--- src/bcmsdio/sys/bcmsdh_sdmmc.c
+++ src/bcmsdio/sys/bcmsdh_sdmmc.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdh_sdmmc.c,v 1.1.2.5.6.19 2009/06/09 00:57:07 Exp $
+ * $Id: bcmsdh_sdmmc.c,v 1.1.2.5.6.27 2009/10/28 19:42:29 Exp $
  */
 #include <typedefs.h>
 
@@ -35,10 +35,16 @@
 #include <sdiovar.h>	/* ioctl/iovars */
 
 #include <linux/mmc/core.h>
-#include <linux/mmc/card.h>
 #include <linux/mmc/sdio_func.h>
 #include <linux/mmc/sdio_ids.h>
 
+#include <dngl_stats.h>
+#include <dhd.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP)
+#include <linux/suspend.h>
+extern volatile bool dhd_mmc_suspend;
+#endif
 #include "bcmsdh_sdmmc.h"
 
 #ifndef BCMSDH_MODULE
@@ -46,8 +52,10 @@
 extern void sdio_function_cleanup(void);
 #endif /* BCMSDH_MODULE */
 
+#if !defined(OOB_INTR_ONLY)
 static void IRQHandler(struct sdio_func *func);
 static void IRQHandlerF2(struct sdio_func *func);
+#endif
 static int sdioh_sdmmc_get_cisaddr(sdioh_info_t *sd, uint32 regaddr);
 extern int sdio_reset_comm(struct mmc_card *card);
 
@@ -63,22 +71,15 @@
 uint sd_hiok = FALSE;	/* Don't use hi-speed mode by default */
 uint sd_msglevel = 0x01;
 uint sd_use_dma = TRUE;
+DHD_PM_RESUME_WAIT_INIT(sdioh_request_byte_wait);
+DHD_PM_RESUME_WAIT_INIT(sdioh_request_word_wait);
+DHD_PM_RESUME_WAIT_INIT(sdioh_request_packet_wait);
+DHD_PM_RESUME_WAIT_INIT(sdioh_request_buffer_wait);
 
 #define DMA_ALIGN_MASK	0x03
 
 int sdioh_sdmmc_card_regread(sdioh_info_t *sd, int func, uint32 regaddr, int regsize, uint32 *data);
 
-
-void SDIO_CLAIM_HOST(uint32 func)
-{
-	sdio_claim_host(gInstance->func[func]);
-}
-
-void SDIO_RELEASE_HOST(uint32 func)
-{
-	sdio_release_host(gInstance->func[func]);
-}
-
 static int
 sdioh_sdmmc_card_enablefuncs(sdioh_info_t *sd)
 {
@@ -105,10 +106,9 @@
 	sd_info(("%s: Card's Common CIS Ptr = 0x%x\n", __FUNCTION__, sd->com_cis_ptr));
 
 	/* Enable Function 1 */
-	gInstance->host_claimed = 0;
-	SDIO_CLAIM_HOST(1);
+	sdio_claim_host(gInstance->func[1]);
 	err_ret = sdio_enable_func(gInstance->func[1]);
-	SDIO_RELEASE_HOST(1);
+	sdio_release_host(gInstance->func[1]);
 	if (err_ret) {
 		sd_err(("bcmsdh_sdmmc: Failed to enable F1 Err: 0x%08x", err_ret));
 	}
@@ -152,7 +152,7 @@
 	gInstance->sd = sd;
 
 	/* Claim host controller */
-	SDIO_CLAIM_HOST(1);
+	sdio_claim_host(gInstance->func[1]);
 
 	sd->client_block_size[1] = 64;
 	err_ret = sdio_set_block_size(gInstance->func[1], 64);
@@ -161,11 +161,11 @@
 	}
 
 	/* Release host controller F1 */
-	SDIO_RELEASE_HOST(1);
+	sdio_release_host(gInstance->func[1]);
 
 	if (gInstance->func[2]) {
 		/* Claim host controller F2 */
-		SDIO_CLAIM_HOST(2);
+		sdio_claim_host(gInstance->func[2]);
 
 		sd->client_block_size[2] = sd_f2_blocksize;
 		err_ret = sdio_set_block_size(gInstance->func[2], sd_f2_blocksize);
@@ -175,7 +175,7 @@
 		}
 
 		/* Release host controller F2 */
-		SDIO_RELEASE_HOST(2);
+		sdio_release_host(gInstance->func[2]);
 	}
 
 	sdioh_sdmmc_card_enablefuncs(sd);
@@ -193,14 +193,14 @@
 	if (sd) {
 
 		/* Disable Function 2 */
-		SDIO_CLAIM_HOST(2);
+		sdio_claim_host(gInstance->func[2]);
 		sdio_disable_func(gInstance->func[2]);
-		SDIO_RELEASE_HOST(2);
+		sdio_release_host(gInstance->func[2]);
 
 		/* Disable Function 1 */
-		SDIO_CLAIM_HOST(1);
+		sdio_claim_host(gInstance->func[1]);
 		sdio_disable_func(gInstance->func[1]);
-		SDIO_RELEASE_HOST(1);
+		sdio_release_host(gInstance->func[1]);
 
 		/* deregister irq */
 		sdioh_sdmmc_osfree(sd);
@@ -280,22 +341,26 @@
 		sd_err(("%s: interrupt handler is NULL, not registering\n", __FUNCTION__));
 		return SDIOH_API_RC_FAIL;
 	}
+#if !defined(OOB_INTR_ONLY)
 	sd->intr_handler = fn;
 	sd->intr_handler_arg = argh;
 	sd->intr_handler_valid = TRUE;
 
 	/* register and unmask irq */
 	if (gInstance->func[2]) {
-		SDIO_CLAIM_HOST(2);
+		sdio_claim_host(gInstance->func[2]);
 		sdio_claim_irq(gInstance->func[2], IRQHandlerF2);
-		SDIO_RELEASE_HOST(2);
+		sdio_release_host(gInstance->func[2]);
 	}
 
 	if (gInstance->func[1]) {
-		SDIO_CLAIM_HOST(1);
+		sdio_claim_host(gInstance->func[1]);
 		sdio_claim_irq(gInstance->func[1], IRQHandler);
-		SDIO_RELEASE_HOST(1);
+		sdio_release_host(gInstance->func[1]);
 	}
+#elif defined(HW_OOB)
+	sdioh_enable_func_intr(2);
+#endif /* defined(OOB_INTR_ONLY) */
 	return SDIOH_API_RC_SUCCESS;
 }
 
@@ -304,24 +369,28 @@
 {
 	sd_trace(("%s: Entering\n", __FUNCTION__));
 
+#if !defined(OOB_INTR_ONLY)
 	if (gInstance->func[1]) {
 		/* register and unmask irq */
-		SDIO_CLAIM_HOST(1);
+		sdio_claim_host(gInstance->func[1]);
 		sdio_release_irq(gInstance->func[1]);
-		SDIO_RELEASE_HOST(1);
+		sdio_release_host(gInstance->func[1]);
 	}
 
 	if (gInstance->func[2]) {
 		/* Claim host controller F2 */
-		SDIO_CLAIM_HOST(2);
+		sdio_claim_host(gInstance->func[2]);
 		sdio_release_irq(gInstance->func[2]);
 		/* Release host controller F2 */
-		SDIO_RELEASE_HOST(2);
+		sdio_release_host(gInstance->func[2]);
 	}
 
 	sd->intr_handler_valid = FALSE;
 	sd->intr_handler = NULL;
 	sd->intr_handler_arg = NULL;
+#elif defined(HW_OOB)
+	sdioh_disable_func_intr(2);
+#endif /*  !defined(OOB_INTR_ONLY) */
 	return SDIOH_API_RC_SUCCESS;
 }
 
@@ -758,7 +848,7 @@
 			 */
 			if (regaddr == SDIOD_CCCR_IOEN) {
 				if (gInstance->func[2]) {
-					SDIO_CLAIM_HOST(2);
+					sdio_claim_host(gInstance->func[2]);
 					if (*byte & SDIO_FUNC_ENABLE_2) {
 						/* Enable Function 2 */
 						err_ret = sdio_enable_func(gInstance->func[2]);
@@ -774,25 +864,40 @@
 								err_ret));
 						}
 					}
-					SDIO_RELEASE_HOST(2);
+					sdio_release_host(gInstance->func[2]);
 				}
-			} else if (regaddr < 0xF0) {
+			}
+#if defined(MMC_SDIO_ABORT)
+			/* to allow abort command through F1 */
+			else if (regaddr == SDIOD_CCCR_IOABORT) {
+				sdio_claim_host(gInstance->func[func]);
+				/*
+				* this sdio_f0_writeb() can be replaced with another api
+				* depending upon MMC driver change.
+				* As of this time, this is temporaray one
+				*/
+				sdio_f0_writeb(gInstance->func[func], *byte,
+					regaddr, &err_ret);
+				sdio_release_host(gInstance->func[func]);
+			}
+#endif /* MMC_SDIO_ABORT */
+			else if (regaddr < 0xF0) {
 				sd_err(("bcmsdh_sdmmc: F0 Wr:0x%02x: write disallowed\n", regaddr));
 			} else {
 				/* Claim host controller, perform F0 write, and release */
-				SDIO_CLAIM_HOST(func);
+				sdio_claim_host(gInstance->func[func]);
 				sdio_f0_writeb(gInstance->func[func], *byte, regaddr, &err_ret);
-				SDIO_RELEASE_HOST(func);
+				sdio_release_host(gInstance->func[func]);
 			}
 		} else {
 			/* Claim host controller, perform Fn write, and release */
-			SDIO_CLAIM_HOST(func);
+			sdio_claim_host(gInstance->func[func]);
 			sdio_writeb(gInstance->func[func], *byte, regaddr, &err_ret);
-			SDIO_RELEASE_HOST(func);
+			sdio_release_host(gInstance->func[func]);
 		}
 	} else { /* CMD52 Read */
 		/* Claim host controller, perform Fn read, and release */
-		SDIO_CLAIM_HOST(func);
+		sdio_claim_host(gInstance->func[func]);
 
 		if (func == 0) {
 			*byte = sdio_f0_readb(gInstance->func[func], regaddr, &err_ret);
@@ -800,7 +905,7 @@
 			*byte = sdio_readb(gInstance->func[func], regaddr, &err_ret);
 		}
 
-		SDIO_RELEASE_HOST(func);
+		sdio_release_host(gInstance->func[func]);
 	}
 
 	if (err_ret) {
@@ -815,7 +920,7 @@
 sdioh_request_word(sdioh_info_t *sd, uint cmd_type, uint rw, uint func, uint addr,
                                    uint32 *word, uint nbytes)
 {
-	int err_ret;
+	int err_ret = SDIOH_API_RC_FAIL;
 
 	if (func == 0) {
 		sd_err(("%s: Only CMD52 allowed to F0.\n", __FUNCTION__));
@@ -825,8 +930,10 @@
 	sd_info(("%s: cmd_type=%d, rw=%d, func=%d, addr=0x%05x, nbytes=%d\n",
 	         __FUNCTION__, cmd_type, rw, func, addr, nbytes));
 
+	DHD_PM_RESUME_WAIT(sdioh_request_word_wait);
+	DHD_PM_RESUME_RETURN_ERROR(SDIOH_API_RC_FAIL);
 	/* Claim host controller */
-	SDIO_CLAIM_HOST(func);
+	sdio_claim_host(gInstance->func[func]);
 
 	if(rw) { /* CMD52 Write */
 		if (nbytes == 4) {
@@ -847,7 +954,7 @@
 	}
 
 	/* Release host controller */
-	SDIO_RELEASE_HOST(func);
+	sdio_release_host(gInstance->func[func]);
 
 	if (err_ret) {
 		sd_err(("bcmsdh_sdmmc: Failed to %s word, Err: 0x%08x",
@@ -870,9 +977,11 @@
 	sd_trace(("%s: Enter\n", __FUNCTION__));
 
 	ASSERT(pkt);
+	DHD_PM_RESUME_WAIT(sdioh_request_packet_wait);
+	DHD_PM_RESUME_RETURN_ERROR(SDIOH_API_RC_FAIL);
 
 	/* Claim host controller */
-	SDIO_CLAIM_HOST(func);
+	sdio_claim_host(gInstance->func[func]);
 	for (pnext = pkt; pnext; pnext = PKTNEXT(sd->osh, pnext)) {
 		uint pkt_len = PKTLEN(sd->osh, pnext);
 		pkt_len += 3;
@@ -930,7 +1039,7 @@
 	}
 
 	/* Release host controller */
-	SDIO_RELEASE_HOST(func);
+	sdio_release_host(gInstance->func[func]);
 
 	sd_trace(("%s: Exit\n", __FUNCTION__));
 	return ((err_ret == 0) ? SDIOH_API_RC_SUCCESS : SDIOH_API_RC_FAIL);
@@ -957,11 +1066,17 @@
 
 	sd_trace(("%s: Enter\n", __FUNCTION__));
 
+	DHD_PM_RESUME_WAIT(sdioh_request_buffer_wait);
+	DHD_PM_RESUME_RETURN_ERROR(SDIOH_API_RC_FAIL);
 	/* Case 1: we don't have a packet. */
 	if (pkt == NULL) {
 		sd_data(("%s: Creating new %s Packet, len=%d\n",
 		         __FUNCTION__, write ? "TX" : "RX", buflen_u));
+#ifdef DHD_USE_STATIC_BUF
+		if (!(mypkt = PKTGET_STATIC(sd->osh, buflen_u, write ? TRUE : FALSE))) {
+#else
 		if (!(mypkt = PKTGET(sd->osh, buflen_u, write ? TRUE : FALSE))) {
+#endif /* DHD_USE_STATIC_BUF */
 			sd_err(("%s: PKTGET failed: len %d\n",
 			           __FUNCTION__, buflen_u));
 			return SDIOH_API_RC_FAIL;
@@ -978,8 +1093,11 @@
 		if (!write) {
 			bcopy(PKTDATA(sd->osh, mypkt), buffer, buflen_u);
 		}
-
+#ifdef DHD_USE_STATIC_BUF
+		PKTFREE_STATIC(sd->osh, mypkt, write ? TRUE : FALSE);
+#else
 		PKTFREE(sd->osh, mypkt, write ? TRUE : FALSE);
+#endif /* DHD_USE_STATIC_BUF */
 	} else if (((uint32)(PKTDATA(sd->osh, pkt)) & DMA_ALIGN_MASK) != 0) {
 		/* Case 2: We have a packet, but it is unaligned. */
 
@@ -988,7 +1106,11 @@
 
 		sd_data(("%s: Creating aligned %s Packet, len=%d\n",
 		         __FUNCTION__, write ? "TX" : "RX", PKTLEN(sd->osh, pkt)));
+#ifdef DHD_USE_STATIC_BUF
+		if (!(mypkt = PKTGET_STATIC(sd->osh, PKTLEN(sd->osh, pkt), write ? TRUE : FALSE))) {
+#else
 		if (!(mypkt = PKTGET(sd->osh, PKTLEN(sd->osh, pkt), write ? TRUE : FALSE))) {
+#endif /* DHD_USE_STATIC_BUF */
 			sd_err(("%s: PKTGET failed: len %d\n",
 			           __FUNCTION__, PKTLEN(sd->osh, pkt)));
 			return SDIOH_API_RC_FAIL;
@@ -1009,8 +1131,11 @@
 			      PKTDATA(sd->osh, pkt),
 			      PKTLEN(sd->osh, mypkt));
 		}
-
+#ifdef DHD_USE_STATIC_BUF
+		PKTFREE_STATIC(sd->osh, mypkt, write ? TRUE : FALSE);
+#else
 		PKTFREE(sd->osh, mypkt, write ? TRUE : FALSE);
+#endif /* DHD_USE_STATIC_BUF */
 	} else { /* case 3: We have a packet and it is aligned. */
 		sd_data(("%s: Aligned %s Packet, direct DMA\n",
 		         __FUNCTION__, write ? "Tx" : "Rx"));
@@ -1025,6 +1150,10 @@
 {
 	sd_trace(("%s: Enter\n", __FUNCTION__));
 
+#if defined(MMC_SDIO_ABORT)
+	/* issue abort cmd52 command through F1 */
+	sdioh_request_byte(sd, SD_IO_OP_WRITE, SDIO_FUNC_0, SDIOD_CCCR_IOABORT, &t_func);
+#endif /* defined(MMC_SDIO_ABORT) */
 
 	sd_trace(("%s: Exit\n", __FUNCTION__));
 	return SDIOH_API_RC_SUCCESS;
@@ -1079,6 +1208,7 @@
 	return SUCCESS;
 }
 
+#if !defined(OOB_INTR_ONLY)
 /* bcmsdh_sdmmc interrupt handler */
 static void IRQHandler(struct sdio_func *func)
 {
@@ -1089,7 +1219,7 @@
 
 	ASSERT(sd != NULL);
 	sdio_release_host(gInstance->func[0]);
-	gInstance->host_claimed = 1;
+
 	if (sd->use_client_ints) {
 		sd->intrcount++;
 		ASSERT(sd->intr_handler);
@@ -1101,7 +1231,6 @@
 		sd_err(("%s: Not ready for intr: enabled %d, handler %p\n",
 		        __FUNCTION__, sd->client_intr_enabled, sd->intr_handler));
 	}
-	gInstance->host_claimed = 0;
 
 	sdio_claim_host(gInstance->func[0]);
 }
@@ -1204,11 +1334,17 @@
 			sdioh_sdmmc_card_enablefuncs(sd);
 			}
 		} else {
+#if !defined(OOB_INTR_ONLY)
 			sdio_claim_host(gInstance->func[0]);
 			sdio_claim_irq(gInstance->func[2], IRQHandlerF2);
 			sdio_claim_irq(gInstance->func[1], IRQHandler);
 			sdio_release_host(gInstance->func[0]);
-
+#else /* defined(OOB_INTR_ONLY) */
+#if defined(HW_OOB)
+			sdioh_enable_func_intr(2);
+#endif
+			bcmsdh_oob_intr_set(TRUE);
+#endif /* !defined(OOB_INTR_ONLY) */
 		}
 	}
 	else
@@ -1227,10 +1363,17 @@
 		polling
 	*/
 	if (gInstance->func[0]) {
+#if !defined(OOB_INTR_ONLY)
 		sdio_claim_host(gInstance->func[0]);
 		sdio_release_irq(gInstance->func[1]);
 		sdio_release_irq(gInstance->func[2]);
 		sdio_release_host(gInstance->func[0]);
+#else /* defined(OOB_INTR_ONLY) */
+#if defined(HW_OOB)
+		sdioh_disable_func_intr(2);
+#endif
+		bcmsdh_oob_intr_set(FALSE);
+#endif /* !defined(OOB_INTR_ONLY) */
 	}
 	else
 		sd_err(("%s Failed\n", __FUNCTION__));
