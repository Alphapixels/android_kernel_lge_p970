diff --git a/drivers/net/wireless/bcm43291/Makefile b/drivers/net/wireless/bcm43291/Makefile
index aab262e..a412320 100644
--- a/drivers/net/wireless/bcm43291/Makefile
+++ b/drivers/net/wireless/bcm43291/Makefile
@@ -47,6 +47,7 @@ EXTRA_CFLAGS = \
 	-DBDC \
 	-DTOE \
 	-DDHD_BCMEVENTS \
+	-DSHOW_EVENTS \
 	-DBCMSDIO \
 	-DDHD_GPL \
 	-DBCMLXSDMMC \
@@ -59,18 +60,20 @@ EXTRA_CFLAGS = \
 	-I$(SRCROOT)/dongle \
 	-I$(SRCROOT)/wl/sys \
 	\
-	-DIOCTL_RESP_TIMEOUT=6000 \
+	-DIOCTL_RESP_TIMEOUT=2000 \
 	-DSDIO_VENDOR_ID_BROADCOM=0x2d0 \
 	-DSDIO_DEVICE_ID_BROADCOM_4325=0x4c6 \
 	-DSDIO_DEVICE_ID_BROADCOM_4329=0x4329 \
 	-DANDROID_SPECIFIC \
 	-DOEM_ANDROID -DEMBEDDED_PLATFORM \
 	-DDHD_SCHED \
-	-DCUSTOMER_HW2 \
+	-DMMC_SDIO_ABORT \
+	-DCONFIG_FIRST_SCAN \
+	-DCSCAN \
 	-DCONFIG_WIFI_CONTROL_FUNC \
-#	-DSDIO_ISR_THREAD \
-#	-DSHOW_EVENTS \
 #	\
+	#-DGET_CUSTOM_MAC_ENABLE \
+	#-DSDIO_ISR_THREAD \
 	-fshort-wchar \
 	-D__KERNEL__ \
 	-Iinclude \
diff --git a/drivers/net/wireless/bcm43291/src/GNUmakefile.inc b/drivers/net/wireless/bcm43291/src/GNUmakefile.inc
index 3ca3bdd..ae08afe 100644
--- a/drivers/net/wireless/bcm43291/src/GNUmakefile.inc
+++ b/drivers/net/wireless/bcm43291/src/GNUmakefile.inc
@@ -4,7 +4,7 @@
 #  and sources(windows style makefile). it doesn't depend on 
 #  Makerules.env except to get SRCBASE if not yet defined. 
 #
-#  $Id: GNUmakefile.inc,v 1.103.50.1 2009/05/20 19:39:45 Exp $
+#  $Id: GNUmakefile.inc,v 1.103.50.2 2009/08/18 18:42:30 Exp $
 
 SHELL=bash
 export SHELL
@@ -540,11 +540,15 @@ define calculate_dependencies
 	| sed '\''s?$*\.o[ :]*?$@ &?g'\'' >$@'
 endef
 
+# OTHER_SOURCES_PROCESSED removes recursive build of OTHER_SOURCES, when that
+# switch is set from cmd line
 ifdef OTHER_SOURCES
+ifndef OTHER_SOURCES_PROCESSED
 all clean :: $(OTHER_SOURCES)
 	@echo "Go through OTHER_SOURCES: $(OTHER_SOURCES)"
-	$(foreach SRCFILE,$(OTHER_SOURCES),$(MAKE) SRCFILE=$(SRCFILE) TTYPE=$(TTYPE) $@; )
-endif
+	$(foreach SRCFILE,$(OTHER_SOURCES),$(MAKE) SRCFILE=$(SRCFILE) TTYPE=$(TTYPE) OTHER_SOURCES_PROCESSED=true $@; )
+endif # OTHER_SOURCES_PROCESSED
+endif # OTHER_SOURCES
 
 vpath %.Lib $(LIBVPATH)
 vpath %.LIB $(LIBVPATH)
diff --git a/drivers/net/wireless/bcm43291/src/Makerules b/drivers/net/wireless/bcm43291/src/Makerules
index a60d3db..06ee2fe 100644
--- a/drivers/net/wireless/bcm43291/src/Makerules
+++ b/drivers/net/wireless/bcm43291/src/Makerules
@@ -22,7 +22,7 @@
 # software in any way with any other Broadcom software provided under a license
 # other than the GPL, without Broadcom's express prior written consent.
 #
-# $Id: Makerules,v 2.69.30.3.2.6.106.1 2010/05/11 17:53:09 Exp $
+# $Id: Makerules,v 2.69.30.3.2.6 2009/05/15 23:06:59 Exp $
 
 # first rule (default)
 all:
@@ -132,9 +132,8 @@ ifeq ($(TARGETOS), unix)
 	ifeq ($(TARGETENV), android)
 		TARGET_PREFIX = arm-eabi-
         	GCFLAGS += -Dlinux
-			GCFLAGS += -I/projects/hnd/tools/linux/hndtools-arm-eabi-4.2.1/android-ndk-r3/build/platforms/android-3/arch-arm/usr/include
-#        	GCFLAGS += -I/projects/hnd/tools/linux/hndtools-arm-eabi-4.2.1/arm-eabi/include/bionic/libc/include
-#        	GCFLAGS += -I/projects/hnd/tools/linux/hndtools-arm-eabi-4.2.1/arm-eabi/include/bionic/libc/arch-arm/include/
+        	GCFLAGS += -I/projects/hnd/tools/linux/hndtools-arm-eabi-4.2.1/arm-eabi/include/bionic/libc/include
+        	GCFLAGS += -I/projects/hnd/tools/linux/hndtools-arm-eabi-4.2.1/arm-eabi/include/bionic/libc/arch-arm/include/
         	GCFLAGS += -I/tools/linux/src/linux-2.6.25-01843-gfea26b0/include/
 	else
 	ifeq ($(TARGETENV), linuxarm_omap)
diff --git a/drivers/net/wireless/bcm43291/src/bcmsdio/linux/Makefile b/drivers/net/wireless/bcm43291/src/bcmsdio/linux/Makefile
index 41ed016..0b507ff 100644
--- a/drivers/net/wireless/bcm43291/src/bcmsdio/linux/Makefile
+++ b/drivers/net/wireless/bcm43291/src/bcmsdio/linux/Makefile
@@ -21,7 +21,7 @@
 # software in any way with any other Broadcom software provided under a license
 # other than the GPL, without Broadcom's express prior written consent.
 #
-# $Id: Makefile,v 1.5.8.4.6.1 2009/01/26 20:28:33 Exp $
+# $Id: Makefile,v 1.5.8.4.6.2 2010/04/09 23:54:38 Exp $
 #
 
 # Try a couple of places for LINUXDIR if not specified
diff --git a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmpcispi.c b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmpcispi.c
index eef3043..1a8b671 100644
--- a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmpcispi.c
+++ b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmpcispi.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmpcispi.c,v 1.22.2.4.4.5.226.1 2010/11/02 03:19:47 Exp $
+ * $Id: bcmpcispi.c,v 1.22.2.4.4.5.6.1 2010/08/13 00:26:05 Exp $
  */
 
 #include <typedefs.h>
diff --git a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh.c b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh.c
index 24deb88..4bf5889 100644
--- a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh.c
+++ b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh.c
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdh.c,v 1.35.2.1.4.8.6.6.20.4.18.4 2010/11/02 20:22:22 Exp $
+ * $Id: bcmsdh.c,v 1.35.2.1.4.8.6.13 2010/04/06 03:26:57 Exp $
  */
 /* ****************** BCMSDH Interface Functions *************************** */
 
@@ -594,16 +594,6 @@ bcmsdh_stop(void *sdh)
 	return sdioh_stop(bcmsdh->sdioh);
 }
 
-int
-bcmsdh_waitlockfree(void *sdh)
-{
-	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *)sdh;
-	if (!bcmsdh)
-		bcmsdh = l_bcmsdh;
-
-	return sdioh_waitlockfree(bcmsdh->sdioh);
-}
-
 
 int
 bcmsdh_query_device(void *sdh)
diff --git a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh_linux.c b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh_linux.c
index f410fa2..c5cf7b2 100644
--- a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh_linux.c
+++ b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh_linux.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdh_linux.c,v 1.42.10.10.2.6.20.5.2.5 2010/11/02 22:27:20 Exp $
+ * $Id: bcmsdh_linux.c,v 1.42.10.10.2.14.4.2 2010/09/15 00:30:11 Exp $
  */
 
 /**
@@ -87,7 +87,7 @@ static bcmsdh_hc_t *sdhcinfo = NULL;
 static bcmsdh_driver_t drvinfo = {NULL, NULL};
 
 /* debugging macros */
-#define SDLX_MSG(x) //printk x // louislee
+#define SDLX_MSG(x)
 
 /**
  * Checks to see if vendor and device IDs match a supported SDIO Host Controller.
@@ -192,13 +192,11 @@ int bcmsdh_probe(struct device *dev)
 
 #if defined(OOB_INTR_ONLY)
 #ifdef HW_OOB
-	irq_flags =
-		IORESOURCE_IRQ | IORESOURCE_IRQ_LOWLEVEL | IORESOURCE_IRQ_SHAREABLE;
+	irq_flags = \
+		IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL | IORESOURCE_IRQ_SHAREABLE;
 #else
 	irq_flags = IRQF_TRIGGER_FALLING;
 #endif /* HW_OOB */
-
-	/* Get CUSTOMER's specific OOB IRQ parametres as Irq number as Irq type */
 	irq = dhd_customer_oob_irq_map(&irq_flags);
 	if  (irq < 0) {
 		SDLX_MSG(("%s: Host irq is not defined\n", __FUNCTION__));
@@ -350,11 +348,15 @@ static struct pci_driver bcmsdh_pci_driver = {
 	};
 
 
-extern uint sd_pci_slot;	/* Force detection to a particular PCI slot only */
-				/* Allow for having multiple WL devices at once in a PC */
-				/* Only one instance will be useable at a time */
-				/* Upper word is bus number, lower word is slot number */
-				/* Default value of 0xFFFFffff turns this off */
+extern uint sd_pci_slot;	/* Force detection to a particular PCI */
+							/* slot only . Allows for having multiple */
+							/* WL devices at once in a PC */
+							/* Only one instance of dhd will be */
+							/* usable at a time */
+							/* Upper word is bus number, */
+							/* lower word is slot number */
+							/* Default value of 0xFFFFffff turns this */
+							/* off */
 module_param(sd_pci_slot, uint, 0);
 
 
@@ -373,24 +375,23 @@ bcmsdh_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	bcmsdh_info_t *sdh = NULL;
 	int rc;
 
-	if (sd_pci_slot != 0xffffffff) {
-		if (pdev->bus->number != (sd_pci_slot >> 16) ||
-		    PCI_SLOT(pdev->devfn) != (sd_pci_slot & 0xffff)) {
-			SDLX_MSG(("%s: %s: bus %X, slot %X, vendor %X, "
-			          "device %X (but want bus %X: slot %X)\n",
+	if (sd_pci_slot != 0xFFFFffff) {
+		if (pdev->bus->number != (sd_pci_slot>>16) ||
+			PCI_SLOT(pdev->devfn) != (sd_pci_slot&0xffff)) {
+			SDLX_MSG(("%s: %s: bus %X, slot %X, vend %X, dev %X\n",
 			          __FUNCTION__,
 			          bcmsdh_chipmatch(pdev->vendor, pdev->device) ?
-			          "Found compatible SDIOHC" : "Probing unknown device",
+			          "Found compatible SDIOHC" :
+			          "Probing unknown device",
 			          pdev->bus->number, PCI_SLOT(pdev->devfn),
-			          pdev->vendor, pdev->device,
-			          sd_pci_slot >> 16, sd_pci_slot & 0xffff));
+			          pdev->vendor, pdev->device));
 			return -ENODEV;
 		}
-		SDLX_MSG(("%s: %s: bus %X, slot %X, vendor %X, "
-		          "device %X (good PCI location)\n",
+		SDLX_MSG(("%s: %s: bus %X, slot %X, vendor %X, device %X (good PCI location)\n",
 		          __FUNCTION__,
 		          bcmsdh_chipmatch(pdev->vendor, pdev->device) ?
-		          "Using compatible SDIOHC" : "WARNING, forced use of unknown device",
+		          "Using compatible SDIOHC" :
+		          "WARNING, forced use of unkown device",
 		          pdev->bus->number, PCI_SLOT(pdev->devfn),
 		          pdev->vendor, pdev->device));
 	}
@@ -610,6 +611,8 @@ static irqreturn_t wlan_oob_irq(int irq, void *dev_id)
 		return IRQ_HANDLED;
 	}
 
+	WAKE_LOCK_TIMEOUT(dhdp, WAKE_LOCK_TMOUT, 25);
+
 	dhdsdio_isr((void *)dhdp->bus);
 
 	return IRQ_HANDLED;
@@ -621,22 +624,22 @@ int bcmsdh_register_oob_intr(void * dhdp)
 
 	SDLX_MSG(("%s Enter\n", __FUNCTION__));
 
+/* Example of  HW_OOB for HW2: please refer to your host  specifiction */
+/* sdhcinfo->oob_flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL | IORESOURCE_IRQ_SHAREABLE; */
+
 	dev_set_drvdata(sdhcinfo->dev, dhdp);
 
 	if (!sdhcinfo->oob_irq_registered) {
-
-		SDLX_MSG(("%s IRQ=%d Type=%X \n", __FUNCTION__,
+		SDLX_MSG(("%s IRQ=%d Type=%X \n", __FUNCTION__, \
 			(int)sdhcinfo->oob_irq, (int)sdhcinfo->oob_flags));
-
 		/* Refer to customer Host IRQ docs about proper irqflags definition */
 		error = request_irq(sdhcinfo->oob_irq, wlan_oob_irq, sdhcinfo->oob_flags,
 		"bcmsdh_sdmmc", NULL);
+		if (error)
+			return -ENODEV;
 
-#ifndef set_irq_wake
-		irq_set_irq_wake(sdhcinfo->oob_irq, 1);
-#else
-		set_irq_wake(sdhcinfo->oob_irq, 1);
-#endif
+		//set_irq_wake(sdhcinfo->oob_irq, 1);
+		enable_irq_wake(sdhcinfo->oob_irq);
 		sdhcinfo->oob_irq_registered = TRUE;
 	}
 
@@ -647,19 +650,13 @@ void bcmsdh_unregister_oob_intr(void)
 {
 	SDLX_MSG(("%s: Enter\n", __FUNCTION__));
 
-	if (sdhcinfo->oob_irq_registered == TRUE) {
-#ifndef set_irq_wake
-		irq_set_irq_wake(sdhcinfo->oob_irq, 0);
-#else
-		set_irq_wake(sdhcinfo->oob_irq, 0);
-#endif
+	//set_irq_wake(sdhcinfo->oob_irq, 0);
+	disable_irq_wake(sdhcinfo->oob_irq);
 		disable_irq(sdhcinfo->oob_irq);	/* just in case.. */
 		free_irq(sdhcinfo->oob_irq, NULL);
 		sdhcinfo->oob_irq_registered = FALSE;
-	}
 }
 #endif /* defined(OOB_INTR_ONLY) */
-
 /* Module parameters specific to each host-controller driver */
 
 extern uint sd_msglevel;	/* Debug message level */
@@ -716,7 +713,6 @@ EXPORT_SYMBOL(bcmsdh_register);
 EXPORT_SYMBOL(bcmsdh_unregister);
 EXPORT_SYMBOL(bcmsdh_chipmatch);
 EXPORT_SYMBOL(bcmsdh_reset);
-EXPORT_SYMBOL(bcmsdh_waitlockfree);
 
 EXPORT_SYMBOL(bcmsdh_get_dstatus);
 EXPORT_SYMBOL(bcmsdh_cfg_read_word);
diff --git a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh_sdmmc.c b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh_sdmmc.c
index ead1115..f0d4a67 100644
--- a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh_sdmmc.c
+++ b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh_sdmmc.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdh_sdmmc.c,v 1.1.2.5.6.18.4.6.2.5 2010/11/02 19:30:01 Exp $
+ * $Id: bcmsdh_sdmmc.c,v 1.1.2.5.6.30.4.1 2010/09/02 23:12:21 Exp $
  */
 #include <typedefs.h>
 
@@ -302,8 +302,7 @@ sdioh_interrupt_register(sdioh_info_t *sd, sdioh_cb_fn_t fn, void *argh)
 	}
 #elif defined(HW_OOB)
 	sdioh_enable_func_intr();
-#endif /* !defined(OOB_INTR_ONLY) */
-
+#endif /* defined(OOB_INTR_ONLY) */
 	return SDIOH_API_RC_SUCCESS;
 }
 
@@ -676,8 +675,7 @@ sdioh_enable_hw_oob_intr(sdioh_info_t *sd, bool enable)
 		data = 3;	/* enable hw oob interrupt */
 	else
 		data = 4;	/* disable hw oob interrupt */
-
-	/*data |= 4;*/		/* Active HIGH */ // louislee : it must be active low!!!!!!!!!!!
+	data |= 4;		/* Active HIGH */
 
 	status = sdioh_request_byte(sd, SDIOH_WRITE, 0, 0xf2, &data);
 	return status;
@@ -758,7 +756,9 @@ sdioh_cis_read(sdioh_info_t *sd, uint func, uint8 *cisd, uint32 length)
 extern SDIOH_API_RC
 sdioh_request_byte(sdioh_info_t *sd, uint rw, uint func, uint regaddr, uint8 *byte)
 {
-	int err_ret=0;
+/* LGE_CHANGE_S, [dongp.kim@lge.com], 2010-04-22, WBT Fix */
+	int err_ret = 0; 
+/* LGE_CHANGE_S, [dongp.kim@lge.com], 2010-04-22, WBT Fix */
 
 	sd_info(("%s: rw=%d, func=%d, addr=0x%05x\n", __FUNCTION__, rw, func, regaddr));
 
@@ -967,19 +967,6 @@ sdioh_request_packet(sdioh_info_t *sd, uint fix_inc, uint write, uint func,
 	return ((err_ret == 0) ? SDIOH_API_RC_SUCCESS : SDIOH_API_RC_FAIL);
 }
 
-#if defined(CONFIG_LGE_BCM432X_PATCH)
-#define PKTALIGN(osh, p, len, align)					\
-	do {								\
-		uint datalign;						\
-		datalign = (uintptr)PKTDATA((osh), (p));		\
-		datalign = ROUNDUP(datalign, (align)) - datalign;	\
-		ASSERT(datalign < (align));				\
-		ASSERT(PKTLEN((osh), (p)) >= ((len) + datalign));	\
-		if (datalign)						\
-			PKTPULL((osh), (p), datalign);			\
-		PKTSETLEN((osh), (p), (len));				\
-	} while (0)
-#endif	/* CONFIG_LGE_BCM432X_PATCH */
 
 /*
  * This function takes a buffer or packet, and fixes everything up so that in the
@@ -1008,25 +995,14 @@ sdioh_request_buffer(sdioh_info_t *sd, uint pio_dma, uint fix_inc, uint write, u
 		sd_data(("%s: Creating new %s Packet, len=%d\n",
 		         __FUNCTION__, write ? "TX" : "RX", buflen_u));
 #ifdef DHD_USE_STATIC_BUF
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
 		if (!(mypkt = PKTGET_STATIC(sd->osh, buflen_u, write ? TRUE : FALSE))) {
 #else
-		if (!(mypkt = PKTGET_STATIC(sd->osh, buflen_u + DHD_SDALIGN, write ? TRUE : FALSE))) {
-#endif	/* CONFIG_LGE_BCM432X_PATCH */
-#else
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
 		if (!(mypkt = PKTGET(sd->osh, buflen_u, write ? TRUE : FALSE))) {
-#else
-		if (!(mypkt = PKTGET(sd->osh, buflen_u + DHD_SDALIGN, write ? TRUE : FALSE))) {
-#endif	/* CONFIG_LGE_BCM432X_PATCH */
 #endif /* DHD_USE_STATIC_BUF */
 			sd_err(("%s: PKTGET failed: len %d\n",
 			           __FUNCTION__, buflen_u));
 			return SDIOH_API_RC_FAIL;
 		}
-#if defined(CONFIG_LGE_BCM432X_PATCH)	
-		PKTALIGN(osh, mypkt, buflen_u, DHD_SDALIGN);
-#endif	/* CONFIG_LGE_BCM432X_PATCH */
 
 		/* For a write, copy the buffer data into the packet. */
 		if (write) {
@@ -1054,25 +1030,14 @@ sdioh_request_buffer(sdioh_info_t *sd, uint pio_dma, uint fix_inc, uint write, u
 		sd_data(("%s: Creating aligned %s Packet, len=%d\n",
 		         __FUNCTION__, write ? "TX" : "RX", PKTLEN(sd->osh, pkt)));
 #ifdef DHD_USE_STATIC_BUF
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
 		if (!(mypkt = PKTGET_STATIC(sd->osh, PKTLEN(sd->osh, pkt), write ? TRUE : FALSE))) {
 #else
-		if (!(mypkt = PKTGET_STATIC(sd->osh, PKTLEN(sd->osh, pkt) + DHD_SDALIGN, write ? TRUE : FALSE))) {
-#endif /* CONFIG_LGE_BCM432X_PATCH */
-#else
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
 		if (!(mypkt = PKTGET(sd->osh, PKTLEN(sd->osh, pkt), write ? TRUE : FALSE))) {
-#else
-		if (!(mypkt = PKTGET(sd->osh, PKTLEN(sd->osh, pkt) + DHD_SDALIGN, write ? TRUE : FALSE))) {
-#endif
 #endif /* DHD_USE_STATIC_BUF */
 			sd_err(("%s: PKTGET failed: len %d\n",
 			           __FUNCTION__, PKTLEN(sd->osh, pkt)));
 			return SDIOH_API_RC_FAIL;
 		}
-#if defined(CONFIG_LGE_BCM432X_PATCH)	
-		PKTALIGN(osh, mypkt, PKTLEN(sd->osh, pkt), DHD_SDALIGN);
-#endif	/* CONFIG_LGE_BCM432X_PATCH */
 
 		/* For a write, copy the buffer data into the packet. */
 		if (write) {
@@ -1341,9 +1306,3 @@ sdioh_stop(sdioh_info_t *si)
 		sd_err(("%s Failed\n", __FUNCTION__));
 	return (0);
 }
-
-	int
-sdioh_waitlockfree(sdioh_info_t *sd)
-{
-	return (1);
-}
diff --git a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh_sdmmc_linux.c b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh_sdmmc_linux.c
index 4574a34..8992a42 100644
--- a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh_sdmmc_linux.c
+++ b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdh_sdmmc_linux.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdh_sdmmc_linux.c,v 1.1.2.5.6.7.4.4.2.4 2010/11/02 19:30:01 Exp $
+ * $Id: bcmsdh_sdmmc_linux.c,v 1.1.2.5.6.17 2010/08/13 00:36:19 Exp $
  */
 
 #include <typedefs.h>
@@ -54,14 +54,11 @@
 #endif /* !defined(SDIO_DEVICE_ID_BROADCOM_4329) */
 #if !defined(SDIO_DEVICE_ID_BROADCOM_4319)
 #define SDIO_DEVICE_ID_BROADCOM_4319	0x4319
-#endif /* !defined(SDIO_DEVICE_ID_BROADCOM_4319) */
+#endif /* !defined(SDIO_DEVICE_ID_BROADCOM_4329) */
 
 #include <bcmsdh_sdmmc.h>
 
 #include <dhd_dbg.h>
-#ifdef CONFIG_CFG80211
-#include <wl_cfg80211.h>
-#endif
 
 extern void sdioh_sdmmc_devintr_off(sdioh_info_t *sd);
 extern void sdioh_sdmmc_devintr_on(sdioh_info_t *sd);
@@ -112,9 +109,6 @@ static int bcmsdh_sdmmc_probe(struct sdio_func *func,
 	gInstance->func[func->num] = func;
 
 	if (func->num == 2) {
-#ifdef CONFIG_CFG80211
-		wl_cfg80211_sdio_func(func);
-#endif
 		sd_trace(("F2 found, calling bcmsdh_probe...\n"));
 		ret = bcmsdh_probe(&sdmmc_dev);
 	}
@@ -259,8 +253,6 @@ int sdio_function_init(void)
 	bzero(&sdmmc_dev, sizeof(sdmmc_dev));
 	error = sdio_register_driver(&bcmsdh_sdmmc_driver);
 
-	sd_trace(("bcmsdh_sdmmc: %s returned %d \n", __FUNCTION__, error));
-
 
 	return error;
 }
diff --git a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdspi.c b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdspi.c
index 43dcd6e..636539b 100644
--- a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdspi.c
+++ b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdspi.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdspi.c,v 1.14.4.2.4.4.6.4.20.1.22.1 2010/08/26 21:39:09 Exp $
+ * $Id: bcmsdspi.c,v 1.14.4.2.4.4.6.5 2010/03/10 03:09:48 Exp $
  */
 
 #include <typedefs.h>
@@ -708,12 +708,6 @@ sdioh_stop(sdioh_info_t *sd)
 	return SUCCESS;
 }
 
-int
-sdioh_waitlockfree(sdioh_info_t *sd)
-{
-	return SUCCESS;
-}
-
 
 /*
  * Private/Static work routines
diff --git a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdstd.c b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdstd.c
index 6d19485..0ca1f8f 100644
--- a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdstd.c
+++ b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdstd.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdstd.c,v 1.64.4.1.4.4.2.10.4.7.10.3 2010/11/02 19:30:01 Exp $
+ * $Id: bcmsdstd.c,v 1.64.4.1.4.4.2.18 2010/08/17 17:00:48 Exp $
  */
 
 #include <typedefs.h>
@@ -1127,13 +1127,6 @@ sdioh_stop(sdioh_info_t *sd)
 	return SUCCESS;
 }
 
-int
-sdioh_waitlockfree(sdioh_info_t *sd)
-{
-	sdstd_waitlockfree(sd);
-	return SUCCESS;
-}
-
 static int
 sdstd_check_errs(sdioh_info_t *sdioh_info, uint32 cmd, uint32 arg)
 {
diff --git a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdstd_linux.c b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdstd_linux.c
index d8d6d5d..a8b98e2 100644
--- a/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdstd_linux.c
+++ b/drivers/net/wireless/bcm43291/src/bcmsdio/sys/bcmsdstd_linux.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdstd_linux.c,v 1.11.18.2.236.2 2010/08/31 00:27:07 Exp $
+ * $Id: bcmsdstd_linux.c,v 1.11.18.2.16.1 2010/08/17 17:03:13 Exp $
  */
 
 #include <typedefs.h>
@@ -178,7 +178,6 @@ sdstd_lock(sdioh_info_t *sd)
 {
 	ulong flags;
 	struct sdos_info *sdos;
-	int    wait_count = 0;
 
 	sdos = (struct sdos_info *)sd->sdos_info;
 	ASSERT(sdos);
@@ -186,17 +185,12 @@ sdstd_lock(sdioh_info_t *sd)
 	sd_trace(("%s: %d\n", __FUNCTION__, sd->lockcount));
 
 	spin_lock_irqsave(&sdos->lock, flags);
-	while (sd->lockcount)
-	{
-	    spin_unlock_irqrestore(&sdos->lock, flags);
-	    yield();
-		spin_lock_irqsave(&sdos->lock, flags);
-		if (++wait_count == 10000) {
+	if (sd->lockcount) {
+		sd_err(("%s: Already locked! called from %p\n",
+		       __FUNCTION__,
+		       __builtin_return_address(0)));
 		ASSERT(sd->lockcount == 0);
 	}
-	}
-	if (wait_count)
-		printk("sdstd_lock: wait count = %d\n", wait_count);
 	sdstd_devintr_off(sd);
 	sd->lockcount++;
 	spin_unlock_irqrestore(&sdos->lock, flags);
@@ -222,19 +216,6 @@ sdstd_unlock(sdioh_info_t *sd)
 	spin_unlock_irqrestore(&sdos->lock, flags);
 }
 
-void
-sdstd_waitlockfree(sdioh_info_t *sd)
-{
-	if (sd->lockcount) {
-		printk("wait lock free\n");
-		while (sd->lockcount)
-		{
-		    yield();
-		}
-	}
-}
-
-
 uint16
 sdstd_waitbits(sdioh_info_t *sd, uint16 norm, uint16 err, bool yield)
 {
diff --git a/drivers/net/wireless/bcm43291/src/dhd/exe/GNUmakefile b/drivers/net/wireless/bcm43291/src/dhd/exe/GNUmakefile
index 7600919..901f2ca 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/exe/GNUmakefile
+++ b/drivers/net/wireless/bcm43291/src/dhd/exe/GNUmakefile
@@ -22,7 +22,7 @@
 # software in any way with any other Broadcom software provided under a license
 # other than the GPL, without Broadcom's express prior written consent.
 #
-# $Id: GNUmakefile,v 1.9.24.4.2.4.28.2.2.3 2010/11/11 17:10:07 Exp $
+# $Id: GNUmakefile,v 1.9.24.4.2.4 2009/03/04 03:53:29 Exp $
 
 SRCBASE = ../..
 
@@ -46,20 +46,13 @@ include $(SRCBASE)/Makerules
 CFLAGS += -DSDTEST
 CFLAGS += -DBCMSPI
 
-CFLAGS += -DWLBTAMP
-
-CFLAGS += -DDONGLEOVERLAYS
-GCINCS	+= -I$(SRCBASE)/wl/exe
-
 #-----------------------------------------------------------
 # Linux build
 #
 ifneq ($(findstring $(TARGETENV), "linux linuxmips linuxmips_be linuxarm linuxarm_le linuxarm_omap android"),)
-# the below WL_OID_BASE is not visible from wlioctl.h. Hence including
-# it from here for file wlu_linux_common.c.
-CFLAGS += -DWL_OID_BASE=0
+
 # $(TARGETARCH) is set based on TARGETENV in src/Makerules.* files
-DHD_OBJS := dhdu.o dhdu_linux.o bcmutils.o miniopt.o ucode_download.o wlu_linux_common.o wlu_common.o
+DHD_OBJS := dhdu.o dhdu_linux.o bcmutils.o miniopt.o
 DHD_EXE  := dhd
 
 ifneq ($(findstring x86,$(TARGETARCH)),x86)
@@ -74,7 +67,6 @@ ifeq ($(TARGETENV), linuxarm_omap)
 CFLAGS += -DBGBRD
 endif
 
-vpath %.c $(SRCBASE)/wl/exe
 vpath %.c $(SRCBASE)/shared
 
 all: $(DHD_EXE)
diff --git a/drivers/net/wireless/bcm43291/src/dhd/exe/dhdu.c b/drivers/net/wireless/bcm43291/src/dhd/exe/dhdu.c
index e010212..23bba8d 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/exe/dhdu.c
+++ b/drivers/net/wireless/bcm43291/src/dhd/exe/dhdu.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhdu.c,v 1.52.2.10.2.6.2.9.10.12.2.5 2010/11/04 18:47:59 Exp $
+ * $Id: dhdu.c,v 1.52.2.10.2.6.2.14 2010/01/19 07:24:15 Exp $
  */
 
 /* For backwards compatibility, the absense of the define 'BWL_NO_FILESYSTEM_SUPPORT'
@@ -45,14 +45,13 @@
 #include <bcmutils.h>
 #include <bcmendian.h>
 #include "dhdu.h"
-#include <usbrdl.h>
+
 
 #include "miniopt.h"
 
 #include <errno.h>
 
 #include <trxhdr.h>
-#include "ucode_download.h"
 
 #define stricmp strcasecmp
 #define strnicmp strncasecmp
@@ -75,7 +74,6 @@ static cmd_func_t dhd_dma_mode;
 static cmd_func_t dhd_membytes, dhd_download, dhd_upload, dhd_vars, dhd_idleclock, dhd_idletime;
 static cmd_func_t dhd_logstamp;
 
-static cmd_func_t dhd_proptxstatusmode;
 static int dhd_var_getbuf(void *dhd, char *iovar, void *param, int param_len, void **bufptr);
 static int dhd_var_setbuf(void *dhd, char *iovar, void *param, int param_len);
 
@@ -213,8 +211,6 @@ cmd_t dhd_cmds[] = {
 	"\t              read up to <-c> pkts every <-f> ticks until <-t>\n"
 	"\t              total reads\n"},
 #endif /* SDTEST */
-	{ "dconpoll", dhd_varint, DHD_GET_VAR, DHD_SET_VAR,
-	"g/set dongle console polling intervale(ms)"},
 	{ "sdreg", dhd_sdreg, DHD_GET_VAR, DHD_SET_VAR,
 	"g/set sdpcmdev core register (f1) across SDIO (CMD53)"},
 	{ "sbreg", dhd_sdreg, DHD_GET_VAR, DHD_SET_VAR,
@@ -267,11 +263,6 @@ cmd_t dhd_cmds[] = {
 	"get status of last connection attempt" },
 	{ "ioctl_timeout", dhd_varint, DHD_GET_VAR, DHD_SET_VAR,
 	"IOCTL response timeout (milliseconds)."},
-	{ "ptxmode", dhd_proptxstatusmode, DHD_GET_VAR, DHD_SET_VAR,
-	"set the proptxtstatus operation mode:\n"
-	"0 - Unsupported\n"
-	"1 - Use implied credit from a packet status\n"
-	"2 - Use explicit credit\n" },
 	{ NULL, NULL, 0, 0, NULL }
 };
 
@@ -1457,7 +1448,7 @@ dhd_vars(void *dhd, cmd_t *cmd, char **argv)
 
 #if defined(BWL_FILESYSTEM_SUPPORT)
 static int
-dhd_load_file_bytes(void *dhd, cmd_t *cmd, FILE *fp, int fsize, int start, uint blk_sz)
+dhd_load_file_bytes(void *dhd, cmd_t *cmd, FILE *fp, int fsize, int start)
 {
 	int tot_len = 0;
 	uint read_len;
@@ -1468,12 +1459,10 @@ dhd_load_file_bytes(void *dhd, cmd_t *cmd, FILE *fp, int fsize, int start, uint
 
 	UNUSED_PARAMETER(cmd);
 
-	assert(blk_sz <= MEMBLOCK);
-
 	while (tot_len < fsize) {
 		read_len = fsize - tot_len;
-		if (read_len >= blk_sz)
-			read_len = blk_sz;
+		if (read_len >= MEMBLOCK)
+			read_len = MEMBLOCK;
 		len = fread(memblock, sizeof(uint8), read_len, fp);
 		if ((len < read_len) && !feof(fp)) {
 			fprintf(stderr, "%s: error reading file\n", __FUNCTION__);
@@ -1518,8 +1507,6 @@ dhd_download(void *dhd, cmd_t *cmd, char **argv)
 	uint32 start = 0;
 	int ret = 0;
 	int fsize;
-	uint32 bustype;
-	long filepos;
 
 	FILE *fp = NULL;
 	uint32 memsize;
@@ -1531,16 +1518,7 @@ dhd_download(void *dhd, cmd_t *cmd, char **argv)
 	int opt_err;
 	uint nvram_len;
 	struct trx_header trx_hdr;
-	uint32 trx_hdr_len;
 	bool trx_file = FALSE;
-	uint memblock_sz = MEMBLOCK;
-
-	bool overlays = FALSE, embedded_ucode = FALSE;
-#if defined(DONGLEOVERLAYS)
-	uint32 overlay_sz = 0;			/* size of overlay section of rtecdc.bin */
-	uint8 *overlaytab = NULL;		/* overlay code table */
-	uint32 otable_sz = 0;			/* overlay offsets table size */
-#endif /* DONGLEOVERLAYS */
 
 	/* Parse command-line options */
 	miniopt_init(&opts, "download", "", TRUE);
@@ -1612,129 +1590,18 @@ dhd_download(void *dhd, cmd_t *cmd, char **argv)
 	/* Verify the file is a regular bin file or trx file */
 	{
 		uint32 tmp_len;
-		trx_hdr_len = sizeof(struct trx_header);
+		uint32 trx_hdr_len = sizeof(struct trx_header);
 		tmp_len = fread(&trx_hdr, sizeof(uint8), trx_hdr_len, fp);
 		if (tmp_len == trx_hdr_len) {
 			if (trx_hdr.magic == TRX_MAGIC) {
+				fprintf(stderr, "TRX file\n");
 				trx_file = TRUE;
-				if (trx_hdr.flag_version & TRX_EMBED_UCODE)
-					embedded_ucode = TRUE;
-				if (trx_hdr.flag_version & TRX_OVERLAYS) {
-#if defined(DONGLEOVERLAYS)
-					uint32 offset_ct;
-					uint32 i;
-					uint32 offset;
-					uint32 header_sz;
-
-					/* read the size of the overlay section */
-					tmp_len = fread(&overlay_sz, sizeof(uint8),
-					                sizeof(uint32), fp);
-					if (tmp_len != sizeof(uint32)) {
-						ret = BCME_BADLEN;
-						fprintf(stderr,
-						        "%s: error reading overlay section size\n",
-						        __FUNCTION__);
-						goto exit;
-					}
-					/* read the size of the overlay bookkeeping info */
-					tmp_len = fread(&header_sz, sizeof(uint8),
-					                sizeof(uint32), fp);
-					if (tmp_len != sizeof(uint32)) {
-						ret = BCME_BADLEN;
-						fprintf(stderr,
-						        "%s: error reading header size value\n",
-						        __FUNCTION__);
-						goto exit;
-					}
-					/* read number of offsets in offets table */
-					tmp_len = fread(&offset_ct, sizeof(uint8),
-					                sizeof(uint32), fp);
-					if (tmp_len != sizeof(uint32)) {
-						ret = BCME_BADLEN;
-						fprintf(stderr,
-						        "%s: error reading overlay offset ct\n",
-						        __FUNCTION__);
-						goto exit;
-					}
-					if (offset_ct < 2) {
-						ret = BCME_BADARG;
-						fprintf(stderr, "%s: overlay offset ct %d < 2\n",
-						        __FUNCTION__, offset_ct);
-						goto exit;
-					}
-					/*
-					 * overlaytab contains:
-					 *
-					 * uint32 total size
-					 * uint32 header size
-					 * uint32 offset count
-					 * uint32 * (offset count) overlay offsets
-					 * uint32 region count
-					 * uint32 * (region count) overlay region addresses
-					 * overlay_sz bytes of overlay code/data
-					 */
-					otable_sz = (sizeof(uint32) * 2) + header_sz;
-					overlaytab = malloc(otable_sz + overlay_sz);
-					if (!overlaytab) {
-						ret = BCME_NOMEM;
-						fprintf(stderr,
-						        "%s: malloc err %s: overlay tab %d bytes\n",
-						        __FUNCTION__, strerror(errno),
-						        otable_sz + overlay_sz);
-						goto exit;
-					}
-					/* first uint32 of buf: table size + overlay code size */
-					tmp_len = otable_sz + overlay_sz;
-					memcpy(overlaytab, &tmp_len, sizeof(uint32));
-					memcpy(overlaytab + sizeof(uint32), &header_sz,
-					       sizeof(uint32));
-					memcpy(overlaytab + (sizeof(uint32) * 2), &offset_ct,
-					       sizeof(uint32));
-					/* deduct for the uint32 offset_ct previously read in */
-					header_sz -= sizeof(uint32);
-					/* read offsets & regions table entries */
-					tmp_len = fread(overlaytab + (sizeof(uint32) * 3),
-					                sizeof(uint8),
-					                header_sz, fp);
-					if (tmp_len != header_sz) {
-						ret = BCME_BADLEN;
-						fprintf(stderr,
-						        "%s: read err: overlay offsets & regions\n",
-						        __FUNCTION__);
-						goto exit;
-					}
-					/* normalize the offsets to be 0-based */
-					for (i = 0; i < offset_ct; ++i) {
-						memcpy(&offset, overlaytab + (sizeof(uint32) * 3) +
-						       (sizeof(uint32) * i), sizeof(uint32));
-						offset -= trx_hdr.offsets[0];
-						if (offset & 3)
-							fprintf(stderr,
-							        "offset[%d] (0x%x) not aligned!\n",
-							        i, offset);
-						memcpy(overlaytab + (sizeof(uint32) * 3) +
-						       (sizeof(uint32) * i), &offset,
-						       sizeof(uint32));
-					}
-					overlays = TRUE;
-					fsize = trx_hdr.offsets[0];
-#else
-					fprintf(stderr, "Image contains overlays but overlays "
-					        "not supported by this command\n");
-					ret = BCME_UNSUPPORTED;
-					goto exit;
-#endif /* DONGLEOVERLAYS */
-				/* check trx flag for embedded ucode */
-				} else if (trx_hdr.flag_version & TRX_ROMSIM_IMAGE) {
-					/* trx header fmt: image_size, rom_img_size, rom_load_adr */
-					fprintf(stderr, "dongle RAM Image size %d\n",
-					        trx_hdr.offsets[0]);
-					fprintf(stderr, "dongle ROM Image size %d\n",
-					        trx_hdr.offsets[1]);
-					fprintf(stderr, "dongle ROM Loadaddr 0x%x\n",
-					        trx_hdr.offsets[2]);
+				/* trx header file format: image_size, rom_img_size, rom_load_adr */
+				fprintf(stderr, "dongle RAM Image size %d\n", trx_hdr.offsets[0]);
+				fprintf(stderr, "dongle ROM Image size %d\n", trx_hdr.offsets[1]);
+				fprintf(stderr, "dongle ROM Loadaddr 0x%x\n", trx_hdr.offsets[2]);
 					fsize = trx_hdr.offsets[0] + trx_hdr.offsets[1];
-				}
+				fprintf(stderr, "filesize is %d\n", fsize);
 			}
 			else
 				fseek(fp, 0, SEEK_SET);
@@ -1743,25 +1610,6 @@ dhd_download(void *dhd, cmd_t *cmd, char **argv)
 			fseek(fp, 0, SEEK_SET);
 	}
 
-	/* Check on which bus the dhd driver is sitting. Downloading methodology differs from
-	USB to SDIO.
-	*/
-	{
-		char* bustype_args[] = {"bustype", NULL};
-
-		/* Read the bus type the DHD driver is associated to */
-		if ((ret = dhd_var_get(dhd, NULL, bustype_args))) {
-			fprintf(stderr, "%s: error obtaining bustype\n", __FUNCTION__);
-			goto exit;
-		}
-
-		bustype = *(uint32*)buf;
-	}
-
-	if (trx_file)
-		fsize = trx_hdr.offsets[0];
-
-	if (BUS_TYPE_SDIO == bustype) {
 	if ((ret = dhd_var_get(dhd, NULL, memszargs))) {
 		fprintf(stderr, "%s: error obtaining memsize\n", __FUNCTION__);
 		goto exit;
@@ -1775,117 +1623,44 @@ dhd_download(void *dhd, cmd_t *cmd, char **argv)
 		ret = -1;
 		goto exit;
 	}
-	}
 
 	/* do the download reset if not suppressed */
 	if (reset) {
-		if ((ret = dhd_iovar_setint(dhd, "dwnldstate", TRUE))) {
+		if ((ret = dhd_iovar_setint(dhd, "download", TRUE))) {
 			fprintf(stderr, "%s: failed to put dongle in download mode\n",
 			        __FUNCTION__);
 			goto exit;
 		}
 	}
-
-	if (BUS_TYPE_USB == bustype) {
-		/* store the cur pos pointing to base image which should be written */
-		filepos = ftell(fp);
-		if (-1 == filepos) {
-			fprintf(stderr, "%s: ftell failed.\n", __FUNCTION__);
-		}
-
-		/* In case of USB, we need to write header information also to dongle. */
-		fseek(fp, 0, SEEK_SET);
-
-		if (TRUE == overlays) {
-			/* Load the HDR to RAM */
-			if (dhd_load_file_bytes(dhd, cmd, fp, trx_hdr_len, start, RDL_CHUNK)) {
-
-				fprintf(stderr, "%s: error loading the ramimage at addr 0x%x\n",
-					__FUNCTION__, start);
-					ret = -1;
-					goto exit;
-			}
-			start += trx_hdr_len;
-
-			/* Lets go back to base image address */
-			fseek(fp, filepos, SEEK_SET);
-
-		} else {
-			/* For non-overlay images, download the firmware file as it is */
-			/* The file size is "base_image + TRX_Header_size" */
-			fsize = trx_hdr.offsets[0] + sizeof(struct trx_header);
-		}
-
-		memblock_sz = RDL_CHUNK;
-	}
-
-
+	if (trx_file)
+		fsize = trx_hdr.offsets[0];
 	/* Load the ram image */
-	if (dhd_load_file_bytes(dhd, cmd, fp, fsize, start, memblock_sz)) {
+	if (dhd_load_file_bytes(dhd, cmd, fp, fsize, start)) {
 		fprintf(stderr, "%s: error loading the ramimage at addr 0x%x\n",
 			__FUNCTION__, start);
 			ret = -1;
 			goto exit;
 		}
 	if (trx_file) {
-
-		filepos = ftell(fp);
-		if (-1 == filepos) {
-			fprintf(stderr, "%s: ftell failed.\n", __FUNCTION__);
-		}
-
-		if (overlays) {
-#if defined(DONGLEOVERLAYS)
-			uint8 *bufp = overlaytab;
-			int chunksize = DHD_IOCTL_MAXLEN - (strlen("overlaytab") + 1);
-			int tot_sz = otable_sz + overlay_sz;
-
-			/* append the overlay code to the overlay table */
-			if (fread(overlaytab + otable_sz, sizeof(uint8),
-			          overlay_sz, fp) != overlay_sz) {
-				ret = BCME_BADLEN;
-				fprintf(stderr, "%s: error %s reading overlay section of size %d\n",
-				        __FUNCTION__, strerror(errno), overlay_sz);
-				goto exit;
-			}
-
-			/* copy the overlay table to dhd */
-			while (tot_sz) {
-				if (tot_sz <= chunksize) {
-					chunksize = tot_sz;
-					tot_sz = 0;
-				} else
-					tot_sz -= chunksize;
-
-				if ((ret = dhd_var_setbuf(dhd, "overlaytab", bufp, chunksize))) {
-					fprintf(stderr,
-					        "%s: set overlay chunksize %d failed w/status %d\n",
-					        __FUNCTION__, chunksize, ret);
-					goto exit;
-				}
-				bufp += chunksize;
-			}
-#endif /* DONGLEOVERLAYS */
-		} else if (trx_hdr.flag_version & TRX_ROMSIM_IMAGE) {
 			/* Load the rom library */
 			start = trx_hdr.offsets[2];
 			fsize = trx_hdr.offsets[1];
 
 			fprintf(stderr, "setting the maxsocram value 0x%x \n", start);
-
 			if (dhd_iovar_setint(dhd, "maxsocram", start)) {
-					fprintf(stderr, "%s: setting the maxram size to"
-						"%d failed\n", __FUNCTION__,  start);
+			fprintf(stderr, "%s: setting the maxram size to %d failed\n",
+				__FUNCTION__,  start);
 				goto exit;
 			}
 
-				if (dhd_load_file_bytes(dhd, cmd, fp, fsize, start, memblock_sz)) {
-					fprintf(stderr, "%s: error loading the rom library at"
-						" addr 0x%x\n", __FUNCTION__,  start);
+		if (dhd_load_file_bytes(dhd, cmd, fp, fsize, start)) {
+			fprintf(stderr, "%s: error loading the rom library at addr 0x%x\n",
+				__FUNCTION__,  start);
 				goto exit;
 			}
+
 		}
-	}
+
 	fclose(fp);
 	fp = NULL;
 
@@ -1912,40 +1687,19 @@ dhd_download(void *dhd, cmd_t *cmd, char **argv)
 			goto exit;
 		}
 	}
+
 	/* start running the downloaded code if not suppressed */
 	if (run) {
-		if ((ret = dhd_iovar_setint(dhd, "dwnldstate", FALSE))) {
-
+		if ((ret = dhd_iovar_setint(dhd, "download", FALSE))) {
 			fprintf(stderr, "%s: failed to take dongle out of download mode\n",
 			        __FUNCTION__);
-			/* USB Error return values */
-			if (BUS_TYPE_USB == bustype) {
-				if (ret == -1)
-					fprintf(stderr, "%s: CPU is not in RUNNABLE State\n",
-						__FUNCTION__);
-				else
-					fprintf(stderr, "%s: Error in setting CPU to RUN mode.\n",
-						__FUNCTION__);
-			}
 			goto exit;
 		}
 	}
 
-	if (embedded_ucode) {
-		int retval;
-		/* download the embedded ucode now */
-		retval = proc_ucode_download(fname, dhd);
-		if (retval !=  0)
-			printf("ucode & initvals download has failed\n");
-	}
-
 exit:
 	if (fp)
 		fclose(fp);
-#if defined(DONGLEOVERLAYS)
-	if (overlaytab)
-		free(overlaytab);
-#endif
 
 	return ret;
 #endif /* BWL_FILESYSTEM_SUPPORT */
@@ -2202,22 +1956,6 @@ static dbg_msg_t dhd_msgs[] = {
 };
 
 static int
-dhd_proptxstatusmode(void *dhd, cmd_t *cmd, char **argv)
-{
-	int mode = 0xdead;
-
-	if (argv[1]) {
-		mode = atoi(argv[1]);
-		dhd_iovar_setint(dhd, cmd->name, mode);
-	}
-	else {
-		dhd_iovar_getint(dhd, cmd->name, (int*)(&mode));
-		printf("proptxstatusmode: %d\n", mode);
-	}
-	return 0;
-}
-
-static int
 dhd_msglevel(void *dhd, cmd_t *cmd, char **argv)
 {
 	return dhd_do_msglevel(dhd, cmd, argv, dhd_msgs);
diff --git a/drivers/net/wireless/bcm43291/src/dhd/exe/dhdu_linux.c b/drivers/net/wireless/bcm43291/src/dhd/exe/dhdu_linux.c
index a7588bd..e00c460 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/exe/dhdu_linux.c
+++ b/drivers/net/wireless/bcm43291/src/dhd/exe/dhdu_linux.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhdu_linux.c,v 1.3.10.2.2.3.32.1.18.2 2010/11/04 18:49:35 Exp $
+ * $Id: dhdu_linux.c,v 1.3.10.2.2.3 2009/01/27 01:02:28 Exp $
  */
 
 #include <stdio.h>
diff --git a/drivers/net/wireless/bcm43291/src/dhd/linux/Makefile b/drivers/net/wireless/bcm43291/src/dhd/linux/Makefile
index 865bfd2..1e04107 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/linux/Makefile
+++ b/drivers/net/wireless/bcm43291/src/dhd/linux/Makefile
@@ -21,7 +21,7 @@
 # software in any way with any other Broadcom software provided under a license
 # other than the GPL, without Broadcom's express prior written consent.
 #
-# $Id: Makefile,v 1.55.2.6.2.10.6.17.4.11.2.8 2010/11/11 20:08:16 Exp $
+# $Id: Makefile,v 1.55.2.6.2.10.6.42.4.2 2010/12/02 01:23:07 Exp $
 #
 
 # Try a couple of places for LINUXDIR if not specified
@@ -70,14 +70,14 @@ OBJCOPY := $(CROSS_COMPILE)objcopy
 ifeq ($(SRCBASE),)
 SRCBASE := $(shell /bin/pwd)/../..
 endif
-vpath %.c $(SRCBASE)/dhd/sys $(SRCBASE)/shared $(SRCBASE)/bcmsdio/sys $(SRCBASE)/wl/sys
+vpath %.c $(SRCBASE)/dhd/sys $(SRCBASE)/shared $(SRCBASE)/bcmsdio/sys $(SRCBASE)/wl/sys $(SRCBASE)/crypto
 
 ## Initialize DFLAGS
 DFLAGS :=
 
 
 # basic options (defines in DFLAGS, includes in IFLAGS)
-DFLAGS += -DLINUX -DSRCBASE=\"$(SRCBASE)\" -DBCMDRIVER -DBCMDONGLEHOST -DDHDTHREAD -DBCMWPA2
+DFLAGS += -DLINUX -DSRCBASE=\"$(SRCBASE)\" -DBCMDRIVER -DBCMDONGLEHOST -DDHDTHREAD -DBCMWPA2 -DBCMWAPI_WPI
 DFLAGS += -DUNRELEASEDCHIP
 ifeq ($(BCMQT),1)
 	DFLAGS += -DBCMSLTGT -DBCMQT
@@ -160,12 +160,24 @@ ifeq ($(WLTEST),1)
 endif
 
 ifeq ($(CONFIG_NET_RADIO),y)
-CFILES += wl_iw.c bcmwifi.c
+CFILES +=  bcmwifi.c
+CFILES += wl_iw.c
 else
 	ifeq ($(CONFIG_WIRELESS_EXT),y)
-	CFILES += wl_iw.c bcmwifi.c
+	CFILES += bcmwifi.c
+	CFILES += wl_iw.c
 	endif
 endif
+ifeq ($(BCM_KVER), 2.6)
+CFG80211_KVER:=$(shell echo $(LINUXVER) | cut -c5-6 | sed 's/3[1-9]/true/')
+ifeq ($(CFG80211_KVER), true)
+	ifeq ($(CONFIG_CFG80211),m)
+	DFLAGS += -DCONFIG_CFG80211
+	CFILES += wl_cfg80211.c
+	endif
+endif
+endif
+
 
 OFILES=$(CFILES:.c=.o)
 
@@ -174,27 +186,6 @@ ifneq ($(findstring -debug-,-$(TARGET)-),)
 DFLAGS += -DDHD_DEBUG -DSDTEST
 endif
 
-# Building with -proptxstatus- to enable queuing in host
-ifneq ($(findstring -sdstd-,-$(TARGET)-),)
-ifneq ($(findstring -proptxstatus-,-$(TARGET)-),)
-DFLAGS += -DPROP_TXSTATUS
-endif
-endif
-
-ifneq ($(findstring -sdstd-,-$(TARGET)-),)
-ifneq ($(findstring -dbgwlfc-,-$(TARGET)-),)
-DFLAGS += -DPROP_TXSTATUS_DEBUG
-endif
-endif
-
-# Building with -proptxstatus- to enable queuing in host for usb build
-ifneq ($(findstring -usb-,-$(TARGET)-),)
-ifneq ($(findstring -proptxstatus-,-$(TARGET)-),)
-DFLAGS += -DPROP_TXSTATUS
-endif
-endif
-
-
 # Make big-endian a separate option
 ifneq ($(findstring -be-,-$(TARGET)-),)
 DFLAGS += -DIL_BIGENDIAN
@@ -212,7 +203,7 @@ DFLAGS += -DBDC -DTOE
 DFLAGS += -DDHD_BCMEVENTS -DSHOW_EVENTS
 CFILES += dhd_cdc.c
 ifneq ($(findstring -apsta-,-$(TARGET)-),)
-DFLAGS += -DAP
+DFLAGS += -DAP -DAPSTA_PINGTEST
 endif
 endif
 ifneq ($(findstring -rndis-,-$(TARGET)-),)
@@ -224,8 +215,6 @@ ifneq ($(findstring -usb-,-$(TARGET)-),)
 DFLAGS += -DBCMDHDUSB
 CFILES += dhd_usb_linux.c
 endif
-DFLAGS += -DDONGLEOVERLAYS
-
 ifneq ($(findstring -sdio-,-$(TARGET)-),)
 DFLAGS += -DBCMSDIO
 CFILES += dhd_sdio.c
@@ -244,13 +233,13 @@ DFLAGS += -Dlinux
 DFLAGS += -DBCMDBG
 DFLAGS += -DDHD_USE_STATIC_BUF
 DFLAGS += -DCUSTOMER_HW2
-DFLAGS += -DCONFIG_MACH_MAHIMAHI
-DFLAGS += -DCONFIG_HAS_WAKELOCK
 DFLAGS += -DCUSTOM_OOB_GPIO_NUM=152
 DFLAGS += -DOOB_INTR_ONLY
 DFLAGS += -DMMC_SDIO_ABORT
 DFLAGS += -DSOFTAP
+DFLAGS += -DKEEP_ALIVE
 DFLAGS += -DPNO_SUPPORT
+DFLAGS += -DCONFIG_FIRST_SCAN
 else
 ifneq ($(findstring -oob-,-$(TARGET)-),)
 DFLAGS += -DOOB_INTR_ONLY
@@ -318,22 +307,15 @@ endif
 
 TARGETS := \
 	dhd-cdc-usb dhd-cdc-sdstd \
-	dhd-cdc-sdspi-pci dhd-cdc-sdmmc-oob-gpl \
-	dhd-cdc-sdmmc-nexus-gpl \
-	dhd-cdc-sdmmc-gpl dhd-cdc-usb-gpl \
-	dhd-cdc-sdstd-proptxstatus \
-	dhd-cdc-sdstd-proptxstatus-gpl \
-	dhd-cdc-sdstd-proptxstatus-dbgwlfc \
-	dhd-cdc-usb-proptxstatus-dbgwlfc \
-	dhd-cdc-usb-proptxstatus \
-	dhd-cdc-usb-proptxstatus-gpl
+	dhd-cdc-sdspi-pci dhd-cdc-sdmmc-gpl dhd-cdc-sdmmc-oob-gpl dhd-cdc-sdmmc-nexus-gpl\
+	dhd-cdc-usb-apsta dhd-cdc-usb-gpl \
+	dhd-cdc-sdstd-apsta \
+	dhd-cdc-sdmmc-softap-gpl
 
 
 TARGETS += \
 	dhd-cdc-sdio-dnglimage dhd-cdc-sdspi-pci-dnglimage \
 	dhd-cdc-gspi-pci
-TARGETS += \
-	dhd-cdc-sdstd-apsta
 #ifdef RNDIS
 TARGETS += dhd-rndis-usb
 #endif
diff --git a/drivers/net/wireless/bcm43291/src/dhd/linux/makefile.26 b/drivers/net/wireless/bcm43291/src/dhd/linux/makefile.26
index 62d1bb6..da7319b 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/linux/makefile.26
+++ b/drivers/net/wireless/bcm43291/src/dhd/linux/makefile.26
@@ -22,7 +22,7 @@
 # software in any way with any other Broadcom software provided under a license
 # other than the GPL, without Broadcom's express prior written consent.
 #
-# $Id: makefile.26,v 1.1.144.1.108.1 2010/04/14 23:34:04 Exp $
+# $Id: makefile.26,v 1.1.144.1.14.1 2010/04/16 20:27:14 Exp $
 
 ifneq ($(findstring -nexus-,-$(TARGET)-),)
 obj-m += bcm4329.o
diff --git a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd.h b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd.h
index 0f56e8b..cb39471 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd.h
+++ b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd.h
@@ -24,7 +24,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhd.h,v 1.32.4.7.2.4.14.20.4.18.2.11 2010/11/09 02:06:53 Exp $
+ * $Id: dhd.h,v 1.32.4.7.2.4.14.49.4.9 2011/01/14 22:40:45 Exp $
  */
 
 /****************
@@ -34,7 +34,10 @@
 #ifndef _dhd_h_
 #define _dhd_h_
 
+#if defined(LINUX)
+#if defined(CHROMIUMOS_COMPAT_WIRELESS)
 #include <linux/sched.h>
+#endif
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
@@ -50,6 +53,14 @@
 #include <linux/wakelock.h>
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined (CONFIG_HAS_WAKELOCK) */
 /* The kernel threading is sdio-specific */
+#else /* LINUX */
+#define ENOMEM		1
+#define EFAULT      2
+#define EINVAL		3
+#define EIO			4
+#define ETIMEDOUT	5
+#define ERESTARTSYS 6
+#endif /* LINUX */
 
 #include <wlioctl.h>
 
@@ -58,7 +69,6 @@
 struct dhd_bus;
 struct dhd_prot;
 struct dhd_info;
-struct dhd_cmn;
 
 /* The level of bus communication with the dongle */
 enum dhd_bus_state {
@@ -80,6 +90,7 @@ enum dhd_bus_wake_state {
 	WAKE_LOCK_SOFTAP_SET,
 	WAKE_LOCK_SOFTAP_STOP,
 	WAKE_LOCK_SOFTAP_START,
+	WAKE_LOCK_SOFTAP_THREAD,
 	WAKE_LOCK_MAX
 };
 enum dhd_prealloc_index {
@@ -98,7 +109,6 @@ typedef struct dhd_pub {
 	struct dhd_bus *bus;	/* Bus module handle */
 	struct dhd_prot *prot;	/* Protocol module handle */
 	struct dhd_info  *info; /* Info module handle */
-	struct dhd_cmn	*cmn;	/* dhd_common module handle */
 
 	/* Internal dhd items */
 	bool up;		/* Driver up/down (to OS) */
@@ -142,7 +152,7 @@ typedef struct dhd_pub {
 	/* Last error from dongle */
 	int dongle_error;
 
-	/* Suspend disable flag and "in suspend" flag */
+	/* Suspend disable flag  flag */
 	int suspend_disable_flag; /* "1" to disable all extra powersaving during suspend */
 	int in_suspend;			/* flag set to 1 when early suspend called */
 #ifdef PNO_SUPPORT
@@ -154,35 +164,18 @@ typedef struct dhd_pub {
 	char * pktfilter[100];
 	int pktfilter_count;
 
-	uint8 country_code[WLC_CNTRY_BUF_SZ];
+	wl_country_t dhd_cspec;		/* Current Locale info */
 	char eventmask[WL_EVENTING_MASK_LEN];
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_HAS_WAKELOCK)
+	struct wake_lock 	wakelock[WAKE_LOCK_MAX];
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined (CONFIG_HAS_WAKELOCK) */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+	struct mutex 	wl_start_stop_lock; /* lock/unlock for Android start/stop */
         struct mutex    wl_softap_lock;          /* lock/unlock for any SoftAP/STA settings */
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) */
-
-#ifdef PROP_TXSTATUS
-	void* wlfc_state;
 #endif
 } dhd_pub_t;
 
-typedef struct dhd_cmn {
-	osl_t *osh;		/* OSL handle */
-	dhd_pub_t *dhd;
-#if defined(DONGLEOVERLAYS)
-	char *overlaytab;	/* table of overlay IOCTLs and associated code */
-	int overlaytabsz;	/* size of overlay table */
-	uint32 *regions;	/* ptr to region table in overlaytab */
-	struct pktq overlay_req;	/* requests for overlays sent up in an event */
-	/* Thread to work on overlay_req */
-	long sysioc_pid;
-	struct semaphore sysioc_sem;
-	struct completion sysioc_exited;
-	int overlay_thread_terminate;
-	spinlock_t lock;
-#endif /* DONGLEOVERLAYS */
-} dhd_cmn_t;
-
 
 	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP)
 
@@ -191,14 +184,10 @@ typedef struct dhd_cmn {
 			int retry = 0; \
 			smp_mb(); \
 			while (dhd_mmc_suspend && retry++ != b) { \
-				wait_event_interruptible_timeout(a, FALSE, HZ/100); \
+				wait_event_timeout(a, FALSE, HZ/100); \
 			} \
 		} 	while (0)
-#if defined(CONFIG_ARCH_TEGRA)
-	#define DHD_PM_RESUME_WAIT(a) 			_DHD_PM_RESUME_WAIT(a, 500)
-#else
 	#define DHD_PM_RESUME_WAIT(a) 			_DHD_PM_RESUME_WAIT(a, 30)
-#endif
 	#define DHD_PM_RESUME_WAIT_FOREVER(a) 	_DHD_PM_RESUME_WAIT(a, ~0)
 	#define DHD_PM_RESUME_RETURN_ERROR(a)	do { if (dhd_mmc_suspend) return a; } while (0)
 	#define DHD_PM_RESUME_RETURN		do { if (dhd_mmc_suspend) return; } while (0)
@@ -230,19 +219,115 @@ typedef struct dhd_cmn {
 	} while (0)
 
 	#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP) */
+/*sangjun.bae 2012 */
+/* #ifndef DHDTHREAD*/
+#undef	SPINWAIT_SLEEP
+#define SPINWAIT_SLEEP(a, exp, us) SPINWAIT(exp, us)
+/*#endif*/ /* DHDTHREAD */
+/*sangjun.bae 2012 */
 #define DHD_IF_VIF	0x01	/* Virtual IF (Hidden from user) */
 
-/*  Wakelock Functions */
-extern int dhd_os_wake_lock(dhd_pub_t *pub);
-extern int dhd_os_wake_unlock(dhd_pub_t *pub);
-extern int dhd_os_wake_lock_timeout(dhd_pub_t *pub, uint32 timeout);
-extern int dhd_os_wake_lock_timeout_enable(dhd_pub_t *pub);
+inline static void NETIF_ADDR_LOCK(struct net_device *dev)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29))
+	netif_addr_lock_bh(dev);
+#endif
+}
 
-#define DHD_OS_WAKE_LOCK(pub) 			dhd_os_wake_lock(pub)
-#define DHD_OS_WAKE_UNLOCK(pub) 		dhd_os_wake_unlock(pub)
-#define DHD_OS_WAKE_LOCK_TIMEOUT(pub)		dhd_os_wake_lock_timeout(pub, HZ)
-#define DHD_OS_WAKE_LOCK_TIMEOUT_WITH_TIME(pub,timeout)		dhd_os_wake_lock_timeout(pub, timeout)
-#define DHD_OS_WAKE_LOCK_TIMEOUT_ENABLE(pub)	dhd_os_wake_lock_timeout_enable(pub)
+inline static void NETIF_ADDR_UNLOCK(struct net_device *dev)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29))
+	netif_addr_unlock_bh(dev);
+#endif
+}
+
+inline static void MUTEX_LOCK_INIT(dhd_pub_t * dhdp)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+	mutex_init(&dhdp->wl_start_stop_lock);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
+}
+
+inline static void MUTEX_LOCK_SOFTAP_SET_INIT(dhd_pub_t * dhdp)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+	mutex_init(&dhdp->wl_softap_lock);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
+}
+
+inline static void MUTEX_LOCK_SOFTAP_SET(dhd_pub_t * dhdp)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+	mutex_lock(&dhdp->wl_softap_lock);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
+}
+
+inline static void MUTEX_UNLOCK_SOFTAP_SET(dhd_pub_t * dhdp)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+	mutex_unlock(&dhdp->wl_softap_lock);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+extern struct mutex  g_wl_ss_scan_lock;		 /* lock/unlock for Scan/Cache settings */
+#endif 
+
+inline static void MUTEX_LOCK_WL_SCAN_SET_INIT(void)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+	mutex_init(&g_wl_ss_scan_lock);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
+}
+
+inline static void MUTEX_LOCK_WL_SCAN_SET(void)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+	mutex_lock(&g_wl_ss_scan_lock);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
+}
+
+inline static void MUTEX_UNLOCK_WL_SCAN_SET(void)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+	mutex_unlock(&g_wl_ss_scan_lock);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
+}
+
+inline static void WAKE_LOCK_INIT(dhd_pub_t * dhdp, int index, char * y)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_HAS_WAKELOCK)
+	wake_lock_init(&dhdp->wakelock[index], WAKE_LOCK_SUSPEND, y);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined (CONFIG_HAS_WAKELOCK) */
+}
+
+inline static void WAKE_LOCK(dhd_pub_t * dhdp, int index)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_HAS_WAKELOCK)
+	wake_lock(&dhdp->wakelock[index]);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined (CONFIG_HAS_WAKELOCK) */
+}
+
+inline static void WAKE_UNLOCK(dhd_pub_t * dhdp, int index)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_HAS_WAKELOCK)
+	wake_unlock(&dhdp->wakelock[index]);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined (CONFIG_HAS_WAKELOCK) */
+}
+
+inline static void WAKE_LOCK_TIMEOUT(dhd_pub_t * dhdp, int index, long time)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_HAS_WAKELOCK)
+	wake_lock_timeout(&dhdp->wakelock[index], time);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined (CONFIG_HAS_WAKELOCK) */
+}
+
+inline static void WAKE_LOCK_DESTROY(dhd_pub_t * dhdp, int index)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_HAS_WAKELOCK)
+	wake_lock_destroy(&dhdp->wakelock[index]);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined (CONFIG_HAS_WAKELOCK) */
+}
 
 
 typedef struct dhd_if_event {
@@ -250,29 +335,14 @@ typedef struct dhd_if_event {
 	uint8 action;
 	uint8 flags;
 	uint8 bssidx;
-	uint8 is_AP;
 } dhd_if_event_t;
 
-typedef enum dhd_attach_states
-{
-	DHD_ATTACH_STATE_INIT = 0x0,
-	DHD_ATTACH_STATE_NET_ALLOC = 0x1,
-	DHD_ATTACH_STATE_DHD_ALLOC = 0x2,
-	DHD_ATTACH_STATE_ADD_IF = 0x4,
-	DHD_ATTACH_STATE_PROT_ATTACH = 0x8,
-	DHD_ATTACH_STATE_WL_ATTACH = 0x10,
-	DHD_ATTACH_STATE_THREADS_CREATED = 0x20,
-	DHD_ATTACH_STATE_WAKELOCKS_INIT = 0x40,
-	DHD_ATTACH_STATE_CFG80211 = 0x80,
-	DHD_ATTACH_STATE_EARLYSUSPEND_DONE = 0x100,
-	DHD_ATTACH_STATE_DONE = 0x200
-} dhd_attach_states_t;
-
-/* Value -1 means we are unsuccessful in creating the kthread. */
-#define DHD_PID_KT_INVALID 	-1
-/* Value -2 means we are unsuccessful in both creating the kthread and tasklet */
-#define DHD_PID_KT_TL_INVALID	-2
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+extern void dhd_os_start_lock(dhd_pub_t *pub);
+extern void dhd_os_start_unlock(dhd_pub_t *pub);
+#endif 
+extern unsigned long dhd_os_spin_lock(dhd_pub_t *pub);
+extern void dhd_os_spin_unlock(dhd_pub_t *pub, unsigned long flags);
 /*
  * Exported from dhd OS modules (dhd_linux/dhd_ndis)
  */
@@ -291,7 +361,6 @@ extern int dhd_net_attach(dhd_pub_t *dhdp, int idx);
 
 /* Indication from bus module regarding removal/absence of dongle */
 extern void dhd_detach(dhd_pub_t *dhdp);
-extern void dhd_free(dhd_pub_t *dhdp);
 
 /* Indication from bus module to change flow-control state */
 extern void dhd_txflowcontrol(dhd_pub_t *dhdp, int ifidx, bool on);
@@ -310,6 +379,9 @@ extern void dhd_sched_dpc(dhd_pub_t *dhdp);
 /* Notify tx completion */
 extern void dhd_txcomplete(dhd_pub_t *dhdp, void *txp, bool success);
 
+/* Query ioctl */
+extern int  dhdcdc_query_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len);
+
 /* OS independent layer functions */
 extern int dhd_os_proto_block(dhd_pub_t * pub);
 extern int dhd_os_proto_unblock(dhd_pub_t * pub);
@@ -342,7 +414,14 @@ extern int dhd_customer_oob_irq_map(unsigned long *irq_flags_ptr);
 extern void dhd_os_sdtxlock(dhd_pub_t * pub);
 extern void dhd_os_sdtxunlock(dhd_pub_t * pub);
 
+//int setScheduler(struct task_struct *p, int policy, struct sched_param *param); //before ver. sangjun.bae 2012 
+//patched version 2012 sangjun.bae START
+#if defined(DHDTHREAD)
+struct task_struct;
+struct sched_param;
 int setScheduler(struct task_struct *p, int policy, struct sched_param *param);
+#endif /* DHDTHREAD && DHD_GPL */
+//patched version 2012 sangjun.bae END
 
 typedef struct {
 	uint32 limit;		/* Expiration time (usec) */
@@ -356,22 +435,11 @@ extern int dhd_timeout_expired(dhd_timeout_t *tmo);
 
 extern int dhd_ifname2idx(struct dhd_info *dhd, char *name);
 extern uint8 *dhd_bssidx2bssid(dhd_pub_t *dhd, int idx);
-extern int wl_host_event(dhd_pub_t *dhd_pub, int *idx, void *pktdata,
+extern int wl_host_event(struct dhd_info *dhd, int *idx, void *pktdata,
                          wl_event_msg_t *, void **data_ptr);
 extern void wl_event_to_host_order(wl_event_msg_t * evt);
 
-extern int dhd_wl_ioctl(dhd_pub_t *dhd_pub, int ifindex, wl_ioctl_t *ioc, void *buf, int len);
-extern int dhd_wl_ioctl_cmd(dhd_pub_t *dhd_pub, int cmd, void *arg, int len, uint8 set,
-                            int ifindex);
-#if defined(DONGLEOVERLAYS)
-extern int dhd_wl_ioctl_overlay(dhd_pub_t *dhd_pub, int ifindex, wl_ioctl_t *ioc, void *buf,
-                                int len, int32 idx, bool *found);
-extern wl_ioctl_overlay_t *dhd_mkoverlay(dhd_pub_t *dhd_pub, uint8 *overlay, uint32 oidx,
-                                         int offset, int osize, int *obuflen);
-#endif /* DONGLEOVERLAYS */
-
-extern struct dhd_cmn *dhd_common_init(osl_t *osh);
-extern void dhd_common_deinit(dhd_pub_t *dhd_pub);
+extern void dhd_common_init(void);
 
 extern int dhd_add_if(struct dhd_info *dhd, int ifidx, void *handle,
 	char *name, uint8 *mac_addr, uint32 flags, uint8 bssidx);
@@ -388,13 +456,11 @@ extern void dhd_vif_sendup(struct dhd_info *dhd, int ifidx, uchar *cp, int len);
 extern int dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pkt);
 
 /* Send event to host */
-/* send up locally generated event */
-extern void dhd_sendup_event_common(dhd_pub_t *dhdp, wl_event_msg_t *event, void *data);
 extern void dhd_sendup_event(dhd_pub_t *dhdp, wl_event_msg_t *event, void *data);
 extern int dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag);
 extern uint dhd_bus_status(dhd_pub_t *dhdp);
 extern int  dhd_bus_start(dhd_pub_t *dhdp);
-extern int dhd_bus_membytes(dhd_pub_t *dhdp, bool set, uint32 address, uint8 *data, uint size);
+
 extern void print_buf(void *pbuf, int len, int bytes_per_line);
 
 
@@ -406,6 +472,7 @@ typedef enum cust_gpio_modes {
 } cust_gpio_modes_t;
 extern int wl_iw_iscan_set_scan_broadcast_prep(struct net_device *dev, uint flag);
 extern int wl_iw_send_priv_event(struct net_device *dev, char *flag);
+extern int net_os_send_hang_message(struct net_device *dev);
 /*
  * Insmod parameters for debug/test
  */
@@ -416,10 +483,8 @@ extern uint dhd_watchdog_ms;
 #if defined(DHD_DEBUG)
 /* Console output poll interval */
 extern uint dhd_console_ms;
-extern uint wl_msg_level;
 #endif /* defined(DHD_DEBUG) */
 
-
 /* Use interrupts */
 extern uint dhd_intr;
 
@@ -442,7 +507,7 @@ extern uint dhd_pkt_filter_init;
 extern uint dhd_master_mode;
 
 /* Roaming mode control */
-extern uint dhd_roam_disable;
+extern uint dhd_roam;
 
 /* Roaming mode control */
 extern uint dhd_radio_up;
@@ -457,6 +522,10 @@ extern uint dhd_sdiod_drive_strength;
 /* Override to force tx queueing all the time */
 extern uint dhd_force_tx_queueing;
 
+/* Default KEEP_ALIVE Period is 55 sec to prevent AP from sending Keep Alive probe frame */
+#define KEEP_ALIVE_PERIOD 55000
+#define NULL_PKT_STR	"null_pkt"
+
 #ifdef SDTEST
 /* Echo packet generator (SDIO), pkts/s */
 extern uint dhd_pktgen;
@@ -471,140 +540,19 @@ extern uint dhd_pktgen_len;
 #define MOD_PARAM_PATHLEN	2048
 extern char fw_path[MOD_PARAM_PATHLEN];
 extern char nv_path[MOD_PARAM_PATHLEN];
+/* LGE_CHANGE_S [yoohoo@lge.com] 2009-04-03, configs */
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+extern char config_path[MOD_PARAM_PATHLEN];
+#endif /* CONFIG_LGE_BCM432X_PATCH */
+/* LGE_CHANGE_E [yoohoo@lge.com] 2009-04-03, configs */
 
 /* For supporting multiple interfaces */
 #define DHD_MAX_IFS	16
 #define DHD_DEL_IF	-0xe
 #define DHD_BAD_IF	-0xf
 
-#ifdef PROP_TXSTATUS
-/* Please be mindful that total pkttag space is 32 octets only */
-typedef struct dhd_pkttag {
-	/*
-	b[11 ] - 1 = this packet was sent in response to one time packet request,
-	do not increment credit on status for this one. [WLFC_CTL_TYPE_MAC_REQUEST_PACKET].
-	b[10 ] - 1 = signal-only-packet to firmware [i.e. nothing to piggyback on]
-	b[9  ] - 1 = packet is host->firmware (transmit direction)
-	       - 0 = packet received from firmware (firmware->host)
-	b[8  ] - 1 = packet was sent due to credit_request (pspoll),
-	             packet does not count against FIFO credit.
-	       - 0 = normal transaction, packet counts against FIFO credit
-	b[7  ] - 1 = AP, 0 = STA
-	b[6:4] - AC FIFO number
-	b[3:0] - interface index
-	*/
-	uint16	if_flags;
-	/* destination MAC address for this packet so that not every
-	module needs to open the packet to find this
-	*/
-	uint8	dstn_ether[ETHER_ADDR_LEN];
-	/*
-	This 32-bit goes from host to device for every packet.
-	*/
-	uint32	htod_tag;
-	/* bus specific stuff */
-	union {
-		struct {
-			void* stuff;
-			uint32 thing1;
-			uint32 thing2;
-		} sd;
-		struct {
-			void* bus;
-			void* urb;
-		} usb;
-	} bus_specific;
-} dhd_pkttag_t;
-
-#define DHD_PKTTAG_SET_H2DTAG(tag, h2dvalue)	((dhd_pkttag_t*)(tag))->htod_tag = (h2dvalue)
-#define DHD_PKTTAG_H2DTAG(tag)					(((dhd_pkttag_t*)(tag))->htod_tag)
-
-#define DHD_PKTTAG_IFMASK		0xf
-#define DHD_PKTTAG_IFTYPE_MASK	0x1
-#define DHD_PKTTAG_IFTYPE_SHIFT	7
-#define DHD_PKTTAG_FIFO_MASK	0x7
-#define DHD_PKTTAG_FIFO_SHIFT	4
-
-#define DHD_PKTTAG_SIGNALONLY_MASK			0x1
-#define DHD_PKTTAG_SIGNALONLY_SHIFT			10
-
-#define DHD_PKTTAG_ONETIMEPKTRQST_MASK		0x1
-#define DHD_PKTTAG_ONETIMEPKTRQST_SHIFT		11
-
-#define DHD_PKTTAG_PKTDIR_MASK			0x1
-#define DHD_PKTTAG_PKTDIR_SHIFT			9
-
-#define DHD_PKTTAG_CREDITCHECK_MASK		0x1
-#define DHD_PKTTAG_CREDITCHECK_SHIFT	8
-
-#define DHD_PKTTAG_INVALID_FIFOID 0x7
-
-#define DHD_PKTTAG_SETFIFO(tag, fifo)	((dhd_pkttag_t*)(tag))->if_flags = \
-	(((dhd_pkttag_t*)(tag))->if_flags & ~(DHD_PKTTAG_FIFO_MASK << DHD_PKTTAG_FIFO_SHIFT)) | \
-	(((fifo) & DHD_PKTTAG_FIFO_MASK) << DHD_PKTTAG_FIFO_SHIFT)
-#define DHD_PKTTAG_FIFO(tag)			((((dhd_pkttag_t*)(tag))->if_flags >> \
-	DHD_PKTTAG_FIFO_SHIFT) & DHD_PKTTAG_FIFO_MASK)
-
-#define DHD_PKTTAG_SETIF(tag, if)	((dhd_pkttag_t*)(tag))->if_flags = \
-	(((dhd_pkttag_t*)(tag))->if_flags & ~DHD_PKTTAG_IFMASK) | ((if) & DHD_PKTTAG_IFMASK)
-#define DHD_PKTTAG_IF(tag)	(((dhd_pkttag_t*)(tag))->if_flags & DHD_PKTTAG_IFMASK)
-
-#define DHD_PKTTAG_SETIFTYPE(tag, isAP)	((dhd_pkttag_t*)(tag))->if_flags = \
-	(((dhd_pkttag_t*)(tag))->if_flags & \
-	~(DHD_PKTTAG_IFTYPE_MASK << DHD_PKTTAG_IFTYPE_SHIFT)) | \
-	(((isAP) & DHD_PKTTAG_IFTYPE_MASK) << DHD_PKTTAG_IFTYPE_SHIFT)
-#define DHD_PKTTAG_IFTYPE(tag)	((((dhd_pkttag_t*)(tag))->if_flags >> \
-	DHD_PKTTAG_IFTYPE_SHIFT) & DHD_PKTTAG_IFTYPE_MASK)
-
-#define DHD_PKTTAG_SETCREDITCHECK(tag, check)	((dhd_pkttag_t*)(tag))->if_flags = \
-	(((dhd_pkttag_t*)(tag))->if_flags & \
-	~(DHD_PKTTAG_CREDITCHECK_MASK << DHD_PKTTAG_CREDITCHECK_SHIFT)) | \
-	(((check) & DHD_PKTTAG_CREDITCHECK_MASK) << DHD_PKTTAG_CREDITCHECK_SHIFT)
-#define DHD_PKTTAG_CREDITCHECK(tag)	((((dhd_pkttag_t*)(tag))->if_flags >> \
-	DHD_PKTTAG_CREDITCHECK_SHIFT) & DHD_PKTTAG_CREDITCHECK_MASK)
-
-#define DHD_PKTTAG_SETPKTDIR(tag, dir)	((dhd_pkttag_t*)(tag))->if_flags = \
-	(((dhd_pkttag_t*)(tag))->if_flags & \
-	~(DHD_PKTTAG_PKTDIR_MASK << DHD_PKTTAG_PKTDIR_SHIFT)) | \
-	(((dir) & DHD_PKTTAG_PKTDIR_MASK) << DHD_PKTTAG_PKTDIR_SHIFT)
-#define DHD_PKTTAG_PKTDIR(tag)	((((dhd_pkttag_t*)(tag))->if_flags >> \
-	DHD_PKTTAG_PKTDIR_SHIFT) & DHD_PKTTAG_PKTDIR_MASK)
-
-#define DHD_PKTTAG_SETSIGNALONLY(tag, signalonly)	((dhd_pkttag_t*)(tag))->if_flags = \
-	(((dhd_pkttag_t*)(tag))->if_flags & \
-	~(DHD_PKTTAG_SIGNALONLY_MASK << DHD_PKTTAG_SIGNALONLY_SHIFT)) | \
-	(((signalonly) & DHD_PKTTAG_SIGNALONLY_MASK) << DHD_PKTTAG_SIGNALONLY_SHIFT)
-#define DHD_PKTTAG_SIGNALONLY(tag)	((((dhd_pkttag_t*)(tag))->if_flags >> \
-	DHD_PKTTAG_SIGNALONLY_SHIFT) & DHD_PKTTAG_SIGNALONLY_MASK)
-
-#define DHD_PKTTAG_SETONETIMEPKTRQST(tag)	((dhd_pkttag_t*)(tag))->if_flags = \
-	(((dhd_pkttag_t*)(tag))->if_flags & \
-	~(DHD_PKTTAG_ONETIMEPKTRQST_MASK << DHD_PKTTAG_ONETIMEPKTRQST_SHIFT)) | \
-	(1 << DHD_PKTTAG_ONETIMEPKTRQST_SHIFT)
-#define DHD_PKTTAG_ONETIMEPKTRQST(tag)	((((dhd_pkttag_t*)(tag))->if_flags >> \
-	DHD_PKTTAG_ONETIMEPKTRQST_SHIFT) & DHD_PKTTAG_ONETIMEPKTRQST_MASK)
-
-#define DHD_PKTTAG_SETDSTN(tag, dstn_MAC_ea)	memcpy(((dhd_pkttag_t*)((tag)))->dstn_ether, \
-	(dstn_MAC_ea), ETHER_ADDR_LEN)
-#define DHD_PKTTAG_DSTN(tag)	((dhd_pkttag_t*)(tag))->dstn_ether
-
-typedef int (*f_commitpkt_t)(void* ctx, void* p);
-int dhd_wlfc_interface_event(struct dhd_info *, uint8 action, uint8 ifid, uint8 iftype, uint8* ea);
-int dhd_wlfc_FIFOcreditmap_event(struct dhd_info *dhd, uint8* event_data);
-int dhd_os_wlfc_block(dhd_pub_t *pub);
-int dhd_os_wlfc_unblock(dhd_pub_t *pub);
-
-#ifdef PROP_TXSTATUS_DEBUG
-#define DHD_WLFC_CTRINC_MAC_CLOSE(entry)	do { (entry)->closed_ct++; } while (0)
-#define DHD_WLFC_CTRINC_MAC_OPEN(entry)		do { (entry)->opened_ct++; } while (0)
-#else
-#define DHD_WLFC_CTRINC_MAC_CLOSE(entry)	do {} while (0)
-#define DHD_WLFC_CTRINC_MAC_OPEN(entry)		do {} while (0)
-#endif
-
-#endif /* PROP_TXSTATUS */
 
 extern void dhd_wait_for_event(dhd_pub_t *dhd, bool *lockvar);
 extern void dhd_wait_event_wakeup(dhd_pub_t*dhd);
-extern char config_path[];
+
 #endif /* _dhd_h_ */
diff --git a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_bus.h b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_bus.h
index 143d62a..97af41b 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_bus.h
+++ b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_bus.h
@@ -24,7 +24,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhd_bus.h,v 1.4.6.3.2.3.6.4.10.3.2.2 2010/11/09 02:06:54 Exp $
+ * $Id: dhd_bus.h,v 1.4.6.3.2.3.6.7 2010/08/13 01:35:24 Exp $
  */
 
 #ifndef _dhd_bus_h_
@@ -60,10 +60,10 @@ extern int dhd_bus_rxctl(struct dhd_bus *bus, uchar *msg, uint msglen);
 /* Watchdog timer function */
 extern bool dhd_bus_watchdog(dhd_pub_t *dhd);
 
-#if defined(DHD_DEBUG)
+#ifdef DHD_DEBUG
 /* Device console input function */
 extern int dhd_bus_console_in(dhd_pub_t *dhd, uchar *msg, uint msglen);
-#endif /* defined(DHD_DEBUG) */
+#endif /* DHD_DEBUG */
 
 /* Deferred processing for the bus, return TRUE requests reschedule */
 extern bool dhd_bus_dpc(struct dhd_bus *bus);
@@ -90,8 +90,4 @@ extern void *dhd_bus_pub(struct dhd_bus *bus);
 extern void *dhd_bus_txq(struct dhd_bus *bus);
 extern uint dhd_bus_hdrlen(struct dhd_bus *bus);
 
-#if defined(DONGLEOVERLAYS)
-extern int dhd_bus_overlay_dl(dhd_pub_t *dhdp, int ifindex, uint8 *overlay, uint osize,
-                              int32 idx, uint32 region);
-#endif
 #endif /* _dhd_bus_h_ */
diff --git a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_cdc.c b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_cdc.c
index 996a8d2..b34a695 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_cdc.c
+++ b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_cdc.c
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhd_cdc.c,v 1.22.4.2.4.7.2.12.4.35.2.14 2010/11/09 02:06:54 Exp $
+ * $Id: dhd_cdc.c,v 1.22.4.2.4.7.2.41 2010/06/23 19:58:18 Exp $
  *
  * BDC is like CDC, except it includes a header for data packets to convey
  * packet priority over the bus, and flags (e.g. to indicate checksum status
@@ -41,12 +41,12 @@
 #include <dhd_proto.h>
 #include <dhd_bus.h>
 #include <dhd_dbg.h>
+#ifdef CUSTOMER_HW2
+int wifi_get_mac_addr(unsigned char *buf);
+#endif
 
+extern int dhd_preinit_ioctls(dhd_pub_t *dhd);
 
-#ifdef PROP_TXSTATUS
-#include <wlfc_proto.h>
-#include <dhd_wlfc.h>
-#endif
 
 /* Packet alignment for most efficient SDIO (can change based on platform) */
 #ifndef DHD_SDALIGN
@@ -79,12 +79,9 @@ dhdcdc_msg(dhd_pub_t *dhd)
 {
 	dhd_prot_t *prot = dhd->prot;
 	int len = ltoh32(prot->msg.len) + sizeof(cdc_ioctl_t);
-	int ret;
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-	DHD_OS_WAKE_LOCK(dhd);
-
 	/* NOTE : cdc->msg.len holds the desired length of the buffer to be
 	 *        returned. Only up to CDC_MAX_MSG_SIZE of this buffer area
 	 *	  is actually sent to the dongle
@@ -93,9 +90,7 @@ dhdcdc_msg(dhd_pub_t *dhd)
 		len = CDC_MAX_MSG_SIZE;
 
 	/* Send request */
-	ret = dhd_bus_txctl(dhd->bus, (uchar*)&prot->msg, len);
-	DHD_OS_WAKE_UNLOCK(dhd);
-	return ret;
+	return dhd_bus_txctl(dhd->bus, (uchar*)&prot->msg, len);
 }
 
 static int
@@ -115,8 +110,8 @@ dhdcdc_cmplt(dhd_pub_t *dhd, uint32 id, uint32 len)
 	return ret;
 }
 
-static int
-dhdcdc_query_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len, uint8 action)
+int
+dhdcdc_query_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len)
 {
 	dhd_prot_t *prot = dhd->prot;
 	cdc_ioctl_t *msg = &prot->msg;
@@ -149,9 +144,6 @@ dhdcdc_query_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len, uin
 	msg->len = htol32(len);
 	msg->flags = (++prot->reqid << CDCF_IOC_ID_SHIFT);
 	CDC_SET_IF_IDX(msg, ifidx);
-	/* add additional action bits */
-	action &= WL_IOCTL_ACTION_MASK;
-	msg->flags |= (action << CDCF_IOC_ACTION_SHIFT);
 	msg->flags = htol32(msg->flags);
 
 	if (buf)
@@ -202,8 +194,8 @@ done:
 	return ret;
 }
 
-static int
-dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len, uint8 action)
+int
+dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len)
 {
 	dhd_prot_t *prot = dhd->prot;
 	cdc_ioctl_t *msg = &prot->msg;
@@ -217,11 +209,8 @@ dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len, uint8
 
 	msg->cmd = htol32(cmd);
 	msg->len = htol32(len);
-	msg->flags = (++prot->reqid << CDCF_IOC_ID_SHIFT);
+	msg->flags = (++prot->reqid << CDCF_IOC_ID_SHIFT) | CDCF_IOC_SET;
 	CDC_SET_IF_IDX(msg, ifidx);
-	/* add additional action bits */
-	action &= WL_IOCTL_ACTION_MASK;
-	msg->flags |= (action << CDCF_IOC_ACTION_SHIFT) | CDCF_IOC_SET;
 	msg->flags = htol32(msg->flags);
 
 	if (buf)
@@ -262,18 +251,12 @@ dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx, wl_ioctl_t * ioc, void * buf, int len)
 {
 	dhd_prot_t *prot = dhd->prot;
 	int ret = -1;
-	uint8 action;
-#ifndef DONGLEOVERLAYS
-	bool acquired = FALSE;
-#endif
+
 	if (dhd->busstate == DHD_BUS_DOWN) {
 		DHD_ERROR(("%s : bus is down. we have nothing to do\n", __FUNCTION__));
 		return ret;
 	}
-#ifndef DONGLEOVERLAYS
-	if (dhd_os_proto_block(dhd))
-		acquired = TRUE;
-#endif
+	dhd_os_proto_block(dhd);
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
@@ -283,7 +266,7 @@ dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx, wl_ioctl_t * ioc, void * buf, int len)
 		goto done;
 
 	if (prot->pending == TRUE) {
-		DHD_ERROR(("CDC packet is pending!!!! cmd=0x%x (%lu) lastcmd=0x%x (%lu)\n",
+		DHD_TRACE(("CDC packet is pending!!!! cmd=0x%x (%lu) lastcmd=0x%x (%lu)\n",
 			ioc->cmd, (unsigned long)ioc->cmd, prot->lastcmd,
 			(unsigned long)prot->lastcmd));
 		if ((ioc->cmd == WLC_SET_VAR) || (ioc->cmd == WLC_GET_VAR)) {
@@ -294,15 +277,10 @@ dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx, wl_ioctl_t * ioc, void * buf, int len)
 
 	prot->pending = TRUE;
 	prot->lastcmd = ioc->cmd;
-#ifdef DONGLEOVERLAYS
-	action = ioc->action;
-#else
-	action = ioc->set;
-#endif
-	if (action & WL_IOCTL_ACTION_SET)
-		ret = dhdcdc_set_ioctl(dhd, ifidx, ioc->cmd, buf, len, action);
+	if (ioc->set)
+		ret = dhdcdc_set_ioctl(dhd, ifidx, ioc->cmd, buf, len);
 	else {
-		ret = dhdcdc_query_ioctl(dhd, ifidx, ioc->cmd, buf, len, action);
+		ret = dhdcdc_query_ioctl(dhd, ifidx, ioc->cmd, buf, len);
 		if (ret > 0)
 			ioc->used = ret - sizeof(cdc_ioctl_t);
 	}
@@ -328,10 +306,8 @@ dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx, wl_ioctl_t * ioc, void * buf, int len)
 	prot->pending = FALSE;
 
 done:
-#ifndef DONGLEOVERLAYS
-	if (acquired)
 	    dhd_os_proto_unblock(dhd);
-#endif /* DONGLEOVERLAYS */
+
 	return ret;
 }
 
@@ -342,2411 +318,201 @@ dhd_prot_iovar_op(dhd_pub_t *dhdp, const char *name,
 	return BCME_UNSUPPORTED;
 }
 
-#ifdef PROP_TXSTATUS
-void dhd_wlfc_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf)
+void
+dhd_prot_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf)
 {
-	int i;
-	uint8* ea;
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhdp->wlfc_state;
-	wlfc_hanger_t* h;
-	wlfc_mac_descriptor_t* mac_table;
-	wlfc_mac_descriptor_t* interfaces;
-	char* iftypes[] = {"STA", "AP", "WDS", "p2pGO", "p2pCL"};
-
-	if (wlfc == NULL) {
-		bcm_bprintf(strbuf, "wlfc not initialized yet\n");
-		return;
-	}
-	h = (wlfc_hanger_t*)wlfc->hanger;
-	if (h == NULL) {
-		bcm_bprintf(strbuf, "wlfc-hanger not initialized yet\n");
-	}
-
-	mac_table = wlfc->destination_entries.nodes;
-	interfaces = wlfc->destination_entries.interfaces;
-	bcm_bprintf(strbuf, "---- wlfc stats ----\n");
-	if (h) {
-		bcm_bprintf(strbuf, "wlfc hanger (pushed,popped,f_push,"
-			"f_pop,f_slot, pending) = (%d,%d,%d,%d,%d,%d)\n",
-			h->pushed,
-			h->popped,
-			h->failed_to_push,
-			h->failed_to_pop,
-			h->failed_slotfind,
-			(h->pushed - h->popped));
-	}
-
-	bcm_bprintf(strbuf, "wlfc fail(tlv,credit_rqst,mac_update,psmode_update), "
-		"(dq_full,sendq_full, rollback_fail) = (%d,%d,%d,%d), (%d,%d,%d)\n",
-		wlfc->stats.tlv_parse_failed,
-		wlfc->stats.credit_request_failed,
-		wlfc->stats.mac_update_failed,
-		wlfc->stats.psmode_update_failed,
-		wlfc->stats.delayq_full_error,
-		wlfc->stats.sendq_full_error,
-		wlfc->stats.rollback_failed);
-
-	bcm_bprintf(strbuf, "SENDQ (len,credit,sent) "
-		"(AC0[%d,%d,%d],AC1[%d,%d,%d],AC2[%d,%d,%d],AC3[%d,%d,%d],BC_MC[%d,%d,%d])\n",
-		wlfc->SENDQ.q[0].len, wlfc->FIFO_credit[0], wlfc->stats.sendq_pkts[0],
-		wlfc->SENDQ.q[1].len, wlfc->FIFO_credit[1], wlfc->stats.sendq_pkts[1],
-		wlfc->SENDQ.q[2].len, wlfc->FIFO_credit[2], wlfc->stats.sendq_pkts[2],
-		wlfc->SENDQ.q[3].len, wlfc->FIFO_credit[3], wlfc->stats.sendq_pkts[3],
-		wlfc->SENDQ.q[4].len, wlfc->FIFO_credit[4], wlfc->stats.sendq_pkts[4]);
-
-#ifdef PROP_TXSTATUS_DEBUG
-	bcm_bprintf(strbuf, "SENDQ dropped: AC[0-3]:(%d,%d,%d,%d), (bcmc,atim):(%d,%d)\n",
-		wlfc->stats.dropped_qfull[0], wlfc->stats.dropped_qfull[1],
-		wlfc->stats.dropped_qfull[2], wlfc->stats.dropped_qfull[3],
-		wlfc->stats.dropped_qfull[4], wlfc->stats.dropped_qfull[5]);
-#endif
-
-	bcm_bprintf(strbuf, "\n");
-	for (i = 0; i < WLFC_MAX_IFNUM; i++) {
-		if (interfaces[i].occupied) {
-			char* iftype_desc;
-
-			if (interfaces[i].iftype > WLC_E_IF_ROLE_P2P_CLIENT)
-				iftype_desc = "<Unknown";
-			else
-				iftype_desc = iftypes[interfaces[i].iftype];
-
-			ea = interfaces[i].ea;
-			bcm_bprintf(strbuf, "INTERFACE[%d].ea = "
-				"[%02x:%02x:%02x:%02x:%02x:%02x], if:%d, type: %s\n", i,
-				ea[0], ea[1], ea[2], ea[3], ea[4], ea[5],
-				interfaces[i].interface_id,
-				iftype_desc);
-
-			bcm_bprintf(strbuf, "INTERFACE[%d].DELAYQ(len,state,credit)"
-				"= (%d,%s,%d)\n",
-				i,
-				interfaces[i].psq.len,
-				((interfaces[i].state ==
-				WLFC_STATE_OPEN) ? " OPEN":"CLOSE"),
-				interfaces[i].requested_credit);
-
-			bcm_bprintf(strbuf, "INTERFACE[%d].DELAYQ"
-				"(sup,ac0),(sup,ac1),(sup,ac2),(sup,ac3) = "
-				"(%d,%d),(%d,%d),(%d,%d),(%d,%d)\n",
-				i,
-				interfaces[i].psq.q[0].len,
-				interfaces[i].psq.q[1].len,
-				interfaces[i].psq.q[2].len,
-				interfaces[i].psq.q[3].len,
-				interfaces[i].psq.q[4].len,
-				interfaces[i].psq.q[5].len,
-				interfaces[i].psq.q[6].len,
-				interfaces[i].psq.q[7].len);
-		}
-	}
-
-	bcm_bprintf(strbuf, "\n");
-	for (i = 0; i < WLFC_MAC_DESC_TABLE_SIZE; i++) {
-		if (mac_table[i].occupied) {
-			ea = mac_table[i].ea;
-			bcm_bprintf(strbuf, "MAC_table[%d].ea = "
-				"[%02x:%02x:%02x:%02x:%02x:%02x], if:%d\n", i,
-				ea[0], ea[1], ea[2], ea[3], ea[4], ea[5],
-				mac_table[i].interface_id);
-
-			bcm_bprintf(strbuf, "MAC_table[%d].DELAYQ(len,state,credit)"
-				"= (%d,%s,%d)\n",
-				i,
-				mac_table[i].psq.len,
-				((mac_table[i].state ==
-				WLFC_STATE_OPEN) ? " OPEN":"CLOSE"),
-				mac_table[i].requested_credit);
-#ifdef PROP_TXSTATUS_DEBUG
-			bcm_bprintf(strbuf, "MAC_table[%d]: (opened, closed) = (%d, %d)\n",
-				i, mac_table[i].opened_ct, mac_table[i].closed_ct);
-#endif
-			bcm_bprintf(strbuf, "MAC_table[%d].DELAYQ"
-				"(sup,ac0),(sup,ac1),(sup,ac2),(sup,ac3) = "
-				"(%d,%d),(%d,%d),(%d,%d),(%d,%d)\n",
-				i,
-				mac_table[i].psq.q[0].len,
-				mac_table[i].psq.q[1].len,
-				mac_table[i].psq.q[2].len,
-				mac_table[i].psq.q[3].len,
-				mac_table[i].psq.q[4].len,
-				mac_table[i].psq.q[5].len,
-				mac_table[i].psq.q[6].len,
-				mac_table[i].psq.q[7].len);
-		}
-	}
+	bcm_bprintf(strbuf, "Protocol CDC: reqid %d\n", dhdp->prot->reqid);
+}
 
-#ifdef PROP_TXSTATUS_DEBUG
-	{
-		int avg;
-		int moving_avg = 0;
-		int moving_samples;
-
-		if (wlfc->stats.latency_sample_count) {
-			moving_samples = sizeof(wlfc->stats.deltas)/sizeof(uint32);
-
-			for (i = 0; i < moving_samples; i++)
-				moving_avg += wlfc->stats.deltas[i];
-			moving_avg /= moving_samples;
-
-			avg = (100 * wlfc->stats.total_status_latency) /
-				wlfc->stats.latency_sample_count;
-			bcm_bprintf(strbuf, "txstatus latency (average, last, moving[%d]) = "
-				"(%d.%d, %03d, %03d)\n",
-				moving_samples, avg/100, (avg - (avg/100)*100),
-				wlfc->stats.latency_most_recent,
-				moving_avg);
-		}
-	}
 
-	bcm_bprintf(strbuf, "wlfc- fifo[0-5] credit stats: sent = (%d,%d,%d,%d,%d,%d), "
-		"back = (%d,%d,%d,%d,%d,%d)\n",
-		wlfc->stats.fifo_credits_sent[0],
-		wlfc->stats.fifo_credits_sent[1],
-		wlfc->stats.fifo_credits_sent[2],
-		wlfc->stats.fifo_credits_sent[3],
-		wlfc->stats.fifo_credits_sent[4],
-		wlfc->stats.fifo_credits_sent[5],
-
-		wlfc->stats.fifo_credits_back[0],
-		wlfc->stats.fifo_credits_back[1],
-		wlfc->stats.fifo_credits_back[2],
-		wlfc->stats.fifo_credits_back[3],
-		wlfc->stats.fifo_credits_back[4],
-		wlfc->stats.fifo_credits_back[5]);
-	{
-		uint32 fifo_cr_sent = 0;
-		uint32 fifo_cr_acked = 0;
-		uint32 request_cr_sent = 0;
-		uint32 request_cr_ack = 0;
-		uint32 bc_mc_cr_ack = 0;
-
-		for (i = 0; i < sizeof(wlfc->stats.fifo_credits_sent)/sizeof(uint32); i++) {
-			fifo_cr_sent += wlfc->stats.fifo_credits_sent[i];
-		}
+void
+dhd_prot_hdrpush(dhd_pub_t *dhd, int ifidx, void *pktbuf)
+{
+#ifdef BDC
+	struct bdc_header *h;
+#endif /* BDC */
 
-		for (i = 0; i < sizeof(wlfc->stats.fifo_credits_back)/sizeof(uint32); i++) {
-			fifo_cr_acked += wlfc->stats.fifo_credits_back[i];
-		}
+	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-		for (i = 0; i < WLFC_MAC_DESC_TABLE_SIZE; i++) {
-			if (wlfc->destination_entries.nodes[i].occupied) {
-				request_cr_sent +=
-					wlfc->destination_entries.nodes[i].dstncredit_sent_packets;
-			}
-		}
-		for (i = 0; i < WLFC_MAX_IFNUM; i++) {
-			if (wlfc->destination_entries.interfaces[i].occupied) {
-				request_cr_sent +=
-				wlfc->destination_entries.interfaces[i].dstncredit_sent_packets;
-			}
-		}
-		for (i = 0; i < WLFC_MAC_DESC_TABLE_SIZE; i++) {
-			if (wlfc->destination_entries.nodes[i].occupied) {
-				request_cr_ack +=
-					wlfc->destination_entries.nodes[i].dstncredit_acks;
-			}
-		}
-		for (i = 0; i < WLFC_MAX_IFNUM; i++) {
-			if (wlfc->destination_entries.interfaces[i].occupied) {
-				request_cr_ack +=
-					wlfc->destination_entries.interfaces[i].dstncredit_acks;
-			}
-		}
-		bcm_bprintf(strbuf, "wlfc- (sent, status) => pq(%d,%d), vq(%d,%d),"
-			"other:%d, bc_mc:%d, signal-only, (sent,freed): (%d,%d)",
-			fifo_cr_sent, fifo_cr_acked,
-			request_cr_sent, request_cr_ack,
-			wlfc->destination_entries.other.dstncredit_acks,
-			bc_mc_cr_ack,
-			wlfc->stats.signal_only_pkts_sent, wlfc->stats.signal_only_pkts_freed);
-	}
-#endif /* PROP_TXSTATUS_DEBUG */
-	bcm_bprintf(strbuf, "\n");
-	bcm_bprintf(strbuf, "wlfc- pkt((in,2bus,txstats,hdrpull),(dropped,hdr_only,wlc_tossed)"
-		"(freed,free_err,rollback)) = "
-		"((%d,%d,%d,%d),(%d,%d,%d),(%d,%d,%d))\n",
-		wlfc->stats.pktin,
-		wlfc->stats.pkt2bus,
-		wlfc->stats.txstatus_in,
-		wlfc->stats.dhd_hdrpulls,
-
-		wlfc->stats.pktdropped,
-		wlfc->stats.wlfc_header_only_pkt,
-		wlfc->stats.wlc_tossed_pkts,
-
-		wlfc->stats.pkt_freed,
-		wlfc->stats.pkt_free_err, wlfc->stats.rollback);
-
-	bcm_bprintf(strbuf, "wlfc- suppress((d11,wlc,err),enq(d11,wl,hq,mac?),retx(d11,wlc,hq)) = "
-		"((%d,%d,%d),(%d,%d,%d,%d),(%d,%d,%d))\n",
-
-		wlfc->stats.d11_suppress,
-		wlfc->stats.wl_suppress,
-		wlfc->stats.bad_suppress,
-
-		wlfc->stats.psq_d11sup_enq,
-		wlfc->stats.psq_wlsup_enq,
-		wlfc->stats.psq_hostq_enq,
-		wlfc->stats.mac_handle_notfound,
-
-		wlfc->stats.psq_d11sup_retx,
-		wlfc->stats.psq_wlsup_retx,
-		wlfc->stats.psq_hostq_retx);
-	return;
-}
+#ifdef BDC
+	/* Push BDC header used to convey priority for buses that don't */
 
-/* Create a place to store all packet pointers submitted to the firmware until 
-	a status comes back, suppress or otherwise.
 
-	hang-er: noun, a contrivance on which things are hung, as a hook.
-*/
-static void*
-dhd_wlfc_hanger_create(osl_t *osh, int max_items)
-{
-	int i;
-	wlfc_hanger_t* hanger;
+	PKTPUSH(dhd->osh, pktbuf, BDC_HEADER_LEN);
 
-	/* allow only upto a specfic size for now */
-	ASSERT(max_items == WLFC_HANGER_MAXITEMS);
+	h = (struct bdc_header *)PKTDATA(dhd->osh, pktbuf);
 
-	hanger = (wlfc_hanger_t*)MALLOC(osh, WLFC_HANGER_SIZE(max_items));
+	h->flags = (BDC_PROTO_VER << BDC_FLAG_VER_SHIFT);
+	if (PKTSUMNEEDED(pktbuf))
+		h->flags |= BDC_FLAG_SUM_NEEDED;
 
-	memset(hanger, 0, WLFC_HANGER_SIZE(max_items));
-	hanger->max_items = max_items;
 
-	for (i = 0; i < hanger->max_items; i++) {
-		hanger->items[i].state = WLFC_HANGER_ITEM_STATE_FREE;
-	}
-	return hanger;
+	h->priority = (PKTPRIO(pktbuf) & BDC_PRIORITY_MASK);
+	h->flags2 = 0;
+	h->rssi = 0;
+#endif /* BDC */
+	BDC_SET_IF_IDX(h, ifidx);
 }
 
-static int
-dhd_wlfc_hanger_delete(osl_t *osh, void* hanger)
-{
-	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
-
-	if (h) {
-		MFREE(osh, h, WLFC_HANGER_SIZE(h->max_items));
-		return BCME_OK;
-	}
-	return BCME_BADARG;
-}
 
-static uint16
-dhd_wlfc_hanger_get_free_slot(void* hanger)
+bool
+dhd_proto_fcinfo(dhd_pub_t *dhd, void *pktbuf, uint8 *fcbits)
 {
-	int i;
-	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
+#ifdef BDC
+	struct bdc_header *h;
 
-	if (h) {
-		for (i = 0; i < h->max_items; i++) {
-			if (h->items[i].state == WLFC_HANGER_ITEM_STATE_FREE)
-				return (uint16)i;
-		}
+	if (PKTLEN(dhd->osh, pktbuf) < BDC_HEADER_LEN) {
+		DHD_ERROR(("%s: rx data too short (%d < %d)\n",
+			__FUNCTION__, PKTLEN(dhd->osh, pktbuf), BDC_HEADER_LEN));
+		return BCME_ERROR;
 	}
-	h->failed_slotfind++;
-	return WLFC_HANGER_MAXITEMS;
-}
 
-static int
-dhd_wlfc_hanger_pushpkt(void* hanger, void* pkt, uint32 slot_id)
-{
-	int rc = BCME_OK;
-	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
-
-	if (h && (slot_id < WLFC_HANGER_MAXITEMS)) {
-		if (h->items[slot_id].state == WLFC_HANGER_ITEM_STATE_FREE) {
-			h->items[slot_id].state = WLFC_HANGER_ITEM_STATE_INUSE;
-			h->items[slot_id].pkt = pkt;
-			h->items[slot_id].identifier = slot_id;
-			h->pushed++;
-		}
-		else {
-			h->failed_to_push++;
-			rc = BCME_NOTFOUND;
-		}
-	}
-	else
-		rc = BCME_BADARG;
-	return rc;
-}
+	h = (struct bdc_header *)PKTDATA(dhd->osh, pktbuf);
 
-static int
-dhd_wlfc_hanger_poppkt(void* hanger, uint32 slot_id, void** pktout, int remove_from_hanger)
-{
-	int rc = BCME_OK;
-	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
-
-	/* this packet was not pushed at the time it went to the firmware */
-	if (slot_id == WLFC_HANGER_MAXITEMS)
-		return BCME_NOTFOUND;
-
-	if (h) {
-		if (h->items[slot_id].state == WLFC_HANGER_ITEM_STATE_INUSE) {
-			*pktout = h->items[slot_id].pkt;
-			if (remove_from_hanger) {
-				h->items[slot_id].state =
-					WLFC_HANGER_ITEM_STATE_FREE;
-				h->items[slot_id].pkt = NULL;
-				h->items[slot_id].identifier = 0;
-				h->popped++;
-			}
-		}
-		else {
-			h->failed_to_pop++;
-			rc = BCME_NOTFOUND;
-		}
-	}
-	else
-		rc = BCME_BADARG;
-	return rc;
+	*fcbits = h->priority >> BDC_PRIORITY_FC_SHIFT;
+	if ((h->flags2 & BDC_FLAG2_FC_FLAG) == BDC_FLAG2_FC_FLAG)
+		return TRUE;
+#endif
+	return FALSE;
 }
 
-static int
-_dhd_wlfc_pushheader(athost_wl_status_info_t* ctx, void* p, bool tim_signal,
-	uint8 tim_bmp, uint8 mac_handle, uint32 htodtag)
-{
-	uint32 wl_pktinfo = 0;
-	uint8* wlh;
-	uint8 dataOffset;
-	uint8 fillers;
-	uint8 tim_signal_len = 0;
 
+int
+dhd_prot_hdrpull(dhd_pub_t *dhd, int *ifidx, void *pktbuf)
+{
+#ifdef BDC
 	struct bdc_header *h;
+#endif
 
-	if (tim_signal) {
-		tim_signal_len = 1 + 1 + WLFC_CTL_VALUE_LEN_PENDING_TRAFFIC_BMP;
-	}
-
-	/* +2 is for Type[1] and Len[1] in TLV, plus TIM signal */
-	dataOffset = WLFC_CTL_VALUE_LEN_PKTTAG + 2 + tim_signal_len;
-	fillers = ROUNDUP(dataOffset, 4) - dataOffset;
-	dataOffset += fillers;
+	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-	PKTPUSH(ctx->osh, p, dataOffset);
-	wlh = (uint8*) PKTDATA(ctx->osh, p);
+#ifdef BDC
+	/* Pop BDC header used to convey priority for buses that don't */
 
-	wl_pktinfo = htol32(htodtag);
+	if (PKTLEN(dhd->osh, pktbuf) < BDC_HEADER_LEN) {
+		DHD_ERROR(("%s: rx data too short (%d < %d)\n", __FUNCTION__,
+		           PKTLEN(dhd->osh, pktbuf), BDC_HEADER_LEN));
+		return BCME_ERROR;
+	}
 
-	wlh[0] = WLFC_CTL_TYPE_PKTTAG;
-	wlh[1] = WLFC_CTL_VALUE_LEN_PKTTAG;
-	memcpy(&wlh[2], &wl_pktinfo, sizeof(uint32));
+	h = (struct bdc_header *)PKTDATA(dhd->osh, pktbuf);
 
-	if (tim_signal_len) {
-		wlh[dataOffset - fillers - tim_signal_len ] =
-			WLFC_CTL_TYPE_PENDING_TRAFFIC_BMP;
-		wlh[dataOffset - fillers - tim_signal_len + 1] =
-			WLFC_CTL_VALUE_LEN_PENDING_TRAFFIC_BMP;
-		wlh[dataOffset - fillers - tim_signal_len + 2] = mac_handle;
-		wlh[dataOffset - fillers - tim_signal_len + 3] = tim_bmp;
+	if ((*ifidx = BDC_GET_IF_IDX(h)) >= DHD_MAX_IFS) {
+		DHD_ERROR(("%s: rx data ifnum out of range (%d)\n",
+		           __FUNCTION__, *ifidx));
+		return BCME_ERROR;
 	}
-	if (fillers)
-		memset(&wlh[dataOffset - fillers], WLFC_CTL_TYPE_FILLER, fillers);
-
-	PKTPUSH(ctx->osh, p, BDC_HEADER_LEN);
-	h = (struct bdc_header *)PKTDATA(ctx->osh, p);
-	h->flags = (BDC_PROTO_VER << BDC_FLAG_VER_SHIFT);
-	if (PKTSUMNEEDED(p))
-		h->flags |= BDC_FLAG_SUM_NEEDED;
 
+	if (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) != BDC_PROTO_VER) {
+		DHD_ERROR(("%s: non-BDC packet received, flags 0x%x\n",
+		           dhd_ifname(dhd, *ifidx), h->flags));
+		return BCME_ERROR;
+	}
 
-	h->priority = (PKTPRIO(p) & BDC_PRIORITY_MASK);
-	h->flags2 = 0;
-	h->dataOffset = dataOffset >> 2;
-	BDC_SET_IF_IDX(h, DHD_PKTTAG_IF(PKTTAG(p)));
-	return BCME_OK;
-}
+	if (h->flags & BDC_FLAG_SUM_GOOD) {
+		DHD_INFO(("%s: BDC packet received with good rx-csum, flags 0x%x\n",
+		          dhd_ifname(dhd, *ifidx), h->flags));
+		PKTSETSUMGOOD(pktbuf, TRUE);
+	}
 
-static int
-_dhd_wlfc_pullheader(athost_wl_status_info_t* ctx, void* pktbuf)
-{
-	struct bdc_header *h;
+	PKTSETPRIO(pktbuf, (h->priority & BDC_PRIORITY_MASK));
 
-	if (PKTLEN(ctx->osh, pktbuf) < BDC_HEADER_LEN) {
-		WLFC_DBGMESG(("%s: rx data too short (%d < %d)\n", __FUNCTION__,
-		           PKTLEN(ctx->osh, pktbuf), BDC_HEADER_LEN));
-		return BCME_ERROR;
-	}
-	h = (struct bdc_header *)PKTDATA(ctx->osh, pktbuf);
+	PKTPULL(dhd->osh, pktbuf, BDC_HEADER_LEN);
+#endif /* BDC */
 
-	/* pull BDC header */
-	PKTPULL(ctx->osh, pktbuf, BDC_HEADER_LEN);
-	/* pull wl-header */
-	PKTPULL(ctx->osh, pktbuf, (h->dataOffset << 2));
-	return BCME_OK;
+	return 0;
 }
 
-static wlfc_mac_descriptor_t*
-_dhd_wlfc_find_table_entry(athost_wl_status_info_t* ctx, void* p)
+int
+dhd_prot_attach(dhd_pub_t *dhd)
 {
-	int i;
-	wlfc_mac_descriptor_t* table = ctx->destination_entries.nodes;
-	uint8 ifid = DHD_PKTTAG_IF(PKTTAG(p));
-	uint8* dstn = DHD_PKTTAG_DSTN(PKTTAG(p));
-
-	/* no lookup necessary, only if this packet belongs to STA interface */
-	if (((ctx->destination_entries.interfaces[ifid].iftype == WLC_E_IF_ROLE_STA) ||
-		ETHER_ISMULTI(dstn) ||
-		(ctx->destination_entries.interfaces[ifid].iftype == WLC_E_IF_ROLE_P2P_CLIENT)) &&
-		(ctx->destination_entries.interfaces[ifid].occupied)) {
-			return &ctx->destination_entries.interfaces[ifid];
-	}
+	dhd_prot_t *cdc;
 
-	for (i = 0; i < WLFC_MAC_DESC_TABLE_SIZE; i++) {
-		if (table[i].occupied) {
-			if (table[i].interface_id == ifid) {
-				if (!memcmp(table[i].ea, dstn, ETHER_ADDR_LEN))
-					return &table[i];
+#ifndef DHD_USE_STATIC_BUF
+	if (!(cdc = (dhd_prot_t *)MALLOC(dhd->osh, sizeof(dhd_prot_t)))) {
+		DHD_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
+		goto fail;
 			}
+#else
+	if (!(cdc = (dhd_prot_t *)dhd_os_prealloc(DHD_PREALLOC_PROT, sizeof(dhd_prot_t)))) {
+		DHD_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
+		goto fail;
 		}
-	}
-	return &ctx->destination_entries.other;
-}
+#endif /* DHD_USE_STATIC_BUF */
+	memset(cdc, 0, sizeof(dhd_prot_t));
 
-static int
-_dhd_wlfc_rollback_packet_toq(athost_wl_status_info_t* ctx,
-	void* p, ewlfc_packet_state_t pkt_type, uint32 hslot)
-{
-	/*
-	put the packet back to the head of queue
-
-	- a packet from send-q will need to go back to send-q and not delay-q
-	since that will change the order of packets.
-	- suppressed packet goes back to suppress sub-queue
-	- pull out the header, if new or delayed packet
-
-	Note: hslot is used only when header removal is done.
-	*/
-	wlfc_mac_descriptor_t* entry;
-	void* pktout;
-	int rc = BCME_OK;
-	int prec;
-
-	entry = _dhd_wlfc_find_table_entry(ctx, p);
-	prec = DHD_PKTTAG_FIFO(PKTTAG(p));
-	if (entry != NULL) {
-		if (pkt_type == eWLFC_PKTTYPE_SUPPRESSED) {
-			/* wl-header is saved for suppressed packets */
-			if (NULL == WLFC_PKTQ_PENQ_HEAD(&entry->psq, ((prec << 1) + 1), p)) {
-				WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-				rc = BCME_ERROR;
-			}
-		}
-		else {
-			/* remove header first */
-			_dhd_wlfc_pullheader(ctx, p);
-
-			if (pkt_type == eWLFC_PKTTYPE_DELAYED) {
-				/* delay-q packets are going to delay-q */
-				if (NULL == WLFC_PKTQ_PENQ_HEAD(&entry->psq, (prec << 1), p)) {
-					WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-					rc = BCME_ERROR;
-				}
-			}
-			else {
-				/* these are going to SENDQ */
-				if (NULL == WLFC_PKTQ_PENQ_HEAD(&ctx->SENDQ, prec, p)) {
-					WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-					rc = BCME_ERROR;
-				}
+	/* ensure that the msg buf directly follows the cdc msg struct */
+	if ((uintptr)(&cdc->msg + 1) != (uintptr)cdc->buf) {
+		DHD_ERROR(("dhd_prot_t is not correctly defined\n"));
+		goto fail;
 			}
-			/* free the hanger slot */
-			dhd_wlfc_hanger_poppkt(ctx->hanger, hslot, &pktout, 1);
 
-			/* decrement sequence count */
-			WLFC_DECR_SEQCOUNT(entry, prec);
-		}
-		/*
-		if this packet did not count against FIFO credit, it must have
-		taken a requested_credit from the firmware (for pspoll etc.)
-		*/
-		if (!DHD_PKTTAG_CREDITCHECK(PKTTAG(p))) {
-			entry->requested_credit++;
-		}
-	}
-	else {
-		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-		rc = BCME_ERROR;
-	}
-	if (rc != BCME_OK)
-		ctx->stats.rollback_failed++;
-	else
-		ctx->stats.rollback++;
+	dhd->prot = cdc;
+#ifdef BDC
+	dhd->hdrlen += BDC_HEADER_LEN;
+#endif
+	dhd->maxctl = WLC_IOCTL_MAXLEN + sizeof(cdc_ioctl_t) + ROUND_UP_MARGIN;
+	return 0;
 
-	return rc;
+fail:
+#ifndef DHD_USE_STATIC_BUF
+	if (cdc != NULL)
+		MFREE(dhd->osh, cdc, sizeof(dhd_prot_t));
+#endif
+	return BCME_NOMEM;
 }
 
-static void
-_dhd_wlfc_flow_control_check(athost_wl_status_info_t* ctx, struct pktq* pq, uint8 if_id)
+/* ~NOTE~ What if another thread is waiting on the semaphore?  Holding it? */
+void
+dhd_prot_detach(dhd_pub_t *dhd)
 {
-	if ((pq->len <= WLFC_FLOWCONTROL_LOWATER) && (ctx->hostif_flow_state[if_id] == ON)) {
-		/* start traffic */
-		ctx->hostif_flow_state[if_id] = OFF;
-		/*
-		WLFC_DBGMESG(("qlen:%02d, if:%02d, ->OFF, start traffic %s()\n",
-		pq->len, if_id, __FUNCTION__));
-		*/
-		WLFC_DBGMESG(("F"));
-		/* dhd_txflowcontrol(ctx->dhdp, if_id, OFF); */
-		ctx->toggle_host_if = 0;
-	}
-	if ((pq->len >= WLFC_FLOWCONTROL_HIWATER) && (ctx->hostif_flow_state[if_id] == OFF)) {
-		/* stop traffic */
-		ctx->hostif_flow_state[if_id] = ON;
-		/*
-		WLFC_DBGMESG(("qlen:%02d, if:%02d, ->ON, stop traffic   %s()\n",
-		pq->len, if_id, __FUNCTION__));
-		*/
-		WLFC_DBGMESG(("N"));
-		/* dhd_txflowcontrol(ctx->dhdp, if_id, ON); */
-		ctx->host_ifidx = if_id;
-		ctx->toggle_host_if = 1;
-	}
-	return;
+#ifndef DHD_USE_STATIC_BUF
+	MFREE(dhd->osh, dhd->prot, sizeof(dhd_prot_t));
+#endif
+	dhd->prot = NULL;
 }
 
-static int
-_dhd_wlfc_send_signalonly_packet(athost_wl_status_info_t* ctx, wlfc_mac_descriptor_t* entry,
-	uint8 ta_bmp)
+void
+dhd_prot_dstats(dhd_pub_t *dhd)
 {
-	int rc = BCME_OK;
-	void* p = NULL;
-	int dummylen = ((dhd_pub_t *)ctx->dhdp)->hdrlen+ 12;
-
-	/* allocate a dummy packet */
-	p = PKTGET(ctx->osh, dummylen, TRUE);
-	if (p) {
-		PKTPULL(ctx->osh, p, dummylen);
-		DHD_PKTTAG_SET_H2DTAG(PKTTAG(p), 0);
-		_dhd_wlfc_pushheader(ctx, p, TRUE, ta_bmp, entry->mac_handle, 0);
-		DHD_PKTTAG_SETSIGNALONLY(PKTTAG(p), 1);
-#ifdef PROP_TXSTATUS_DEBUG
-		ctx->stats.signal_only_pkts_sent++;
-#endif
-		dhd_bus_txdata(((dhd_pub_t *)ctx->dhdp)->bus, p);
-	}
-	else {
-		DHD_ERROR(("%s: couldn't allocate new %d-byte packet\n",
-		           __FUNCTION__, dummylen));
-		rc = BCME_NOMEM;
-	}
-	return rc;
+	/* No stats from dongle added yet, copy bus stats */
+	dhd->dstats.tx_packets = dhd->tx_packets;
+	dhd->dstats.tx_errors = dhd->tx_errors;
+	dhd->dstats.rx_packets = dhd->rx_packets;
+	dhd->dstats.rx_errors = dhd->rx_errors;
+	dhd->dstats.rx_dropped = dhd->rx_dropped;
+	dhd->dstats.multicast = dhd->rx_multicast;
+	return;
 }
 
-/* Return TRUE if traffic availability changed */
-static bool
-_dhd_wlfc_traffic_pending_check(athost_wl_status_info_t* ctx, wlfc_mac_descriptor_t* entry,
-	int prec)
+int
+dhd_prot_init(dhd_pub_t *dhd)
 {
-	bool rc = FALSE;
-
-	if (entry->state == WLFC_STATE_CLOSE) {
-		if ((pktq_plen(&entry->psq, (prec << 1)) == 0) &&
-			(pktq_plen(&entry->psq, ((prec << 1) + 1)) == 0)) {
+	int ret = 0;
+	char buf[128];
 
-			if (entry->traffic_pending_bmp & NBITVAL(prec)) {
-				rc = TRUE;
-				entry->traffic_pending_bmp =
-					entry->traffic_pending_bmp & ~ NBITVAL(prec);
-			}
-		}
-		else {
-			if (!(entry->traffic_pending_bmp & NBITVAL(prec))) {
-				rc = TRUE;
-				entry->traffic_pending_bmp =
-					entry->traffic_pending_bmp | NBITVAL(prec);
-			}
-		}
-	}
-	if (rc) {
-		/* request a TIM update to firmware at the next piggyback opportunity */
-		if (entry->traffic_lastreported_bmp != entry->traffic_pending_bmp) {
-			entry->send_tim_signal = 1;
-			_dhd_wlfc_send_signalonly_packet(ctx, entry, entry->traffic_pending_bmp);
-			entry->traffic_lastreported_bmp = entry->traffic_pending_bmp;
-			entry->send_tim_signal = 0;
-		}
-		else {
-			rc = FALSE;
-		}
-	}
-	return rc;
-}
+	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-static int
-_dhd_wlfc_enque_suppressed(athost_wl_status_info_t* ctx, int prec, void* p)
-{
-	wlfc_mac_descriptor_t* entry;
+	dhd_os_proto_block(dhd);
 
-	entry = _dhd_wlfc_find_table_entry(ctx, p);
-	if (entry == NULL) {
-		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-		return BCME_NOTFOUND;
-	}
-	/*
-	- suppressed packets go to sub_queue[2*prec + 1] AND
-	- delayed packets go to sub_queue[2*prec + 0] to ensure
-	order of delivery.
-	*/
-	if (NULL == WLFC_PKTQ_PENQ(&entry->psq, ((prec << 1) + 1), p)) {
-		ctx->stats.delayq_full_error++;
-		/* WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__)); */
-		WLFC_DBGMESG(("s"));
-		return BCME_ERROR;
+	/* Get the device MAC address */
+	strcpy(buf, "cur_etheraddr");
+	ret = dhdcdc_query_ioctl(dhd, 0, WLC_GET_VAR, buf, sizeof(buf));
+	if (ret < 0) {
+		dhd_os_proto_unblock(dhd);
+		return ret;
 	}
-	/* A packet has been pushed, update traffic availability bitmap, if applicable */
-	_dhd_wlfc_traffic_pending_check(ctx, entry, prec);
-	_dhd_wlfc_flow_control_check(ctx, &entry->psq, DHD_PKTTAG_IF(PKTTAG(p)));
-	return BCME_OK;
-}
-
-static int
-_dhd_wlfc_pretx_pktprocess(athost_wl_status_info_t* ctx,
-	wlfc_mac_descriptor_t* entry, void* p, int header_needed, uint32* slot)
-{
-	int rc = BCME_OK;
-	int hslot = WLFC_HANGER_MAXITEMS;
-	bool send_tim_update = FALSE;
-	uint32 htod = 0;
-	uint8 free_ctr;
+	memcpy(dhd->mac.octet, buf, ETHER_ADDR_LEN);
 
-	*slot = hslot;
+	dhd_os_proto_unblock(dhd);
 
-	if (entry == NULL) {
-		entry = _dhd_wlfc_find_table_entry(ctx, p);
-	}
-
-	if (entry == NULL) {
-		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-		return BCME_ERROR;
-	}
-	if (entry->send_tim_signal) {
-		send_tim_update = TRUE;
-		entry->send_tim_signal = 0;
-		entry->traffic_lastreported_bmp = entry->traffic_pending_bmp;
-	}
-	if (header_needed) {
-		hslot = dhd_wlfc_hanger_get_free_slot(ctx->hanger);
-		free_ctr = WLFC_SEQCOUNT(entry, DHD_PKTTAG_FIFO(PKTTAG(p)));
-		DHD_PKTTAG_SET_H2DTAG(PKTTAG(p), htod);
-	}
-	else {
-		hslot = WLFC_PKTID_HSLOT_GET(DHD_PKTTAG_H2DTAG(PKTTAG(p)));
-		free_ctr = WLFC_PKTID_FREERUNCTR_GET(DHD_PKTTAG_H2DTAG(PKTTAG(p)));
-	}
-	WLFC_PKTID_HSLOT_SET(htod, hslot);
-	WLFC_PKTID_FREERUNCTR_SET(htod, free_ctr);
-	DHD_PKTTAG_SETPKTDIR(PKTTAG(p), 1);
-	WL_TXSTATUS_SET_FLAGS(htod, WLFC_PKTFLAG_PKTFROMHOST);
-	WL_TXSTATUS_SET_FIFO(htod, DHD_PKTTAG_FIFO(PKTTAG(p)));
-	WLFC_PKTFLAG_SET_GENERATION(htod, entry->generation);
-
-	if (!DHD_PKTTAG_CREDITCHECK(PKTTAG(p))) {
-		/*
-		Indicate that this packet is being sent in response to an
-		explicit request from the firmware side.
-		*/
-		WLFC_PKTFLAG_SET_PKTREQUESTED(htod);
-	}
-	else {
-		WLFC_PKTFLAG_CLR_PKTREQUESTED(htod);
-	}
-	if (header_needed) {
-		rc = _dhd_wlfc_pushheader(ctx, p, send_tim_update,
-			entry->traffic_lastreported_bmp, entry->mac_handle, htod);
-		if (rc == BCME_OK) {
-			DHD_PKTTAG_SET_H2DTAG(PKTTAG(p), htod);
-			/*
-			a new header was created for this packet.
-			push to hanger slot and scrub q. Since bus
-			send succeeded, increment seq number as well.
-			*/
-			rc = dhd_wlfc_hanger_pushpkt(ctx->hanger, p, hslot);
-			if (rc == BCME_OK) {
-				/* increment free running sequence count */
-				WLFC_INCR_SEQCOUNT(entry, DHD_PKTTAG_FIFO(PKTTAG(p)));
-#ifdef PROP_TXSTATUS_DEBUG
-				((wlfc_hanger_t*)(ctx->hanger))->items[hslot].push_time =
-					OSL_SYSUPTIME();
-#endif
-			}
-			else {
-				WLFC_DBGMESG(("%s() hanger_pushpkt() failed, rc: %d\n",
-					__FUNCTION__, rc));
-			}
-		}
-	}
-	else {
-		/* remove old header */
-		_dhd_wlfc_pullheader(ctx, p);
-
-		hslot = WLFC_PKTID_HSLOT_GET(DHD_PKTTAG_H2DTAG(PKTTAG(p)));
-		free_ctr = WLFC_PKTID_FREERUNCTR_GET(DHD_PKTTAG_H2DTAG(PKTTAG(p)));
-		/* push new header */
-		_dhd_wlfc_pushheader(ctx, p, send_tim_update,
-			entry->traffic_lastreported_bmp, entry->mac_handle, htod);
-	}
-	*slot = hslot;
-	return rc;
-}
-
-static int _dhd_wlfc_is_destination_closed(athost_wl_status_info_t* ctx,
-	wlfc_mac_descriptor_t* entry, int prec)
-{
-	if (ctx->destination_entries.interfaces[entry->interface_id].iftype ==
-		WLC_E_IF_ROLE_P2P_GO) {
-		/* - destination interface is of type p2p GO.
-		For a p2pGO interface, if the destination is OPEN but the interface is
-		CLOSEd, do not send traffic. But if the dstn is CLOSEd while there is
-		destination-specific-credit left send packets. This is because the
-		firmware storing the destination-specific-requested packet in queue.
-		*/
-		if ((entry->state == WLFC_STATE_CLOSE) && (entry->requested_credit == 0) &&
-			(entry->requested_packet == 0))
-			return 1;
-	}
-	/* AP, p2p_go -> unicast desc entry, STA/p2p_cl -> interface desc. entry */
-	if (((entry->state == WLFC_STATE_CLOSE) && (entry->requested_credit == 0) &&
-		(entry->requested_packet == 0)) ||
-		(!(entry->ac_bitmap & (1 << prec))))
-		return 1;
-
-	return 0;
-}
-
-static void*
-_dhd_wlfc_deque_delayedq(athost_wl_status_info_t* ctx,
-	int prec, uint8* ac_credit_spent, uint8* needs_hdr, wlfc_mac_descriptor_t** entry_out)
-{
-	wlfc_mac_descriptor_t* entry;
-	wlfc_mac_descriptor_t* table;
-	uint8 token_pos;
-	int total_entries;
-	void* p = NULL;
-	int pout;
-	int i;
-
-	*entry_out = NULL;
-	token_pos = ctx->token_pos[prec];
-	/* most cases a packet will count against FIFO credit */
-	*ac_credit_spent = 1;
-	*needs_hdr = 1;
-
-	/* search all entries, include nodes as well as interfaces */
-	table = (wlfc_mac_descriptor_t*)&ctx->destination_entries;
-	total_entries = sizeof(ctx->destination_entries)/sizeof(wlfc_mac_descriptor_t);
-
-	for (i = 0; i < total_entries; i++) {
-		entry = &table[(token_pos + i) % total_entries];
-		if (entry->occupied) {
-			if (!_dhd_wlfc_is_destination_closed(ctx, entry, prec)) {
-				p = pktq_mdeq(&entry->psq,
-					/* higher precedence will be picked up first,
-					i.e. suppressed packets before delayed ones
-					*/
-					(NBITVAL((prec << 1) + 1) | NBITVAL((prec << 1))),
-					&pout);
-				if (p != NULL) {
-					/* did the packet come from suppress sub-queue? */
-					if (pout == ((prec << 1) + 1)) {
-						/*
-						this packet was suppressed and was sent on the bus
-						previously; this already has a header
-						*/
-						*needs_hdr = 0;
-					}
-					if (entry->requested_credit > 0) {
-						entry->requested_credit--;
-#ifdef PROP_TXSTATUS_DEBUG
-						entry->dstncredit_sent_packets++;
-#endif
-						/*
-						if the packet was pulled out while destination is in
-						closed state but had a non-zero packets requested,
-						then this should not count against the FIFO credit.
-						That is due to the fact that the firmware will
-						most likely hold onto this packet until a suitable
-						time later to push it to the appropriate  AC FIFO.
-						*/
-						if (entry->state == WLFC_STATE_CLOSE)
-							*ac_credit_spent = 0;
-					}
-					else if (entry->requested_packet > 0) {
-						entry->requested_packet--;
-						DHD_PKTTAG_SETONETIMEPKTRQST(PKTTAG(p));
-						if (entry->state == WLFC_STATE_CLOSE)
-							*ac_credit_spent = 0;
-					}
-					/* move token to ensure fair round-robin */
-					ctx->token_pos[prec] =
-						(token_pos + i + 1) % total_entries;
-					*entry_out = entry;
-					_dhd_wlfc_flow_control_check(ctx, &entry->psq,
-						DHD_PKTTAG_IF(PKTTAG(p)));
-					/*
-					A packet has been picked up, update traffic
-					availability bitmap, if applicable
-					*/
-					_dhd_wlfc_traffic_pending_check(ctx, entry, prec);
-					return p;
-				}
-			}
-		}
-	}
-	return NULL;
-}
-
-static void*
-_dhd_wlfc_deque_sendq(athost_wl_status_info_t* ctx, int prec, uint8* ac_credit_spent)
-{
-	wlfc_mac_descriptor_t* entry;
-	void* p;
-
-	/* most cases a packet will count against FIFO credit */
-	*ac_credit_spent = 1;
-
-	p = pktq_pdeq(&ctx->SENDQ, prec);
-	if (p != NULL) {
-		if (ETHER_ISMULTI(DHD_PKTTAG_DSTN(PKTTAG(p))))
-			/* bc/mc packets do not have a delay queue */
-			return p;
-
-		entry = _dhd_wlfc_find_table_entry(ctx, p);
-
-		if (entry == NULL) {
-			WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-			return p;
-		}
-
-		while ((p != NULL) && _dhd_wlfc_is_destination_closed(ctx, entry, prec)) {
-			/*
-			- suppressed packets go to sub_queue[2*prec + 1] AND
-			- delayed packets go to sub_queue[2*prec + 0] to ensure
-			order of delivery.
-			*/
-			if (NULL == WLFC_PKTQ_PENQ(&entry->psq, (prec << 1), p)) {
-				WLFC_DBGMESG(("D"));
-				/* dhd_txcomplete(ctx->dhdp, p, FALSE); */
-				PKTFREE(ctx->osh, p, TRUE);
-				ctx->stats.delayq_full_error++;
-			}
-			/*
-			A packet has been pushed, update traffic availability bitmap,
-			if applicable
-			*/
-			_dhd_wlfc_traffic_pending_check(ctx, entry, prec);
-			_dhd_wlfc_flow_control_check(ctx, &entry->psq, DHD_PKTTAG_IF(PKTTAG(p)));
-			p = pktq_pdeq(&ctx->SENDQ, prec);
-			if (p == NULL)
-				break;
-
-			entry = _dhd_wlfc_find_table_entry(ctx, p);
-
-			if ((entry == NULL) || (ETHER_ISMULTI(DHD_PKTTAG_DSTN(PKTTAG(p))))) {
-				return p;
-			}
-		}
-		if (p) {
-			if (entry->requested_packet == 0) {
-				if (entry->requested_credit > 0)
-					entry->requested_credit--;
-			}
-			else {
-				entry->requested_packet--;
-				DHD_PKTTAG_SETONETIMEPKTRQST(PKTTAG(p));
-			}
-			if (entry->state == WLFC_STATE_CLOSE)
-				*ac_credit_spent = 0;
-#ifdef PROP_TXSTATUS_DEBUG
-			entry->dstncredit_sent_packets++;
-#endif
-		}
-		if (p)
-			_dhd_wlfc_flow_control_check(ctx, &ctx->SENDQ, DHD_PKTTAG_IF(PKTTAG(p)));
-	}
-	return p;
-}
-
-static int
-_dhd_wlfc_mac_entry_update(athost_wl_status_info_t* ctx, wlfc_mac_descriptor_t* entry,
-	ewlfc_mac_entry_action_t action, uint8 ifid, uint8 iftype, uint8* ea)
-{
-	int rc = BCME_OK;
-
-	if (action == eWLFC_MAC_ENTRY_ACTION_ADD) {
-		entry->occupied = 1;
-		entry->state = WLFC_STATE_OPEN;
-		entry->requested_credit = 0;
-		entry->interface_id = ifid;
-		entry->iftype = iftype;
-		entry->ac_bitmap = 0xff; /* update this when handling APSD */
-		/* for an interface entry we may not care about the MAC address */
-		if (ea != NULL)
-			memcpy(&entry->ea[0], ea, ETHER_ADDR_LEN);
-		pktq_init(&entry->psq, WLFC_PSQ_PREC_COUNT, WLFC_PSQ_LEN);
-	}
-	else if (action == eWLFC_MAC_ENTRY_ACTION_DEL) {
-		entry->occupied = 0;
-		entry->state = WLFC_STATE_CLOSE;
-		entry->requested_credit = 0;
-		/* enable after packets are queued-deqeued properly.
-		pktq_flush(dhd->osh, &entry->psq, FALSE);
-		*/
-	}
-	return rc;
-}
-
-int
-dhd_wlfc_interface_entry_update(void* state,
-	ewlfc_mac_entry_action_t action, uint8 ifid, uint8 iftype, uint8* ea)
-{
-	athost_wl_status_info_t* ctx = (athost_wl_status_info_t*)state;
-	wlfc_mac_descriptor_t* entry;
-
-	if (ifid >= WLFC_MAX_IFNUM)
-		return BCME_BADARG;
-
-	entry = &ctx->destination_entries.interfaces[ifid];
-	return _dhd_wlfc_mac_entry_update(ctx, entry, action, ifid, iftype, ea);
-}
-
-int
-dhd_wlfc_FIFOcreditmap_update(void* state, uint8* credits)
-{
-	athost_wl_status_info_t* ctx = (athost_wl_status_info_t*)state;
-
-	/* update the AC FIFO credit map */
-	ctx->FIFO_credit[0] = credits[0];
-	ctx->FIFO_credit[1] = credits[1];
-	ctx->FIFO_credit[2] = credits[2];
-	ctx->FIFO_credit[3] = credits[3];
-	/* credit for bc/mc packets */
-	ctx->FIFO_credit[4] = credits[4];
-	/* credit for ATIM FIFO is not used yet. */
-	return BCME_OK;
-}
-
-int
-dhd_wlfc_enque_sendq(void* state, int prec, void* p)
-{
-	athost_wl_status_info_t* ctx = (athost_wl_status_info_t*)state;
-
-	if ((state == NULL) ||
-		/* prec = AC_COUNT is used for bc/mc queue */
-		(prec > AC_COUNT) ||
-		(p == NULL)) {
-		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-		return BCME_BADARG;
-	}
-	if (FALSE == dhd_prec_enq(ctx->dhdp, &ctx->SENDQ, p, prec)) {
-		ctx->stats.sendq_full_error++;
-		/*
-		WLFC_DBGMESG(("Error: %s():%d, qlen:%d\n",
-		__FUNCTION__, __LINE__, ctx->SENDQ.len));
-		*/
-		WLFC_HOST_FIFO_DROPPEDCTR_INC(ctx, prec);
-		WLFC_DBGMESG(("Q"));
-		PKTFREE(ctx->osh, p, TRUE);
-		return BCME_ERROR;
-	}
-	ctx->stats.pktin++;
-	/* _dhd_wlfc_flow_control_check(ctx, &ctx->SENDQ, DHD_PKTTAG_IF(PKTTAG(p))); */
-	return BCME_OK;
-}
-
-int
-dhd_wlfc_commit_packets(void* state, f_commitpkt_t fcommit, void* commit_ctx)
-{
-	int ac;
-	int credit;
-	uint8 ac_fifo_credit_spent;
-	uint8 needs_hdr;
-	uint32 hslot;
-	void* p;
-	int rc;
-	athost_wl_status_info_t* ctx = (athost_wl_status_info_t*)state;
-	wlfc_mac_descriptor_t* mac_entry;
-
-	if ((state == NULL) ||
-		(fcommit == NULL)) {
-		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-		return BCME_BADARG;
-	}
-
-	/* 
-	Commit packets for regular AC traffic. Higher priority first.
-
-	-NOTE:
-	If the bus between the host and firmware is overwhelmed by the
-	traffic from host, it is possible that higher priority traffic
-	starves the lower priority queue. If that occurs often, we may
-	have to employ weighted round-robin or ucode scheme to avoid
-	low priority packet starvation.
-	*/
-	for (ac = AC_COUNT; ac >= 0; ac--) {
-		for (credit = 0; credit < ctx->FIFO_credit[ac];) {
-			p = _dhd_wlfc_deque_delayedq(ctx, ac, &ac_fifo_credit_spent, &needs_hdr,
-				&mac_entry);
-			if (p == NULL)
-				break;
-			/*
-			if ac_fifo_credit_spent = 0
-
-			This packet will not count against the FIFO credit.
-			To ensure the txstatus corresponding to this packet
-			does not provide an implied credit (default behavior)
-			mark the packet accordingly.
-
-			if ac_fifo_credit_spent = 1
-
-			This is a normal packet and it counts against the FIFO
-			credit count.
-			*/
-			DHD_PKTTAG_SETCREDITCHECK(PKTTAG(p), ac_fifo_credit_spent);
-			rc = _dhd_wlfc_pretx_pktprocess(ctx, mac_entry, p, needs_hdr, &hslot);
-
-			if (rc == BCME_OK)
-				rc = fcommit(commit_ctx, p);
-			else
-				ctx->stats.generic_error++;
-
-			if (rc == BCME_OK) {
-				ctx->stats.pkt2bus++;
-				if (ac_fifo_credit_spent) {
-					ctx->stats.sendq_pkts[ac]++;
-					WLFC_HOST_FIFO_CREDIT_INC_SENTCTRS(ctx, ac);
-					/*
-					1 FIFO credit has been spent by sending this packet
-					to the device.
-					*/
-					credit++;
-				}
-			}
-			else {
-				/* bus commit has failed, rollback. */
-				rc = _dhd_wlfc_rollback_packet_toq(ctx,
-					p,
-					/*
-					- remove wl-header for a delayed packet
-					- save wl-header header for suppressed packets
-					*/
-					(needs_hdr ? eWLFC_PKTTYPE_DELAYED :
-					eWLFC_PKTTYPE_SUPPRESSED),
-					hslot);
-				if (rc != BCME_OK)
-					ctx->stats.rollback_failed++;
-			}
-		}
-		ctx->FIFO_credit[ac] -= credit;
-		/* packets from SENDQ are fresh and they'd need header */
-		needs_hdr = 1;
-		for (credit = 0; credit < ctx->FIFO_credit[ac];) {
-			p = _dhd_wlfc_deque_sendq(ctx, ac, &ac_fifo_credit_spent);
-			if (p == NULL)
-				break;
-
-			DHD_PKTTAG_SETCREDITCHECK(PKTTAG(p), ac_fifo_credit_spent);
-			rc = _dhd_wlfc_pretx_pktprocess(ctx, NULL, p, needs_hdr, &hslot);
-			if (rc == BCME_OK)
-				rc = fcommit(commit_ctx, p);
-			else
-				ctx->stats.generic_error++;
-
-			if (rc == BCME_OK) {
-				ctx->stats.pkt2bus++;
-				if (ac_fifo_credit_spent) {
-					WLFC_HOST_FIFO_CREDIT_INC_SENTCTRS(ctx, ac);
-					ctx->stats.sendq_pkts[ac]++;
-					credit++;
-				}
-			}
-			else {
-				/* bus commit has failed, rollback. */
-				rc = _dhd_wlfc_rollback_packet_toq(ctx,
-					p,
-					/* remove wl-header while rolling back */
-					eWLFC_PKTTYPE_NEW,
-					hslot);
-				if (rc != BCME_OK)
-					ctx->stats.rollback_failed++;
-			}
-		}
-		ctx->FIFO_credit[ac] -= credit;
-	}
-	return BCME_OK;
-}
-
-static uint8
-dhd_wlfc_find_mac_desc_id_from_mac(dhd_pub_t *dhdp, uint8* ea)
-{
-	wlfc_mac_descriptor_t* table =
-		((athost_wl_status_info_t*)dhdp->wlfc_state)->destination_entries.nodes;
-	uint8 table_index;
-
-	if (ea != NULL) {
-		for (table_index = 0; table_index < WLFC_MAC_DESC_TABLE_SIZE; table_index++) {
-			if ((0 == memcmp(ea, &table[table_index].ea[0], ETHER_ADDR_LEN)) &&
-				table[table_index].occupied)
-				return table_index;
-		}
-	}
-	return WLFC_MAC_DESC_ID_INVALID;
-}
-
-void
-dhd_wlfc_txcomplete(dhd_pub_t *dhd, void *txp, bool success)
-{
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	void* p;
-
-	if (DHD_PKTTAG_SIGNALONLY(PKTTAG(txp))) {
-#ifdef PROP_TXSTATUS_DEBUG
-		wlfc->stats.signal_only_pkts_freed++;
-#endif
-		/* is this a signal-only packet? */
-		PKTFREE(wlfc->osh, txp, TRUE);
-		return;
-	}
-	if (!success) {
-		WLFC_DBGMESG(("At: %s():%d, bus_complete() failure for %p, htod_tag:0x%08x\n",
-			__FUNCTION__, __LINE__, txp, DHD_PKTTAG_H2DTAG(PKTTAG(txp))));
-		dhd_wlfc_hanger_poppkt(wlfc->hanger, WLFC_PKTID_HSLOT_GET(DHD_PKTTAG_H2DTAG
-			(PKTTAG(txp))), &p, 1);
-
-		/* indicate failure and free the packet */
-		dhd_txcomplete(dhd, txp, FALSE);
-		PKTFREE(wlfc->osh, txp, TRUE);
-
-		/* return the credit, if necessary */
-		if (DHD_PKTTAG_CREDITCHECK(PKTTAG(txp)))
-			wlfc->FIFO_credit[DHD_PKTTAG_FIFO(PKTTAG(txp))]++;
-	}
-	return;
-}
-
-/* Handle discard or suppress indication */
-static int
-dhd_wlfc_txstatus_update(dhd_pub_t *dhd, uint8* pkt_info)
-{
-	uint8 	status_flag;
-	uint32	status;
-	int		ret;
-	int		remove_from_hanger = 1;
-	void*	pktbuf;
-	uint8	fifo_id;
-	wlfc_mac_descriptor_t* entry = NULL;
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-
-	memcpy(&status, pkt_info, sizeof(uint32));
-	status_flag = WL_TXSTATUS_GET_FLAGS(status);
-	wlfc->stats.txstatus_in++;
-
-	if (status_flag == WLFC_CTL_PKTFLAG_DISCARD) {
-		wlfc->stats.pkt_freed++;
-	}
-
-	else if (status_flag == WLFC_CTL_PKTFLAG_D11SUPPRESS) {
-		wlfc->stats.d11_suppress++;
-		remove_from_hanger = 0;
-	}
-
-	else if (status_flag == WLFC_CTL_PKTFLAG_WLSUPPRESS) {
-		wlfc->stats.wl_suppress++;
-		remove_from_hanger = 0;
-	}
-
-	else if (status_flag == WLFC_CTL_PKTFLAG_TOSSED_BYWLC) {
-		wlfc->stats.wlc_tossed_pkts++;
-	}
-
-	ret = dhd_wlfc_hanger_poppkt(wlfc->hanger,
-		WLFC_PKTID_HSLOT_GET(status), &pktbuf, remove_from_hanger);
-	if (ret != BCME_OK) {
-		/* do something */
-		return ret;
-	}
-
-	if (!remove_from_hanger) {
-		/* this packet was suppressed */
-
-		entry = _dhd_wlfc_find_table_entry(wlfc, pktbuf);
-		entry->generation = WLFC_PKTID_GEN(status);
-	}
-
-#ifdef PROP_TXSTATUS_DEBUG
-	{
-		uint32 new_t = OSL_SYSUPTIME();
-		uint32 old_t;
-		uint32 delta;
-		old_t = ((wlfc_hanger_t*)(wlfc->hanger))->items[
-			WLFC_PKTID_HSLOT_GET(status)].push_time;
-
-
-		wlfc->stats.latency_sample_count++;
-		if (new_t > old_t)
-			delta = new_t - old_t;
-		else
-			delta = 0xffffffff + new_t - old_t;
-		wlfc->stats.total_status_latency += delta;
-		wlfc->stats.latency_most_recent = delta;
-
-		wlfc->stats.deltas[wlfc->stats.idx_delta++] = delta;
-		if (wlfc->stats.idx_delta == sizeof(wlfc->stats.deltas)/sizeof(uint32))
-			wlfc->stats.idx_delta = 0;
-	}
-#endif /* PROP_TXSTATUS_DEBUG */
-
-	fifo_id = DHD_PKTTAG_FIFO(PKTTAG(pktbuf));
-
-	/* pick up the implicit credit from this packet */
-	if (DHD_PKTTAG_CREDITCHECK(PKTTAG(pktbuf))) {
-		if (wlfc->proptxstatus_mode == WLFC_FCMODE_IMPLIED_CREDIT) {
-			wlfc->FIFO_credit[fifo_id]++;
-		}
-	}
-	else {
-		/*
-		if this packet did not count against FIFO credit, it must have
-		taken a requested_credit from the destination entry (for pspoll etc.)
-		*/
-		if (!entry) {
-
-			entry = _dhd_wlfc_find_table_entry(wlfc, pktbuf);
-		}
-		if (!DHD_PKTTAG_ONETIMEPKTRQST(PKTTAG(pktbuf)))
-			entry->requested_credit++;
-#ifdef PROP_TXSTATUS_DEBUG
-		entry->dstncredit_acks++;
-#endif
-	}
-	if ((status_flag == WLFC_CTL_PKTFLAG_D11SUPPRESS) ||
-		(status_flag == WLFC_CTL_PKTFLAG_WLSUPPRESS)) {
-		ret = _dhd_wlfc_enque_suppressed(wlfc, fifo_id, pktbuf);
-		if (ret != BCME_OK) {
-			/* delay q is full, drop this packet */
-			dhd_wlfc_hanger_poppkt(wlfc->hanger, WLFC_PKTID_HSLOT_GET(status),
-			&pktbuf, 1);
-
-			/* indicate failure and free the packet */
-			dhd_txcomplete(dhd, pktbuf, FALSE);
-			PKTFREE(wlfc->osh, pktbuf, TRUE);
-		}
-	}
-	else {
-		dhd_txcomplete(dhd, pktbuf, TRUE);
-		/* free the packet */
-		PKTFREE(wlfc->osh, pktbuf, TRUE);
-	}
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_fifocreditback_indicate(dhd_pub_t *dhd, uint8* credits)
-{
-	int i;
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	for (i = 0; i < WLFC_CTL_VALUE_LEN_FIFO_CREDITBACK; i++) {
-#ifdef PROP_TXSTATUS_DEBUG
-		wlfc->stats.fifo_credits_back[i] += credits[i];
-#endif
-		/* update FIFO credits */
-		if (wlfc->proptxstatus_mode == WLFC_FCMODE_EXPLICIT_CREDIT)
-			wlfc->FIFO_credit[i] += credits[i];
-	}
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_rssi_indicate(dhd_pub_t *dhd, uint8* rssi)
-{
-	(void)dhd;
-	(void)rssi;
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_mac_table_update(dhd_pub_t *dhd, uint8* value, uint8 type)
-{
-	int rc;
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	wlfc_mac_descriptor_t* table;
-	uint8 existing_index;
-	uint8 table_index;
-	uint8 ifid;
-	uint8* ea;
-
-	WLFC_DBGMESG(("%s(), mac [%02x:%02x:%02x:%02x:%02x:%02x],%s,idx:%d,id:0x%02x\n",
-		__FUNCTION__, value[2], value[3], value[4], value[5], value[6], value[7],
-		((type == WLFC_CTL_TYPE_MACDESC_ADD) ? "ADD":"DEL"),
-		WLFC_MAC_DESC_GET_LOOKUP_INDEX(value[0]), value[0]));
-
-	table = wlfc->destination_entries.nodes;
-	table_index = WLFC_MAC_DESC_GET_LOOKUP_INDEX(value[0]);
-	ifid = value[1];
-	ea = &value[2];
-
-	if (type == WLFC_CTL_TYPE_MACDESC_ADD) {
-		existing_index = dhd_wlfc_find_mac_desc_id_from_mac(dhd, &value[2]);
-		if (existing_index == WLFC_MAC_DESC_ID_INVALID) {
-			/* this MAC entry does not exist, create one */
-			if (!table[table_index].occupied) {
-				table[table_index].mac_handle = value[0];
-				rc = _dhd_wlfc_mac_entry_update(wlfc, &table[table_index],
-				eWLFC_MAC_ENTRY_ACTION_ADD, ifid,
-				wlfc->destination_entries.interfaces[ifid].iftype,
-				ea);
-			}
-			else {
-				/* the space should have been empty, but it's not */
-				wlfc->stats.mac_update_failed++;
-			}
-		}
-		else {
-			/*
-			there is an existing entry, move it to new index
-			if necessary.
-			*/
-			if (existing_index != table_index) {
-				/* if we already have an entry, free the old one */
-				table[existing_index].occupied = 0;
-				table[existing_index].state = WLFC_STATE_CLOSE;
-				table[existing_index].requested_credit = 0;
-				table[existing_index].interface_id = 0;
-				/* enable after packets are queued-deqeued properly.
-				pktq_flush(dhd->osh, &table[existing_index].psq, FALSE);
-				*/
-			}
-		}
-	}
-	if (type == WLFC_CTL_TYPE_MACDESC_DEL) {
-		if (table[table_index].occupied) {
-				rc = _dhd_wlfc_mac_entry_update(wlfc, &table[table_index],
-					eWLFC_MAC_ENTRY_ACTION_DEL, ifid,
-					wlfc->destination_entries.interfaces[ifid].iftype,
-					ea);
-		}
-		else {
-			/* the space should have been occupied, but it's not */
-			wlfc->stats.mac_update_failed++;
-		}
-	}
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_psmode_update(dhd_pub_t *dhd, uint8* value, uint8 type)
-{
-	/* Handle PS on/off indication */
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	wlfc_mac_descriptor_t* table;
-	wlfc_mac_descriptor_t* desc;
-	uint8 mac_handle = value[0];
-	int i;
-
-	table = wlfc->destination_entries.nodes;
-	desc = &table[WLFC_MAC_DESC_GET_LOOKUP_INDEX(mac_handle)];
-	if (desc->occupied) {
-		/* a fresh PS mode should wipe old ps credits? */
-		desc->requested_credit = 0;
-		if (type == WLFC_CTL_TYPE_MAC_OPEN) {
-			desc->state = WLFC_STATE_OPEN;
-			DHD_WLFC_CTRINC_MAC_OPEN(desc);
-		}
-		else {
-			desc->state = WLFC_STATE_CLOSE;
-			DHD_WLFC_CTRINC_MAC_CLOSE(desc);
-			/*
-			Indicate to firmware if there is any traffic pending.
-			*/
-			for (i = AC_BE; i < AC_COUNT; i++) {
-				_dhd_wlfc_traffic_pending_check(wlfc, desc, i);
-			}
-		}
-	}
-	else {
-		wlfc->stats.psmode_update_failed++;
-	}
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_interface_update(dhd_pub_t *dhd, uint8* value, uint8 type)
-{
-	/* Handle PS on/off indication */
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	wlfc_mac_descriptor_t* table;
-	uint8 if_id = value[0];
-
-	if (if_id < WLFC_MAX_IFNUM) {
-		table = wlfc->destination_entries.interfaces;
-		if (table[if_id].occupied) {
-			if (type == WLFC_CTL_TYPE_INTERFACE_OPEN) {
-				table[if_id].state = WLFC_STATE_OPEN;
-				/* WLFC_DBGMESG(("INTERFACE[%d] OPEN\n", if_id)); */
-			}
-			else {
-				table[if_id].state = WLFC_STATE_CLOSE;
-				/* WLFC_DBGMESG(("INTERFACE[%d] CLOSE\n", if_id)); */
-			}
-			return BCME_OK;
-		}
-	}
-	wlfc->stats.interface_update_failed++;
-
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_credit_request(dhd_pub_t *dhd, uint8* value)
-{
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	wlfc_mac_descriptor_t* table;
-	wlfc_mac_descriptor_t* desc;
-	uint8 mac_handle;
-	uint8 credit;
-
-	table = wlfc->destination_entries.nodes;
-	mac_handle = value[1];
-	credit = value[0];
-
-	desc = &table[WLFC_MAC_DESC_GET_LOOKUP_INDEX(mac_handle)];
-	if (desc->occupied) {
-		desc->requested_credit = credit;
-
-		desc->ac_bitmap = value[2];
-	}
-	else {
-		wlfc->stats.credit_request_failed++;
-	}
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_packet_request(dhd_pub_t *dhd, uint8* value)
-{
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	wlfc_mac_descriptor_t* table;
-	wlfc_mac_descriptor_t* desc;
-	uint8 mac_handle;
-	uint8 packet_count;
-
-	table = wlfc->destination_entries.nodes;
-	mac_handle = value[1];
-	packet_count = value[0];
-
-	desc = &table[WLFC_MAC_DESC_GET_LOOKUP_INDEX(mac_handle)];
-	if (desc->occupied) {
-		desc->requested_packet = packet_count;
-
-		desc->ac_bitmap = value[2];
-	}
-	else {
-		wlfc->stats.packet_request_failed++;
-	}
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_parse_header_info(dhd_pub_t *dhd, void* pktbuf, int tlv_hdr_len)
-{
-	uint8 type, len;
-	uint8* value;
-	uint8* tmpbuf;
-	uint16 remainder = tlv_hdr_len;
-	uint16 processed = 0;
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	tmpbuf = (uint8*)PKTDATA(dhd->osh, pktbuf);
-	if (remainder) {
-		while ((processed < (WLFC_MAX_PENDING_DATALEN * 2)) && (remainder > 0)) {
-			type = tmpbuf[processed];
-			if (type == WLFC_CTL_TYPE_FILLER) {
-				remainder -= 1;
-				processed += 1;
-				continue;
-			}
-
-			len  = tmpbuf[processed + 1];
-			value = &tmpbuf[processed + 2];
-
-			if (remainder < (2 + len))
-				break;
-
-			remainder -= 2 + len;
-			processed += 2 + len;
-			if (type == WLFC_CTL_TYPE_TXSTATUS)
-				dhd_wlfc_txstatus_update(dhd, value);
-
-			else if (type == WLFC_CTL_TYPE_FIFO_CREDITBACK)
-				dhd_wlfc_fifocreditback_indicate(dhd, value);
-
-			else if (type == WLFC_CTL_TYPE_RSSI)
-				dhd_wlfc_rssi_indicate(dhd, value);
-
-			else if (type == WLFC_CTL_TYPE_MAC_REQUEST_CREDIT)
-				dhd_wlfc_credit_request(dhd, value);
-
-			else if (type == WLFC_CTL_TYPE_MAC_REQUEST_PACKET)
-				dhd_wlfc_packet_request(dhd, value);
-
-			else if ((type == WLFC_CTL_TYPE_MAC_OPEN) ||
-				(type == WLFC_CTL_TYPE_MAC_CLOSE))
-				dhd_wlfc_psmode_update(dhd, value, type);
-
-			else if ((type == WLFC_CTL_TYPE_MACDESC_ADD) ||
-				(type == WLFC_CTL_TYPE_MACDESC_DEL))
-				dhd_wlfc_mac_table_update(dhd, value, type);
-
-			else if ((type == WLFC_CTL_TYPE_INTERFACE_OPEN) ||
-				(type == WLFC_CTL_TYPE_INTERFACE_CLOSE)) {
-				dhd_wlfc_interface_update(dhd, value, type);
-			}
-		}
-		if (remainder != 0) {
-			/* trouble..., something is not right */
-			wlfc->stats.tlv_parse_failed++;
-		}
-	}
-	return BCME_OK;
-}
-
-int dhd_wlfc_init(dhd_pub_t *dhd)
-{
-	int i;
-	athost_wl_status_info_t* wlfc;
-
-	char iovbuf[12]; /* Room for "tlv" + '\0' + parameter */
-	/* enable all signals & indicate host proptxstatus logic is active */
-	uint32 tlv = WLFC_FLAGS_RSSI_SIGNALS |
-		WLFC_FLAGS_XONXOFF_SIGNALS |
-		WLFC_FLAGS_CREDIT_STATUS_SIGNALS |
-		WLFC_FLAGS_HOST_PROPTXSTATUS_ACTIVE;
-
-	/*
-	try to enable signalling by sending "tlv" iovar. if that fails,
-	fallback to no flow control? Print a message for now.
-	*/
-
-	/* enable proptxtstatus signalling by default */
-	bcm_mkiovar("tlv", (char *)&tlv, 4, iovbuf, sizeof(iovbuf));
-	if (dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0) < 0) {
-		DHD_ERROR(("dhd_wlfc_init(): failed to enable bdcv2 tlv signalling\n"));
-	}
-	else {
-		/*
-		Leaving the message for now, it should be removed after a while; once
-		the tlv situation is stable.
-		*/
-		DHD_ERROR(("dhd_wlfc_init(): successfully enabled bdcv2 tlv signalling, %d\n",
-			tlv));
-	}
-
-	/* allocate space to track txstatus propagated from firmware */
-	dhd->wlfc_state = MALLOC(dhd->osh, sizeof(athost_wl_status_info_t));
-	if (dhd->wlfc_state == NULL)
-		return BCME_NOMEM;
-
-	/* initialize state space */
-	wlfc = (athost_wl_status_info_t*)dhd->wlfc_state;
-	memset(wlfc, 0, sizeof(athost_wl_status_info_t));
-
-	/* remember osh & dhdp */
-	wlfc->osh = dhd->osh;
-	wlfc->dhdp = dhd;
-
-	wlfc->hanger =
-		dhd_wlfc_hanger_create(dhd->osh, WLFC_HANGER_MAXITEMS);
-	if (wlfc->hanger == NULL) {
-		MFREE(dhd->osh, dhd->wlfc_state, sizeof(athost_wl_status_info_t));
-		dhd->wlfc_state = NULL;
-		return BCME_NOMEM;
-	}
-
-	/* initialize all interfaces to accept traffic */
-	for (i = 0; i < WLFC_MAX_IFNUM; i++) {
-		wlfc->hostif_flow_state[i] = OFF;
-	}
-
-	/* 
-	create the SENDQ containing
-	sub-queues for all AC precedences + 1 for bc/mc traffic
-	*/
-	pktq_init(&wlfc->SENDQ, (AC_COUNT + 1), WLFC_SENDQ_LEN);
-
-	wlfc->destination_entries.other.state = WLFC_STATE_OPEN;
-	/* bc/mc FIFO is always open [credit aside], i.e. b[5] */
-	wlfc->destination_entries.other.ac_bitmap = 0x1f;
-	wlfc->destination_entries.other.interface_id = 0;
-
-	wlfc->proptxstatus_mode = WLFC_FCMODE_EXPLICIT_CREDIT;
-
-	return BCME_OK;
-}
-
-/* release all packet resources */
-void dhd_wlfc_cleanup(dhd_pub_t *dhd)
-{
-	int i;
-	int total_entries;
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	wlfc_mac_descriptor_t* table;
-	wlfc_hanger_t* h;
-
-	if (dhd->wlfc_state == NULL)
-		return;
-
-	total_entries = sizeof(wlfc->destination_entries)/sizeof(wlfc_mac_descriptor_t);
-	/* search all entries, include nodes as well as interfaces */
-	table = (wlfc_mac_descriptor_t*)&wlfc->destination_entries;
-
-	for (i = 0; i < total_entries; i++) {
-		if (table[i].occupied) {
-			if (table[i].psq.len) {
-				WLFC_DBGMESG(("%s(): DELAYQ[%d].len = %d\n",
-					__FUNCTION__, i, table[i].psq.len));
-				/* release packets held in DELAYQ */
-				pktq_flush(wlfc->osh, &table[i].psq, TRUE);
-			}
-			table[i].occupied = 0;
-		}
-	}
-	/* release packets held in SENDQ */
-	if (wlfc->SENDQ.len)
-		pktq_flush(wlfc->osh, &wlfc->SENDQ, TRUE);
-	/* any in the hanger? */
-	h = (wlfc_hanger_t*)wlfc->hanger;
-	for (i = 0; i < h->max_items; i++) {
-		if (h->items[i].state == WLFC_HANGER_ITEM_STATE_INUSE) {
-			PKTFREE(wlfc->osh, h->items[i].pkt, TRUE);
-		}
-	}
-	return;
-}
-
-void dhd_wlfc_deinit(dhd_pub_t *dhd)
-{
-	/* cleanup all psq related resources */
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-
-	if (dhd->wlfc_state == NULL)
-		return;
-
-#ifdef PROP_TXSTATUS_DEBUG
-	{
-		int i;
-		wlfc_hanger_t* h = (wlfc_hanger_t*)wlfc->hanger;
-		for (i = 0; i < h->max_items; i++) {
-			if (h->items[i].state == WLFC_HANGER_ITEM_STATE_INUSE) {
-				WLFC_DBGMESG(("%s() pkt[%d] = 0x%p, FIFO_credit_used:%d\n",
-					__FUNCTION__, i, h->items[i].pkt,
-					DHD_PKTTAG_CREDITCHECK(PKTTAG(h->items[i].pkt))));
-			}
-		}
-	}
-#endif
-	/* delete hanger */
-	dhd_wlfc_hanger_delete(dhd->osh, wlfc->hanger);
-
-	/* free top structure */
-	MFREE(dhd->osh, dhd->wlfc_state, sizeof(athost_wl_status_info_t));
-	dhd->wlfc_state = NULL;
-	return;
-}
-#endif /* PROP_TXSTATUS */
-
-void
-dhd_prot_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf)
-{
-	bcm_bprintf(strbuf, "Protocol CDC: reqid %d\n", dhdp->prot->reqid);
-#ifdef PROP_TXSTATUS
-	dhd_wlfc_dump(dhdp, strbuf);
-#endif
-}
-
-void
-dhd_prot_hdrpush(dhd_pub_t *dhd, int ifidx, void *pktbuf)
-{
-#ifdef BDC
-	struct bdc_header *h;
-	uint8 dataOffset = 0;
-#endif /* BDC */
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
-
-#ifdef BDC
-	/* Push BDC header used to convey priority for buses that don't */
-
-	PKTPUSH(dhd->osh, pktbuf, BDC_HEADER_LEN);
-
-	h = (struct bdc_header *)PKTDATA(dhd->osh, pktbuf);
-
-	h->flags = (BDC_PROTO_VER << BDC_FLAG_VER_SHIFT);
-	if (PKTSUMNEEDED(pktbuf))
-		h->flags |= BDC_FLAG_SUM_NEEDED;
-
-
-	h->priority = (PKTPRIO(pktbuf) & BDC_PRIORITY_MASK);
-	h->flags2 = 0;
-#endif /* BDC */
-	h->dataOffset = dataOffset;
-	BDC_SET_IF_IDX(h, ifidx);
-}
-
-bool
-dhd_proto_fcinfo(dhd_pub_t *dhd, void *pktbuf, uint8 *fcbits)
-{
-#ifdef BDC
-	struct bdc_header *h;
-
-	if (PKTLEN(dhd->osh, pktbuf) < BDC_HEADER_LEN) {
-		DHD_ERROR(("%s: rx data too short (%d < %d)\n",
-			__FUNCTION__, PKTLEN(dhd->osh, pktbuf), BDC_HEADER_LEN));
-		return BCME_ERROR;
-	}
-
-	h = (struct bdc_header *)PKTDATA(dhd->osh, pktbuf);
-
-	*fcbits = h->priority >> BDC_PRIORITY_FC_SHIFT;
-	if ((h->flags2 & BDC_FLAG2_FC_FLAG) == BDC_FLAG2_FC_FLAG)
-		return TRUE;
-#endif
-	return FALSE;
-}
-
-int
-dhd_prot_hdrpull(dhd_pub_t *dhd, int *ifidx, void *pktbuf)
-{
-#ifdef BDC
-	struct bdc_header *h;
-#endif
-
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
-
-#ifdef BDC
-	/* Pop BDC header used to convey priority for buses that don't */
-
-	if (PKTLEN(dhd->osh, pktbuf) < BDC_HEADER_LEN) {
-		DHD_ERROR(("%s: rx data too short (%d < %d)\n", __FUNCTION__,
-		           PKTLEN(dhd->osh, pktbuf), BDC_HEADER_LEN));
-		return BCME_ERROR;
-	}
-
-	h = (struct bdc_header *)PKTDATA(dhd->osh, pktbuf);
-
-	if ((*ifidx = BDC_GET_IF_IDX(h)) >= DHD_MAX_IFS) {
-		DHD_ERROR(("%s: rx data ifnum out of range (%d)\n",
-		           __FUNCTION__, *ifidx));
-		return BCME_ERROR;
-	}
-
-	if (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) != BDC_PROTO_VER) {
-		DHD_ERROR(("%s: non-BDC packet received, flags = 0x%x\n",
-		           dhd_ifname(dhd, *ifidx), h->flags));
-		if (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) == BDC_PROTO_VER_1)
-			h->dataOffset = 0;
-		else
-			return BCME_ERROR;
-	}
-
-	if (h->flags & BDC_FLAG_SUM_GOOD) {
-		DHD_INFO(("%s: BDC packet received with good rx-csum, flags 0x%x\n",
-		          dhd_ifname(dhd, *ifidx), h->flags));
-		PKTSETSUMGOOD(pktbuf, TRUE);
-	}
-
-	PKTSETPRIO(pktbuf, (h->priority & BDC_PRIORITY_MASK));
-	PKTPULL(dhd->osh, pktbuf, BDC_HEADER_LEN);
-#endif /* BDC */
-
-#ifdef PROP_TXSTATUS
-	if (((athost_wl_status_info_t*)dhd->wlfc_state)->proptxstatus_mode != WLFC_FCMODE_NONE) {
-		if (!DHD_PKTTAG_PKTDIR(PKTTAG(pktbuf))) {
-			/*
-			- parse txstatus only for packets that came from the firmware
-			*/
-			dhd_os_wlfc_block(dhd);
-			dhd_wlfc_parse_header_info(dhd, pktbuf, (h->dataOffset << 2));
-			((athost_wl_status_info_t*)dhd->wlfc_state)->stats.dhd_hdrpulls++;
-			dhd_wlfc_commit_packets(dhd->wlfc_state,  (f_commitpkt_t)dhd_bus_txdata,
-				dhd->bus);
-			dhd_os_wlfc_unblock(dhd);
-		}
-	}
-#endif
-	PKTPULL(dhd->osh, pktbuf, (h->dataOffset << 2));
-	return 0;
-}
-
-int
-dhd_prot_attach(dhd_pub_t *dhd)
-{
-	dhd_prot_t *cdc;
-
-#ifndef DHD_USE_STATIC_BUF
-	if (!(cdc = (dhd_prot_t *)MALLOC(dhd->osh, sizeof(dhd_prot_t)))) {
-		DHD_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
-		goto fail;
-	}
-#else
-	if (!(cdc = (dhd_prot_t *)dhd_os_prealloc(DHD_PREALLOC_PROT, sizeof(dhd_prot_t)))) {
-		DHD_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
-		goto fail;
-	}
-#endif /* DHD_USE_STATIC_BUF */
-	memset(cdc, 0, sizeof(dhd_prot_t));
-
-	/* ensure that the msg buf directly follows the cdc msg struct */
-	if ((uintptr)(&cdc->msg + 1) != (uintptr)cdc->buf) {
-		DHD_ERROR(("dhd_prot_t is not correctly defined\n"));
-		goto fail;
-	}
-
-	dhd->prot = cdc;
-#ifdef BDC
-	dhd->hdrlen += BDC_HEADER_LEN;
-#endif
-	dhd->maxctl = WLC_IOCTL_MAXLEN + sizeof(cdc_ioctl_t) + ROUND_UP_MARGIN;
-	return 0;
-
-fail:
-#ifndef DHD_USE_STATIC_BUF
-	if (cdc != NULL)
-		MFREE(dhd->osh, cdc, sizeof(dhd_prot_t));
-#endif
-	return BCME_NOMEM;
-}
-
-/* ~NOTE~ What if another thread is waiting on the semaphore?  Holding it? */
-void
-dhd_prot_detach(dhd_pub_t *dhd)
-{
-#ifdef PROP_TXSTATUS
-	dhd_wlfc_deinit(dhd);
-#endif
-#ifndef DHD_USE_STATIC_BUF
-	MFREE(dhd->osh, dhd->prot, sizeof(dhd_prot_t));
-#endif
-	dhd->prot = NULL;
-}
-
-void
-dhd_prot_dstats(dhd_pub_t *dhd)
-{
-	/* No stats from dongle added yet, copy bus stats */
-	dhd->dstats.tx_packets = dhd->tx_packets;
-	dhd->dstats.tx_errors = dhd->tx_errors;
-	dhd->dstats.rx_packets = dhd->rx_packets;
-	dhd->dstats.rx_errors = dhd->rx_errors;
-	dhd->dstats.rx_dropped = dhd->rx_dropped;
-	dhd->dstats.multicast = dhd->rx_multicast;
-	return;
-}
-
-#define htod32(i) i
-
-#define strtoul(nptr, endptr, base) bcm_strtoul((nptr), (endptr), (base))
-
-/* Convert user's input in hex pattern to byte-size mask */
-static int
-wl_pattern_atoh(char *src, char *dst)
-{
-	int i;
-	if (strncmp(src, "0x", 2) != 0 &&
-	    strncmp(src, "0X", 2) != 0) {
-		printf("Mask invalid format. Needs to start with 0x\n");
-		return -1;
-	}
-	src = src + 2; /* Skip past 0x */
-	if (strlen(src) % 2 != 0) {
-		printf("Mask invalid format. Needs to be of even length\n");
-		return -1;
-	}
-	for (i = 0; *src != '\0'; i++) {
-		char num[3];
-		strncpy(num, src, 2);
-		num[2] = '\0';
-		dst[i] = (uint8)strtoul(num, NULL, 16);
-		src += 2;
-	}
-	return i;
-}
-
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-04-03, configs */
-#if defined(CONFIG_LGE_BCM432X_PATCH)
-#include <linux/fs.h>
-#include <linux/ctype.h>
-
-#if 0
-
-CONFIG FILE FORMAT
-==================
-
-AVAILABLE PARAMETERS
-~~~~~~~~~~~~~~~~~~~~
-+====================+=========================================================+
-| VARIABLE NAME      | DESCRIPTION                                             |
-+====================+=========================================================+
-| btc_mode           | BTCoexist                                               |
-|                    | 0: disable, 1: enable                                   |
-+--------------------+---------------------------------------------------------+
-| country            | Country Code                                            |
-|                    | KR, EU, US or AU ...                                    |
-+--------------------+---------------------------------------------------------+
-| vlan_mode          | Specifies the use of 802.1Q Tags (ON, OFF, AUTO).       |
-|                    | 0: off, 1: on, -1: auto                                 |
-+--------------------+---------------------------------------------------------+
-| mpc                | Minimum Power Consumption                               |
-|                    | 0: disable, 1: enable                                   |
-+--------------------+---------------------------------------------------------+
-| wme                | WME QoS                                                 |
-|                    | 0: disable, 1: enable                                   |
-+--------------------+---------------------------------------------------------+
-| wme_apsd           | WME APSD (Advanced Power Save Delivery)                 |
-|                    | 0: disable, 1: enable                                   |
-+--------------------+---------------------------------------------------------+
-| wme_qosinfo        | Set APSD parameters on STA.                             |
-|                    | - max_sp_len = number of frames per USP: 0 (all), 2, 4, |
-|                    |   or 6                                                  |
-|                    | - be, bk, vi, and vo = 0 to disable, 1 to enable U-APSD |
-|                    |   per AC                                                |
-|                    |        <max_sp_len> <be> <bk> <vi> <vo>                 |
-|                    | 0x0f =      0         1    1    1    1                  |
-|                    | 0x2f =      2         1    1    1    1                  |
-|                    | 0x4f =      4         1    1    1    1                  |
-|                    | 0x6f =      6         1    1    1    1                  |
-|                    | 0x03 =      0         0    0    1    1                  |
-+--------------------+---------------------------------------------------------+
-| wme_auto_trigger   | 0: disable, 1: enable                                   |
-+--------------------+---------------------------------------------------------+
-| wme_apsd_trigger   | in msec, 0: disable                                     |
-+--------------------+---------------------------------------------------------+
-| roam_off           | 0: roaming on, 1: roaming off                           |
-+--------------------+---------------------------------------------------------+
-| roam_scan_period   | in sec                                                  |
-+--------------------+---------------------------------------------------------+
-| roam_delta         | in dB                                                   |
-+--------------------+---------------------------------------------------------+
-| roam_trigger       | in dBm                                                  |
-+--------------------+---------------------------------------------------------+
-| PM                 | Power Saving Mode                                       |
-|                    | 0: off, 1: max, 2: fast                                 |
-+--------------------+---------------------------------------------------------+
-| assoc_listen       | The Listen Interval sent in association requests        |
-|                    | number of beacon                                        |
-+--------------------+---------------------------------------------------------+
-
-EXAMPLE
-~~~~~~~
-btc_mode=1
-country=AU
-vlan_mode=0
-mpc=1
-wme=1
-wme_apsd=0
-wme_qosinfo=0x00
-wme_auto_trigger=1
-wme_apsd_trigger=0
-roam_off=0
-roam_scan_period=10
-roam_delta=20
-roam_trigger=-70
-PM=2
-assoc_listen=1
-
-#endif
-
-static int dhd_preinit_proc(dhd_pub_t *dhd, int ifidx, char *name, char *value)
-{
-	int var_int;
-
-	if (!strcmp(name, "country")) {
-		return dhdcdc_set_ioctl(dhd, ifidx, WLC_SET_COUNTRY,
-				value, WLC_CNTRY_BUF_SZ, TRUE);
-	} else if (!strcmp(name, "roam_scan_period")) {
-		var_int = (int)simple_strtol(value, NULL, 0);
-		return dhdcdc_set_ioctl(dhd, ifidx, WLC_SET_ROAM_SCAN_PERIOD,
-				&var_int, sizeof(var_int), TRUE);
-	} else if (!strcmp(name, "roam_delta") || !strcmp(name, "roam_trigger")) {
-		struct {
-			int val;
-			int band;
-		} x;
-		x.val = (int)simple_strtol(value, NULL, 0);
-		x.band = WLC_BAND_AUTO;
-		return dhdcdc_set_ioctl(dhd, ifidx, strcmp(name, "roam_delta") ?
-				WLC_SET_ROAM_TRIGGER : WLC_SET_ROAM_DELTA, &x, sizeof(x), TRUE);
-	} else if (!strcmp(name, "PM")) {
-		var_int = (int)simple_strtol(value, NULL, 0);
-		return dhdcdc_set_ioctl(dhd, ifidx, WLC_SET_PM,
-				&var_int, sizeof(var_int), TRUE);
-	} else if(!strcmp(name,"cur_etheraddr")) {
-		struct ether_addr ea;
-		char buf[32];
-		uint iovlen;
-		int ret;
-
-		bcm_ether_atoe(value, &ea);
-
-		ret = memcmp( &ea.octet, dhd->mac.octet, ETHER_ADDR_LEN);
-		if(ret == 0){
-			DHD_ERROR(("%s: Same Macaddr\n",__FUNCTION__));
-			return 0;
-		}
-
-		DHD_ERROR(("%s: Change Macaddr = %02X:%02X:%02X:%02X:%02X:%02X\n",__FUNCTION__,
-					ea.octet[0], ea.octet[1], ea.octet[2],
-					ea.octet[3], ea.octet[4], ea.octet[5]));
-
-		iovlen = bcm_mkiovar("cur_etheraddr", (char*)&ea, ETHER_ADDR_LEN, buf, 32);
-
-		ret = dhdcdc_set_ioctl(dhd, ifidx, WLC_SET_VAR, buf, iovlen, TRUE);
-		if (ret < 0) {
-			DHD_ERROR(("%s: can't set MAC address , error=%d\n", __FUNCTION__, ret));
-			return ret;
-		}
-		else{
-			memcpy(dhd->mac.octet, (void *)&ea, ETHER_ADDR_LEN);
-			return ret;
-		}
-	} else {
-		uint iovlen;
-		char iovbuf[WLC_IOCTL_SMLEN];
-
-		/* wlu_iovar_setint */
-		var_int = (int)simple_strtol(value, NULL, 0);
-
-		/* Setup timeout bcn_timeout from dhd driver 4.217.48 */
-		if(!strcmp(name, "roam_off")) {
-			/* Setup timeout if Beacons are lost to report link down */
-			if (var_int) {
-				uint bcn_timeout = 2;
-				bcm_mkiovar("bcn_timeout", (char *)&bcn_timeout, 4, iovbuf, sizeof(iovbuf));
-				dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE);
-			}
-		}
-		/* Setup timeout bcm_timeout from dhd driver 4.217.48 */
-
-		iovlen = bcm_mkiovar(name, (char *)&var_int, sizeof(var_int),
-				iovbuf, sizeof(iovbuf));
-		return dhdcdc_set_ioctl(dhd, ifidx, WLC_SET_VAR,
-				iovbuf, iovlen, TRUE);
-	}
-
-	return 0;
-}
-
-static int dhd_preinit_config(dhd_pub_t *dhd, int ifidx)
-{
-	mm_segment_t old_fs;
-	struct kstat stat;
-	struct file *fp = NULL;
-	unsigned int len;
-	char *buf = NULL, *p, *name, *value;
-	int ret = 0;
-
-	if (!*config_path)
-		return 0;
-
-	old_fs = get_fs();
-	set_fs(get_ds());
-	if ((ret = vfs_stat(config_path, &stat))) {
-		set_fs(old_fs);
-		printk(KERN_ERR "%s: Failed to get information (%d)\n",
-				config_path, ret);
-		return ret;
-	}
-	set_fs(old_fs);
-
-	if (!(buf = MALLOC(dhd->osh, stat.size + 1))) {
-		printk(KERN_ERR "Failed to allocate memory %llu bytes\n", stat.size);
-		return -ENOMEM;
-	}
-
-	if (!(fp = dhd_os_open_image(config_path)) ||
-		(len = dhd_os_get_image_block(buf, stat.size, fp)) < 0)
-		goto err;
-
-	buf[stat.size] = '\0';
-	for (p = buf; *p; p++) {
-		if (isspace(*p))
-			continue;
-		for (name = p++; *p && !isspace(*p); p++) {
-			if (*p == '=') {
-				*p = '\0';
-				p++;
-				for (value = p; *p && !isspace(*p); p++);
-				*p = '\0';
-				if ((ret = dhd_preinit_proc(dhd, ifidx, name, value)) < 0)
-					printk(KERN_ERR "%s: %s=%s\n",
-							bcmerrorstr(ret), name, value);
-				break;
-			}
-		}
-	}
-	ret = 0;
-
-out:
-	if (fp)
-		dhd_os_close_image(fp);
-	if (buf)
-		MFREE(dhd->osh, buf, stat.size+1);
-	return ret;
-
-err:
-	ret = -1;
-	goto out;
-}
-#endif /* CONFIG_LGE_BCM432X_PATCH */
-/* LGE_CHANGE_E [yoohoo@lge.com] 2009-04-03, configs */
-
-int
-dhd_preinit_ioctls(dhd_pub_t *dhd)
-{
-	char eventmask[WL_EVENTING_MASK_LEN];
-	char iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" + '\0' + bitvec  */
-	int ret;
-	uint up = 0;
-	
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-08-27, roam_off, PM */
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
-#ifdef CUSTOMER_HW2
-	uint roamvar = 0;
-#else
-	uint roamvar = 1;
-#endif
-	uint power_mode = PM_FAST;
-#endif /* CONFIG_LGE_BCM432X_PATCH */
-/* LGE_CHANGE_E [yoohoo@lge.com] 2009-08-27, roam_off, PM */
-	uint32 dongle_align = DHD_SDALIGN;
-	uint32 glom = 0;
- /* LGE_CHANGE_S [hayun.kim@lge.com] 2012-04-09,bcn_timeout 4->1 */
-	uint bcn_timeout = 4; 
- /* LGE_CHANGE_E [hayun.kim@lge.com] 2012-04-09,bcn_timeout 4->1 */
-	int arpoe = 1;
-	int arp_ol = 0xb; //0xf -> 0xb
-	int scan_assoc_time = 40;
-	int scan_unassoc_time = 80;
-	const char 				*str;
-	wl_pkt_filter_t		pkt_filter;
-	wl_pkt_filter_t		*pkt_filterp;
-	int						buf_len;
-	int						str_len;
-	uint32					mask_size;
-	uint32					pattern_size;
-	char buf[256];
-	uint filter_mode = 1;
-#ifdef AP
-	uint32 mpc = 0; /* Turn MPC off for AP/APSTA mode */
-	uint32 apsta = 1; /* Enable APSTA mode */
-#endif
-
-	/* Get the device MAC address */
-	strcpy(iovbuf, "cur_etheraddr");
-	if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, iovbuf, sizeof(iovbuf), FALSE, 0)) < 0) {
-		DHD_ERROR(("%s: can't get MAC address , error=%d\n", __FUNCTION__, ret));
-		return BCME_NOTUP;
-	}
-	memcpy(dhd->mac.octet, iovbuf, ETHER_ADDR_LEN);
-	/* Set Country code */
-	if (dhd->country_code[0] != 0) {
-		if (dhd_wl_ioctl_cmd(dhd, WLC_SET_COUNTRY,
-			dhd->country_code, sizeof(dhd->country_code), TRUE, 0) < 0) {
-			DHD_ERROR(("%s: country code setting failed\n", __FUNCTION__));
-		}
-	}
-
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-08-27, already PM setup is configured */
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
-	/* Set PowerSave mode */
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_PM, (char *)&power_mode, sizeof(power_mode), TRUE, 0);
-#endif /* CONFIG_LGE_BCM432X_PATCH */
-/* LGE_CHANGE_E [yoohoo@lge.com] 2009-08-27, already PM setup is configured */
-
-	/* Match Host and Dongle rx alignment */
-	bcm_mkiovar("bus:txglomalign", (char *)&dongle_align, 4, iovbuf, sizeof(iovbuf));
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
-
-	/* disable glom option per default */
-	bcm_mkiovar("bus:txglom", (char *)&glom, 4, iovbuf, sizeof(iovbuf));
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
-	/* Setup timeout if Beacons are lost to report link down */
-	
- /* LGE_CHANGE_S [hayun.kim@lge.com] 2012-04-09,bcn_timeout 4->1 */
-	bcm_mkiovar("bcn_timeout", (char *)&bcn_timeout, 4, iovbuf, sizeof(iovbuf));
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
- /* LGE_CHANGE_E [hayun.kim@lge.com] 2012-04-09,bcn_timeout 4->1 */
-
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-04-08, roam_off */
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
-	/* Disable build-in roaming to allowed ext supplicant to take of romaing */
-	bcm_mkiovar("roam_off", (char *)&roamvar, 4, iovbuf, sizeof(iovbuf));
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
-#endif /* CONFIG_LGE_BCM432X_PATCH */
-/* LGE_CHANGE_E [yoohoo@lge.com] 2009-04-08, roam_off */
-
-#ifdef AP
-	/* Disable build-in roaming to allowed ext supplicant to take of romaing */
-	bcm_mkiovar("mpc", (char *)&mpc, 4, iovbuf, sizeof(iovbuf));
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
-
-	/* Disable build-in roaming to allowed ext supplicant to take of romaing */
-	bcm_mkiovar("apsta", (char *)&apsta, 4, iovbuf, sizeof(iovbuf));
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
-#endif
-
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-04-03, configs */
-#if defined(CONFIG_LGE_BCM432X_PATCH)
-	dhd_preinit_config(dhd, 0);
-#endif /* CONFIG_LGE_BCM432X_PATCH */
-/* LGE_CHANGE_E [yoohoo@lge.com] 2009-04-03, configs */
-	
-	/* Force STA UP */
-	dhd_wl_ioctl_cmd(dhd, WLC_UP, (char *)&up, sizeof(up), TRUE, 0);
-
-//debug
-printk("%s: WLC_UP  %d\n", __FUNCTION__, up );
-
-	/* Setup event_msgs */
-	bcm_mkiovar("event_msgs", eventmask, WL_EVENTING_MASK_LEN, iovbuf, sizeof(iovbuf));
-	dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, iovbuf, sizeof(iovbuf), FALSE, 0);
-	bcopy(iovbuf, eventmask, WL_EVENTING_MASK_LEN);
-
-	/* Setup event_msgs */
-	setbit(eventmask, WLC_E_SET_SSID);
-	setbit(eventmask, WLC_E_PRUNE);
-	setbit(eventmask, WLC_E_AUTH);
-	setbit(eventmask, WLC_E_REASSOC);
-	setbit(eventmask, WLC_E_REASSOC_IND);
-	setbit(eventmask, WLC_E_DEAUTH_IND);
-	setbit(eventmask, WLC_E_DISASSOC_IND);
-	setbit(eventmask, WLC_E_DISASSOC);
-	setbit(eventmask, WLC_E_JOIN);
-	setbit(eventmask, WLC_E_ASSOC_IND);
-	setbit(eventmask, WLC_E_PSK_SUP);
-	setbit(eventmask, WLC_E_LINK);
-	setbit(eventmask, WLC_E_NDIS_LINK);
-	setbit(eventmask, WLC_E_MIC_ERROR);
-	setbit(eventmask, WLC_E_PMKID_CACHE);
-	setbit(eventmask, WLC_E_TXFAIL);
-	setbit(eventmask, WLC_E_JOIN_START);
-	setbit(eventmask, WLC_E_SCAN_COMPLETE);
-#if defined(DONGLEOVERLAYS)
-	setbit(eventmask, WLC_E_OVERLAY_REQ);
-#endif
-#if defined(CONFIG_LGE_BCM432X_PATCH)
-	clrbit(eventmask, WLC_E_TXFAIL);
-#endif
-	bcm_mkiovar("event_msgs", eventmask, WL_EVENTING_MASK_LEN, iovbuf, sizeof(iovbuf));
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
-
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_SCAN_CHANNEL_TIME, (char *)&scan_assoc_time,
-		sizeof(scan_assoc_time), TRUE, 0);
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_SCAN_UNASSOC_TIME, (char *)&scan_unassoc_time,
-		sizeof(scan_unassoc_time), TRUE, 0);
-
-	/* Set ARP offload */
-	bcm_mkiovar("arpoe", (char *)&arpoe, 4, iovbuf, sizeof(iovbuf));
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
-	bcm_mkiovar("arp_ol", (char *)&arp_ol, 4, iovbuf, sizeof(iovbuf));
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
-
-	/* add a default packet filter pattern */
-	str = "pkt_filter_add";
-	str_len = strlen(str);
-	strncpy(buf, str, str_len);
-	buf[ str_len ] = '\0';
-	buf_len = str_len + 1;
-
-	pkt_filterp = (wl_pkt_filter_t *) (buf + str_len + 1);
-
-	/* Parse packet filter id. */
-	pkt_filter.id = htod32(100);
-
-	/* Parse filter polarity. */
-	pkt_filter.negate_match = htod32(0);
-
-	/* Parse filter type. */
-	pkt_filter.type = htod32(0);
-
-	/* Parse pattern filter offset. */
-	pkt_filter.u.pattern.offset = htod32(0);
-
-#if 0 // louislee 
-	/* Parse pattern filter mask. */
-	mask_size =	htod32(wl_pattern_atoh("0x01",
-		(char *) pkt_filterp->u.pattern.mask_and_pattern));
-
-	/* Parse pattern filter pattern. */
-	pattern_size = htod32(wl_pattern_atoh("0x00",
-		(char *) &pkt_filterp->u.pattern.mask_and_pattern[mask_size]));
-
-	if (mask_size != pattern_size) {
-		DHD_ERROR(("Mask and pattern not the same size\n"));
-		return -EINVAL;
-	}
-#else
-	/* Parse pattern filter mask. */
-	mask_size =	htod32(wl_pattern_atoh("0xffffffffffff",
-		(char *) pkt_filterp->u.pattern.mask_and_pattern));
-
-	/* Parse pattern filter pattern. */
-	pattern_size = htod32(wl_pattern_atoh("0xffffffffffff",
-		(char *) &pkt_filterp->u.pattern.mask_and_pattern[mask_size]));
-
-	if (mask_size != pattern_size) {
-		DHD_ERROR(("Mask and pattern not the same size\n"));
-		return -EINVAL;
-	}
-	
-	pkt_filter.negate_match = htod32(1);
-#endif
-	pkt_filter.u.pattern.size_bytes = mask_size;
-	buf_len += WL_PKT_FILTER_FIXED_LEN;
-	buf_len += (WL_PKT_FILTER_PATTERN_FIXED_LEN + 2 * mask_size);
-
-	/* Keep-alive attributes are set in local	variable (keep_alive_pkt), and
-	** then memcpy'ed into buffer (keep_alive_pktp) since there is no
-	** guarantee that the buffer is properly aligned.
-	*/
-	memcpy((char *)pkt_filterp, &pkt_filter,
-		WL_PKT_FILTER_FIXED_LEN + WL_PKT_FILTER_PATTERN_FIXED_LEN);
-
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, buf, buf_len, TRUE, 0);
-
-	/* set mode to allow pattern */
-	bcm_mkiovar("pkt_filter_mode", (char *)&filter_mode, 4, iovbuf, sizeof(iovbuf));
-	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
-
-	return 0;
-}
-
-int
-dhd_prot_init(dhd_pub_t *dhd)
-{
-	int ret = 0;
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
-
-
-	ret = dhd_preinit_ioctls(dhd);
+#ifdef EMBEDDED_PLATFORM
+	ret = dhd_preinit_ioctls(dhd);
+#endif /* EMBEDDED_PLATFORM */
 
 	/* Always assumes wl for now */
 	dhd->iswl = TRUE;
 
-#ifdef PROP_TXSTATUS
-	ret = dhd_wlfc_init(dhd);
-#endif
-
 	return ret;
 }
 
diff --git a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_common.c b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_common.c
index 3edffd6..d8304ec 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_common.c
+++ b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_common.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhd_common.c,v 1.5.6.8.2.6.6.30.2.31.2.19 2010/11/09 03:31:47 Exp $
+ * $Id: dhd_common.c,v 1.5.6.8.2.6.6.69.4.21 2011/01/14 22:40:46 Exp $
  */
 #include <typedefs.h>
 #include <osl.h>
@@ -38,17 +38,7 @@
 #include <msgtrace.h>
 
 
-
-#ifdef PROP_TXSTATUS
-#include <wlfc_proto.h>
-#include <dhd_wlfc.h>
-#endif
-
-#if defined(DONGLEOVERLAYS)
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
-#include <linux/rtnetlink.h>
-#endif
-#endif /* DONGLEOVERLAYS */
+#include <wlioctl.h>
 
 int dhd_msg_level;
 
@@ -73,11 +63,24 @@ uint32 dhd_conn_reason;
 #define dtoh32(i) i
 #define dtoh16(i) i
 
+/* LGE_CHANGE_S [bill.park@lge.com] 2010-12-10, mac write */
+#define NV_WIFI_MACADDR "/data/misc/wifi/config_mac"
+//#define NV_WIFI_MACFLAG "/proc/nvdata/WIFI_FLAG"
+/* LGE_CHANGE_E [bill.park@lge.com] 2010-12-10, mac write */
+
+extern int dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len);
 extern void dhd_ind_scan_confirm(void *h, bool status);
-extern int dhd_iscan_in_progress(void *h);
+extern int dhd_wl_ioctl(dhd_pub_t *dhd, uint cmd, char *buf, uint buflen);
 void dhd_iscan_lock(void);
 void dhd_iscan_unlock(void);
 
+#if defined(SOFTAP)
+extern bool ap_fw_loaded;
+#endif 
+#if defined(KEEP_ALIVE)
+int dhd_keep_alive_onoff(dhd_pub_t *dhd, int ka_on);
+#endif /* KEEP_ALIVE */
+
 /* Packet alignment for most efficient SDIO (can change based on platform) */
 #ifndef DHD_SDALIGN
 #define DHD_SDALIGN	32
@@ -95,11 +98,6 @@ const char dhd_version[] = "Dongle Host Driver, version " EPI_VERSION_STR;
 
 void dhd_set_timer(void *bus, uint wdtick);
 
-#if defined(DONGLEOVERLAYS)
-static int _overlay_req_sysioc_thread(void *data);
-#endif
-
-
 /* IOVar table */
 enum {
 	IOV_VERSION = 1,
@@ -107,24 +105,17 @@ enum {
 	IOV_BCMERRORSTR,
 	IOV_BCMERROR,
 	IOV_WDTICK,
-	IOV_DCONSOLE_POLL,
 	IOV_DUMP,
+#ifdef DHD_DEBUG
+	IOV_CONS,
+	IOV_DCONSOLE_POLL,
+#endif
 	IOV_CLEARCOUNTS,
 	IOV_LOGDUMP,
 	IOV_LOGCAL,
 	IOV_LOGSTAMP,
 	IOV_GPIOOB,
 	IOV_IOCTLTIMEOUT,
-#if defined(DHD_DEBUG)
-	IOV_CONS,
-#endif 
-#ifdef PROP_TXSTATUS
-	IOV_PROPTXSTATUS_MODE,
-#endif
-#if defined(DONGLEOVERLAYS)
-	IOV_OVERLAYTAB,
-#endif
-	IOV_BUS_TYPE,
 	IOV_LAST
 };
 
@@ -144,27 +135,12 @@ const bcm_iovar_t dhd_iovars[] = {
 	{"clearcounts", IOV_CLEARCOUNTS, 0, IOVT_VOID,	0 },
 	{"gpioob",	IOV_GPIOOB,	0,	IOVT_UINT32,	0 },
 	{"ioctl_timeout",	IOV_IOCTLTIMEOUT,	0,	IOVT_UINT32,	0 },
-#ifdef PROP_TXSTATUS
-	/*
-	set the proptxtstatus operation mode:
-	0 - Do not do any proptxtstatus flow control
-	1 - Use implied credit from a packet status
-	2 - Use explicit credit
-	*/
-	{"ptxmode",	IOV_PROPTXSTATUS_MODE,	0,	IOVT_UINT32,	0 },
-#endif
-#if defined(DONGLEOVERLAYS)
-	{"overlaytab", IOV_OVERLAYTAB, 0,	IOVT_BUFFER,	0},
-#endif
-	{"bustype", IOV_BUS_TYPE, 0, IOVT_UINT32, 0},
 	{NULL, 0, 0, 0, 0 }
 };
 
-struct dhd_cmn *
-dhd_common_init(osl_t *osh)
+void
+dhd_common_init(void)
 {
-	dhd_cmn_t *cmn;
-
 	/* Init global variables at run-time, not as part of the declaration.
 	 * This is required to support init/de-init of the driver. Initialization
 	 * of globals as part of the declaration results in non-deterministic
@@ -172,72 +148,18 @@ dhd_common_init(osl_t *osh)
 	 * first time that the driver is initialized vs subsequent initializations.
 	 */
 	dhd_msg_level = DHD_ERROR_VAL;
-	/* Allocate private bus interface state */
-	if (!(cmn = MALLOC(osh, sizeof(dhd_cmn_t)))) {
-		DHD_ERROR(("%s: MALLOC failed\n", __FUNCTION__));
-		return NULL;
-	}
-	memset(cmn, 0, sizeof(dhd_cmn_t));
-	cmn->osh = osh;
-
-#if defined(DONGLEOVERLAYS)
-	sema_init(&cmn->sysioc_sem, 0);
-	init_completion(&cmn->sysioc_exited);
-	spin_lock_init(&cmn->lock);
-	pktq_init(&cmn->overlay_req, 1, 100);
-	cmn->sysioc_pid = kernel_thread(_overlay_req_sysioc_thread, cmn, 0);
-	if (cmn->sysioc_pid < 0) {
-		DHD_ERROR(("%s: unable to start _overlay_req_sysioc_thread\n",
-		           __FUNCTION__));
-	}
-#endif /* DONGLEOVERLAYS */
-
+//	dhd_msg_level = 0x091f; //sangjun.bae2012
+//	dhd_msg_level = 0xffff; //sangjun.bae2012
 #ifdef CONFIG_BCM4329_FW_PATH
 	strncpy(fw_path, CONFIG_BCM4329_FW_PATH, MOD_PARAM_PATHLEN-1);
 #else
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-09-03, don't init */
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
 	fw_path[0] = '\0';
-/* LGE_CHANGE_E [yoohoo@lge.com] 2009-09-03, don't init */
-#endif /* CONFIG_LGE_BCM432X_PATCH */
 #endif
 #ifdef CONFIG_BCM4329_NVRAM_PATH
 	strncpy(nv_path, CONFIG_BCM4329_NVRAM_PATH, MOD_PARAM_PATHLEN-1);
 #else
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-09-03, don't init */
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
 	nv_path[0] = '\0';
-/* LGE_CHANGE_E [yoohoo@lge.com] 2009-09-03, don't init */
-#endif /* CONFIG_LGE_BCM432X_PATCH */
 #endif
-
-	return cmn;
-}
-
-void
-dhd_common_deinit(dhd_pub_t *dhd_pub)
-{
-	osl_t *osh;
-	dhd_cmn_t *cmn = dhd_pub->cmn;
-
-	if (!cmn)
-		return;
-
-	osh = cmn->osh;
-#if defined(DONGLEOVERLAYS)
-	if (cmn->sysioc_pid >= 0) {
-		cmn->overlay_thread_terminate = 1;
-		KILL_PROC(cmn->sysioc_pid, SIGTERM);
-		wait_for_completion(&cmn->sysioc_exited);
-	}
-	if (cmn->overlaytab) {
-		MFREE(cmn->osh, cmn->overlaytab, cmn->overlaytabsz);
-		cmn->overlaytab = NULL;
-		cmn->overlaytabsz = 0;
-	}
-#endif /* DONGLEOVERLAYS */
-	dhd_pub->cmn = NULL;
-	MFREE(osh, cmn, sizeof(dhd_cmn_t));
 }
 
 static int
@@ -294,261 +216,15 @@ dhd_dump(dhd_pub_t *dhdp, char *buf, int buflen)
 	return (!strbuf->size ? BCME_BUFTOOSHORT : 0);
 }
 
-int
-dhd_wl_ioctl_cmd(dhd_pub_t *dhd_pub, int cmd, void *arg, int len, uint8 set, int ifindex)
-{
-	wl_ioctl_t ioc;
-
-	ioc.cmd = cmd;
-	ioc.buf = arg;
-	ioc.len = len;
-#ifdef DONGLEOVERLAYS
-	ioc.action = set ? WL_IOCTL_ACTION_SET : WL_IOCTL_ACTION_GET;
-#else
-	ioc.set = set;
-#endif
-
-	return dhd_wl_ioctl(dhd_pub, ifindex, &ioc, arg, len);
-}
-
-#if defined(DONGLEOVERLAYS)
-wl_ioctl_overlay_t *
-dhd_mkoverlay(dhd_pub_t *dhd_pub, uint8 *overlay, uint32 oidx, int offset, int osize, int *obuflen)
-{
-	wl_ioctl_overlay_t *op;
-
-	op = (wl_ioctl_overlay_t *) MALLOC(dhd_pub->osh, sizeof(wl_ioctl_overlay_t) + osize);
-	if (!op) {
-		DHD_ERROR(("%s: malloc failed for size %d\n", __FUNCTION__, offset + osize));
-		return NULL;
-	}
-
-	/* HTOL32 should byte swap for BIG ENDIAN host */
-	op->flags_idx = HTOL32(oidx);
-	op->offset = HTOL32(offset);
-	op->len = HTOL32(osize);
-	memcpy((uint8*)op + sizeof(wl_ioctl_overlay_t), overlay + offset, osize);
-	DHD_TRACE(("%s: overlay idx %d, offset %d, osize %d\n",
-	           __FUNCTION__, oidx, offset, osize));
-
-	*obuflen = sizeof(wl_ioctl_overlay_t) + osize;
-
-	return op;
-}
-
-static uint8 *
-dhd_find_overlay(dhd_pub_t *dhd_pub, uint32 cmd, char *buf, int32 *idx, int *osize,
-                 bool match_flags)
-{
-	dhd_cmn_t *cmn = dhd_pub->cmn;
-	uint32 *vals = (uint32 *)cmn->overlaytab;
-	uint32 header_sz = vals[0];
-	uint32 ocount = vals[1];
-	uint32 *offsets = &vals[2];
-	uint8 *obase = cmn->overlaytab + sizeof(uint32) + header_sz;
-	uint8 *overlay = obase;
-	int i = 0;
-	uint32 ocmd1, ocmd2, oidx;
-	bool match = FALSE;
-	uint32 index = (uint32) *idx;
-	bool firmware_req = ((int32)index != -1);
-	bool iovar;
-	char *name = NULL;
-
-	/*
-	 * cmn->overlaytab contains:
-	 *
-	 * uint32 header size
-	 * uint32 offset count
-	 * uint32 * (offset count) overlay offsets
-	 * uint32 region count
-	 * uint32 * (region count) overlay region addresses
-	 * variable length overlay code/data
-	 */
-
-	/* offsets (start, end) must account for at least one overlay */
-	ASSERT(ocount > 1);
-
-	if (firmware_req && !match_flags)
-		index &= OVERLAY_IDX_MASK;
-
-	/* check if it's an iovar */
-	if (cmd == WLC_SET_VAR || cmd == WLC_GET_VAR) {
-		iovar = TRUE;
-		/* some iovars have an xx: prefix. skip it */
-		if ((name = strchr(buf, ':')))
-			++name;
-		else
-			name = buf;
-		DHD_TRACE(("%s: got iovar %s %s\n", __FUNCTION__,
-		           cmd == WLC_SET_VAR ? "set" : "get",
-		           name));
-	} else
-		iovar = FALSE;
-
-	/* assumes cmn->overlaytab is 4-byte aligned */
-	while (i < (ocount - 1)) {
-		ocmd1 = ((uint32*)overlay)[0];
-		ocmd2 = ((uint32*)overlay)[1];
-		oidx = ((uint32*)overlay)[2];
-		if (!match_flags)
-			oidx &= OVERLAY_IDX_MASK;
-
-		DHD_TRACE(("%s: check cmd %d against %d and %d, offset %d\n", __FUNCTION__,
-		           cmd, ocmd1, ocmd2, offsets[i]));
-		if (cmd == ocmd1 || cmd == ocmd2) {
-			/* match the command name if it's an iovar */
-			if (iovar) {
-				char *cp = overlay + (sizeof(uint32) * 3);
-				while (*cp) {
-					DHD_TRACE(("%s: compare against %s\n", __FUNCTION__,
-					           cp));
-					if (!strcmp(name, cp)) {
-						DHD_TRACE(("%s: found iovar %s %s\n", __FUNCTION__,
-						           cmd == WLC_SET_VAR ? "set" : "get",
-						           cp));
-						match = TRUE;
-						break;
-					}
-					cp += strlen(cp) + 1;
-				}
-			} else {
-				DHD_TRACE(("%s: found ioctl %d\n", __FUNCTION__, cmd));
-				match = TRUE;
-			}
-			/* if index was specified, make sure it matches */
-			if (match) {
-				if (firmware_req && index != oidx)
-					match = FALSE;
-				else {
-					/* size = diff betw. offsets, minus table lookup overhead */
-					*osize = offsets[i + 1] - offsets[i];
-					*idx = ((uint32*)overlay)[2];
-					return overlay;
-				}
-			}
-		}
-		overlay = obase + offsets[++i];
-	}
-	if (firmware_req)
-		DHD_ERROR(("%s: fw req for idx 0x%x; name %s not found\n", __FUNCTION__,
-		           *idx, name ? name : "<NULL>"));
-
-	return NULL;
-}
-
-int
-dhd_wl_ioctl_overlay(dhd_pub_t *dhd_pub, int ifindex, wl_ioctl_t *ioc, void *buf, int len,
-                     int32 idx, bool *found)
-{
-	uint32 cmd = ioc->cmd;
-	uint8 *overlay;
-	int osize;
-	bool firmware_req = (idx != -1);
-	int ret = BCME_OK;
-
-	*found = FALSE;
-
-	overlay = dhd_find_overlay(dhd_pub, cmd, buf, &idx, &osize, FALSE);
-
-	if (overlay) {
-		*found = TRUE;
-
-		/* add overlay index and "overlay" bits to the action field */
-		ioc->action |= ((idx & OVERLAY_IDX_MASK) << WL_IOCTL_ACTION_OVL_SHIFT) |
-		    WL_IOCTL_ACTION_OVL;
-
-		/* just issue the IOCTL if DEFER_DL set and the request is not from the device */
-		/* (DEFER_DL means the device will request it later via WLC_E_OVL_DOWNLOAD) */
-		if ((idx & OVERLAY_FLAG_DEFER_DL) && !firmware_req) {
-			/* tell the firmware which overlay region to reserve */
-			ioc->action |= WL_IOCTL_ACTION_OVL_RSV;
-			DHD_TRACE(("%s: defer idx %x, action 0x%x\n", __FUNCTION__,
-			           idx, ioc->action));
-			goto sendreq;
-		}
-		if ((idx & OVERLAY_FLAG_PRESLEEP) && (firmware_req)) {
-			idx &= ~OVERLAY_FLAG_PRESLEEP;
-		}
-
-		if (idx & OVERLAY_FLAG_PRESLEEP) {
-			/* the IOCTL/iovar is sent first to flush the overlay region */
-			DHD_ERROR(("%s: PRESLEEP IOCTL issued for idx 0x%x\n",
-			           __FUNCTION__, idx));
-			/* include the overlay size after the "presleep" string */
-			memcpy((char *)buf + 9, &osize, sizeof(osize));
-			if ((ret = dhd_prot_ioctl(dhd_pub, ifindex, ioc, buf, len)) != BCME_OK)
-				return ret;
-		}
-
-		/* let the bus layer decide how best to download the overlay code/data */
-		ret = dhd_bus_overlay_dl(dhd_pub, ifindex, overlay, osize, idx,
-		                         dhd_pub->cmn->regions[idx & OVERLAY_IDX_MASK]);
-		if (ret != BCME_OK)
-			return ret;
-
-		if (idx & OVERLAY_FLAG_PRESLEEP) {
-			/* tell the device to start using the presleep overlay */
-			uint32 presleep_resident = 1;
-			/* gPresleepResident flag is uint32 immediately before region 0 */
-			return dhd_bus_membytes(dhd_pub, TRUE,
-			                        dhd_pub->cmn->regions[0] - sizeof(uint32),
-			                        (uint8 *)&presleep_resident, sizeof(uint32));
-		}
-
-sendreq:
-		/* now call the original ioctl */
-		ret = dhd_prot_ioctl(dhd_pub, ifindex, ioc, buf, len);
-
-		return ret;
-	}
-
-	return BCME_NOTFOUND;
-}
-#endif /* DONGLEOVERLAYS */
-
-int
-dhd_wl_ioctl(dhd_pub_t *dhd_pub, int ifindex, wl_ioctl_t *ioc, void *buf, int len)
-{
-	int ret;
-
-#if defined(DONGLEOVERLAYS)
-	if (!dhd_pub->cmn)
-		return BCME_ERROR;
-	/* need to serialize here since overlays involve an initial (over)write to overlay memory */
-	dhd_os_proto_block(dhd_pub);
-
-	if (dhd_pub->cmn->overlaytab) {
-		bool found;
-		ret = dhd_wl_ioctl_overlay(dhd_pub, ifindex, ioc, buf, len, -1, &found);
-		if (found)
-			goto done;
-	}
-#endif /* DONGLEOVERLAYS */
-
-	ret = dhd_prot_ioctl(dhd_pub, ifindex, ioc, buf, len);
-
-#if defined(DONGLEOVERLAYS)
-done:
-	dhd_os_proto_unblock(dhd_pub);
-#endif
-
-	return ret;
-}
-
 static int
 dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid, const char *name,
             void *params, int plen, void *arg, int len, int val_size)
 {
 	int bcmerror = 0;
 	int32 int_val = 0;
-#if defined(DONGLEOVERLAYS)
-	dhd_cmn_t *cmn = dhd_pub->cmn;
-#endif
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-	DHD_TRACE(("%s: actionid = %d\n", __FUNCTION__, actionid));
 	if ((bcmerror = bcm_iovar_lencheck(vi, arg, len, IOV_ISSET(actionid))) != 0)
 		goto exit;
 
@@ -623,22 +299,6 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid, const ch
 		dhd_pub->wd_dpc_sched = 0;
 		memset(&dhd_pub->dstats, 0, sizeof(dhd_pub->dstats));
 		dhd_bus_clearcounts(dhd_pub);
-#ifdef PROP_TXSTATUS
-		/* clear proptxstatus related counters */
-		{
-			wlfc_hanger_t* hanger;
-
-			memset(&((athost_wl_status_info_t*)(dhd_pub->wlfc_state))->stats, 0,
-				sizeof(athost_wl_stat_counters_t));
-			hanger = (wlfc_hanger_t*)((athost_wl_status_info_t*)
-				(dhd_pub->wlfc_state))->hanger;
-			hanger->pushed = 0;
-			hanger->popped = 0;
-			hanger->failed_slotfind = 0;
-			hanger->failed_to_pop = 0;
-			hanger->failed_to_push = 0;
-		}
-#endif /* PROP_TXSTATUS */
 		break;
 
 
@@ -657,98 +317,12 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid, const ch
 	}
 
 
-#ifdef PROP_TXSTATUS
-	case IOV_GVAL(IOV_PROPTXSTATUS_MODE):
-		int_val = (int32)((athost_wl_status_info_t*)dhd_pub->wlfc_state)->proptxstatus_mode;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_PROPTXSTATUS_MODE):
-		((athost_wl_status_info_t*)dhd_pub->wlfc_state)->proptxstatus_mode = int_val & 0xff;
-		break;
-#endif
-
-	case IOV_GVAL(IOV_BUS_TYPE):
-	/* The dhd application query the driver to check if its usb or sdio.  */
-#ifdef BCMDHDUSB
-		int_val = BUS_TYPE_USB;
-#endif
-		int_val = BUS_TYPE_SDIO;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-#if defined(DONGLEOVERLAYS)
-	case IOV_SVAL(IOV_OVERLAYTAB):
-	{
-		static uint32 offset;
-
-		/* first int in first chunk is the overall size */
-		if (cmn->overlaytab == NULL) {
-			ASSERT(plen > sizeof(int_val));
-			if (!(cmn->overlaytab =
-			      MALLOC(dhd_pub->osh, int_val - sizeof(uint32)))) {
-				bcmerror = BCME_NOMEM;
-				break;
-			}
-			DHD_TRACE(("%s: overlaytabsize %d\n", __FUNCTION__,
-			           int_val - (int)sizeof(uint32)));
-			/* table access code assumes malloc was 4-byte aligned */
-			ASSERT(ISALIGNED((uintptr)cmn->overlaytab, 4));
-			params = (void*) (uint8*)params + sizeof(uint32);
-			plen -= sizeof(uint32);
-			cmn->overlaytabsz = int_val - sizeof(uint32);
-			offset = 0;
-		}
-
-		bcopy((char *)params, cmn->overlaytab + offset, plen);
-		offset += plen;
-
-		/* got it all: now write overlay code/data that's marked POSTLOAD */
-		if (offset == cmn->overlaytabsz) {
-			uint32 idx, i;
-			uint32 *vals = (uint32 *)cmn->overlaytab;
-			uint32 ocount = vals[1];
-			uint32 rcount = vals[2 + ocount];
-			uint32 *region = &vals[3 + ocount];
-			uint8 *overlay;
-			int osize;
-
-			/* store away a pointer to the regions for easy access */
-			cmn->regions = region;
-
-			/* write the POSTLOAD code/data for each overlay region */
-			for (i = 0; i < rcount; ++i) {
-				idx = OVERLAY_FLAG_POSTLOAD | i;
-				overlay = dhd_find_overlay(dhd_pub, 0xfffffffe, NULL, &idx,
-				                           &osize, TRUE);
-				if (overlay) {
-					int ret = dhd_bus_membytes(dhd_pub, TRUE,
-					                           region[i], overlay,
-					                           osize);
-					if (ret) {
-						DHD_ERROR(("%s: dhd_bus_membytes failed for "
-						           "region %d w/status %d\n",
-						           __FUNCTION__, i, ret));
-						break;
-					} else {
-						DHD_TRACE(("%s: wrote POSTLOAD 0x%x; size %d "
-						           "to addr 0x%x\n",
-						           __FUNCTION__, idx, osize, region[i]));
-					}
-				}
-			}
-		}
-		break;
-	}
-#endif /* DONGLEOVERLAYS */
-
 	default:
 		bcmerror = BCME_UNSUPPORTED;
 		break;
 	}
 
 exit:
-	DHD_TRACE(("%s: actionid %d, bcmerror %d\n", __FUNCTION__, actionid, bcmerror));
 	return bcmerror;
 }
 
@@ -879,9 +453,7 @@ dhd_ioctl(dhd_pub_t *dhd_pub, dhd_ioctl_t *ioc, void *buf, uint buflen)
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-	if (!buf) {
-		return BCME_BADARG;
-	}
+	if (!buf) return BCME_BADARG;
 
 	switch (ioc->cmd) {
 	case DHD_GET_MAGIC:
@@ -1012,17 +584,11 @@ wl_show_host_event(wl_event_msg_t *event, void *event_data)
 		{WLC_E_UNICAST_DECODE_ERROR, "UNICAST_DECODE_ERROR"},
 		{WLC_E_MULTICAST_DECODE_ERROR, "MULTICAST_DECODE_ERROR"},
 		{WLC_E_TRACE, "TRACE"},
-#ifdef PROP_TXSTATUS
-		{WLC_E_FIFO_CREDIT_MAP, "FIFO CREDIT MAP"},
-#endif
 		{WLC_E_ACTION_FRAME, "ACTION FRAME"},
 		{WLC_E_ACTION_FRAME_COMPLETE, "ACTION FRAME TX COMPLETE"},
 		{WLC_E_IF, "IF"},
 		{WLC_E_RSSI, "RSSI"},
-		{WLC_E_PFN_SCAN_COMPLETE, "PFN_SCAN_COMPLETE"},
-#if defined(DONGLEOVERLAYS)
-		{WLC_E_OVERLAY_REQ, "OVERLAY_REQ"}
-#endif
+		{WLC_E_PFN_SCAN_COMPLETE, "SCAN_COMPLETE"}
 	};
 	uint event_type, flags, auth_type, datalen;
 	event_type = ntoh32(event->event_type);
@@ -1239,29 +805,25 @@ wl_show_host_event(wl_event_msg_t *event, void *event_data)
 
 	/* show any appended data */
 	if (datalen) {
-		prhex("MACEVENT: Appended data", event_data, datalen);
+		buf = (uchar *) event_data;
+		DHD_EVENT((" data (%d) : ", datalen));
+		for (i = 0; i < datalen; i++)
+			DHD_EVENT((" 0x%02x ", *buf++));
+		DHD_EVENT(("\n"));
 	}
 }
 #endif /* SHOW_EVENTS */
 
-#if defined(WLP2P)
-extern int dhd_use_p2p;
-#define P2P_INTERFACE_NAME "p2p"
-#endif /* defined(WLP2P) */
-
 int
-wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
+wl_host_event(struct dhd_info *dhd, int *ifidx, void *pktdata,
               wl_event_msg_t *event, void **data_ptr)
 {
 	/* check whether packet is a BRCM event pkt */
 	bcm_event_t *pvt_data = (bcm_event_t *)pktdata;
 	char *event_data;
-	uint32 type, status, reason, datalen;
+	uint32 type, status;
 	uint16 flags;
 	int evlen;
-#if defined(DONGLEOVERLAYS)
-	dhd_cmn_t *cmn = dhd_pub->cmn;
-#endif
 
 	if (bcmp(BRCM_OUI, &pvt_data->bcm_hdr.oui[0], DOT11_OUI_LEN)) {
 		DHD_ERROR(("%s: mismatched OUI, bailing\n", __FUNCTION__));
@@ -1283,149 +845,39 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 	type = ntoh32_ua((void *)&event->event_type);
 	flags = ntoh16_ua((void *)&event->flags);
 	status = ntoh32_ua((void *)&event->status);
-	reason = ntoh32_ua((void *)&event->reason);
-	datalen = ntoh32_ua((void *)&event->datalen);
-	evlen = datalen + sizeof(bcm_event_t);
+	evlen = ntoh32_ua((void *)&event->datalen) + sizeof(bcm_event_t);
 
 	switch (type) {
-#ifdef PROP_TXSTATUS
-		case WLC_E_FIFO_CREDIT_MAP:
-			dhd_wlfc_FIFOcreditmap_event(dhd_pub->info, event_data);
-			WLFC_DBGMESG(("WLC_E_FIFO_CREDIT_MAP:(AC0,AC1,AC2,AC3),(BC_MC),(OTHER): "
-				"(%d,%d,%d,%d),(%d),(%d)\n", event_data[0], event_data[1],
-				event_data[2],
-				event_data[3], event_data[4], event_data[5]));
-			break;
-#endif
-
 		case WLC_E_IF:
 			{
 				dhd_if_event_t *ifevent = (dhd_if_event_t *)event_data;
 				DHD_TRACE(("%s: if event\n", __FUNCTION__));
-#if defined(WLP2P)
-             if (dhd_use_p2p) {
-                if (strncmp(pvt_data->event.ifname,"wl",2) == 0) {
-                     memmove(&(pvt_data->event.ifname[1]),&(pvt_data->event.ifname[0]),6);
-                     memcpy(pvt_data->event.ifname,P2P_INTERFACE_NAME,strlen(P2P_INTERFACE_NAME));
-					 memcpy(event, &pvt_data->event, sizeof(wl_event_msg_t));
-                }
-             }
-#endif
 
-#ifdef PROP_TXSTATUS
-{
-				uint8* ea = pvt_data->eth.ether_dhost;
-				WLFC_DBGMESG(("WLC_E_IF: idx:%d, action:%s, iftype:%s, "
-					"[%02x:%02x:%02x:%02x:%02x:%02x]\n",
-					ifevent->ifidx,
-					((ifevent->action == WLC_E_IF_ADD) ? "ADD":"DEL"),
-					((ifevent->is_AP == 0) ? "STA":"AP "),
-					ea[0], ea[1], ea[2], ea[3], ea[4], ea[5]));
-				(void)ea;
-
-				dhd_wlfc_interface_event(dhd_pub->info,
-					((ifevent->action == WLC_E_IF_ADD) ?
-					eWLFC_MAC_ENTRY_ACTION_ADD : eWLFC_MAC_ENTRY_ACTION_DEL),
-					ifevent->ifidx, ifevent->is_AP, ea);
-
-				/* dhd already has created an interface by deafult, for 0 */
-				if (ifevent->ifidx == 0)
-					break;
-}
-#endif /* PROP_TXSTATUS */
-				if (ifevent->ifidx > 0 && ifevent->ifidx < DHD_MAX_IFS) {
+				if (ifevent->ifidx > 0 && ifevent->ifidx < DHD_MAX_IFS)
+				{
 					if (ifevent->action == WLC_E_IF_ADD)
-						dhd_add_if(dhd_pub->info, ifevent->ifidx,
-							NULL, event->ifname, event->addr.octet,
+						dhd_add_if(dhd, ifevent->ifidx,
+							NULL, event->ifname,
+							pvt_data->eth.ether_dhost,
 							ifevent->flags, ifevent->bssidx);
 					else
-						dhd_del_if(dhd_pub->info, ifevent->ifidx);
+						dhd_del_if(dhd, ifevent->ifidx);
 				} else {
-#ifndef PROP_TXSTATUS
 					DHD_ERROR(("%s: Invalid ifidx %d for %s\n",
 						__FUNCTION__, ifevent->ifidx, event->ifname));
-#endif
 				}
 			}
 			/* send up the if event: btamp user needs it */
-			*ifidx = dhd_ifname2idx(dhd_pub->info, event->ifname);
+			*ifidx = dhd_ifname2idx(dhd, event->ifname);
 			/* push up to external supp/auth */
-			dhd_event(dhd_pub->info, (char *)pvt_data, evlen, *ifidx);
+			dhd_event(dhd, (char *)pvt_data, evlen, *ifidx);
 			break;
 
-#if defined(DONGLEOVERLAYS)
-		case WLC_E_OVERLAY_REQ:
-		{
-			int datalen = ntoh32(event->datalen);
-			void *p = NULL;
-
-			switch (reason) {
-			case WLC_E_OVL_DOWNLOAD:
-				if (!pktq_full(&cmn->overlay_req)) {
-					/* packetize the data to place it on a work queue */
-					p = PKTGET(dhd_pub->osh, sizeof(wl_event_msg_t) + datalen,
-					           TRUE);
-				} else {
-					DHD_ERROR(("WLC_E_OVERLAY_REQ: pkt queue full!\n"));
-					break;
-				}
-
-				if (!p)
-					DHD_ERROR(("WLC_E_OVERLAY_REQ: pkt malloc failure\n"));
-				else {
-					unsigned long flags;
-					char *cp = (char *)PKTDATA(dhd_pub->osh, p);
-					memcpy(cp, &pvt_data->event, sizeof(wl_event_msg_t));
-					memcpy(cp + sizeof(wl_event_msg_t), event_data, datalen);
-
-					spin_lock_irqsave(&cmn->lock, flags);
-					pktenq(&cmn->overlay_req, p);
-					spin_unlock_irqrestore(&cmn->lock, flags);
-
-					/* signal the thread to do the work */
-					up(&cmn->sysioc_sem);
-				}
-				break;
-			case WLC_E_OVL_UPDATE_IND:
-				{
-					uint32 offset = ntoh32_ua((void *)event_data);
-					uint32 cmd = ntoh32_ua((void *)(event_data +
-					                                sizeof(uint32)));
-					uint32 idx = ntoh32_ua((void *)(event_data +
-					                                sizeof(uint32) * 2));
-					char *buf = (char *)(event_data +
-					                     sizeof(uint32) * 3);
-					uint8 *overlay;
-					int osize;
-
-					overlay = dhd_find_overlay(dhd_pub, cmd, buf, &idx,
-					                           &osize, FALSE);
-					if (overlay) {
-						if (cmd == WLC_SET_VAR || cmd == WLC_GET_VAR)
-							buf += strlen(buf) + 1;
-						datalen -= (uint32)(buf - event_data);
-						memcpy(overlay + offset, buf, datalen);
-					} else {
-						DHD_ERROR(("OVL_UPDATE_IND: overlay not found\n"));
-					}
-				}
-				break;
-			default:
-				DHD_ERROR(("OVERLAY_REQ: reason code %d not found\n",
-				           reason));
-				break;
-			}
-			break;
-		}
-#endif /* DONGLEOVERLAYS */
 
+#ifdef P2P
 		case WLC_E_NDIS_LINK:
-		{
-			uint32 temp = hton32(WLC_E_LINK);
-
-			memcpy((void *)(&pvt_data->event.event_type), &temp,
-				sizeof(pvt_data->event.event_type));
-		}
+			break;
+#endif
 		/* fall through */
 		/* These are what external supplicant/authenticator wants */
 		case WLC_E_LINK:
@@ -1436,9 +888,9 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 		default:
 		/* Fall through: this should get _everything_  */
 
-			*ifidx = dhd_ifname2idx(dhd_pub->info, event->ifname);
+			*ifidx = dhd_ifname2idx(dhd, event->ifname);
 			/* push up to external supp/auth */
-			dhd_event(dhd_pub->info, (char *)pvt_data, evlen, *ifidx);
+			dhd_event(dhd, (char *)pvt_data, evlen, *ifidx);
 			DHD_TRACE(("%s: MAC event %d, flags %x, status %x\n",
 			           __FUNCTION__, type, flags, status));
 
@@ -1527,8 +979,6 @@ wl_pattern_atoh(char *src, char *dst)
 	return i;
 }
 
-extern int dhd_preinit_ioctls(dhd_pub_t *dhd);
-
 void
 dhd_pktfilter_offload_enable(dhd_pub_t * dhd, char *arg, int enable, int master_mode)
 {
@@ -1578,7 +1028,7 @@ dhd_pktfilter_offload_enable(dhd_pub_t * dhd, char *arg, int enable, int master_
 	       sizeof(enable_parm));
 
 	/* Enable/disable the specified filter. */
-	rc = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, buf, buf_len, TRUE, 0);
+	rc = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, buf, buf_len);
 	rc = rc >= 0 ? 0 : rc;
 	if (rc)
 		DHD_TRACE(("%s: failed to add pktfilter %s, retcode = %d\n",
@@ -1589,7 +1039,7 @@ dhd_pktfilter_offload_enable(dhd_pub_t * dhd, char *arg, int enable, int master_
 
 	/* Contorl the master mode */
 	bcm_mkiovar("pkt_filter_mode", (char *)&master_mode, 4, buf, sizeof(buf));
-	rc = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, buf, sizeof(buf), TRUE, 0);
+	rc = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, buf, sizeof(buf));
 	rc = rc >= 0 ? 0 : rc;
 	if (rc)
 		DHD_TRACE(("%s: failed to add pktfilter %s, retcode = %d\n",
@@ -1716,7 +1166,7 @@ dhd_pktfilter_offload_set(dhd_pub_t * dhd, char *arg)
 	       &pkt_filter,
 	       WL_PKT_FILTER_FIXED_LEN + WL_PKT_FILTER_PATTERN_FIXED_LEN);
 
-	rc = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, buf, buf_len, TRUE, 0);
+	rc = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, buf, buf_len);
 	rc = rc >= 0 ? 0 : rc;
 
 	if (rc)
@@ -1741,7 +1191,7 @@ dhd_arp_offload_set(dhd_pub_t * dhd, int arp_mode)
 	int retcode;
 
 	bcm_mkiovar("arp_ol", (char *)&arp_mode, 4, iovbuf, sizeof(iovbuf));
-	retcode = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
+	retcode = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
 	retcode = retcode >= 0 ? 0 : retcode;
 	if (retcode)
 		DHD_TRACE(("%s: failed to set ARP offload mode to 0x%x, retcode = %d\n",
@@ -1758,7 +1208,7 @@ dhd_arp_offload_enable(dhd_pub_t * dhd, int arp_enable)
 	int retcode;
 
 	bcm_mkiovar("arpoe", (char *)&arp_enable, 4, iovbuf, sizeof(iovbuf));
-	retcode = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
+	retcode = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
 	retcode = retcode >= 0 ? 0 : retcode;
 	if (retcode)
 		DHD_TRACE(("%s: failed to enabe ARP offload to %d, retcode = %d\n",
@@ -1768,174 +1218,707 @@ dhd_arp_offload_enable(dhd_pub_t * dhd, int arp_enable)
 		__FUNCTION__, arp_enable));
 }
 
-/* send up locally generated event */
-void
-dhd_sendup_event_common(dhd_pub_t *dhdp, wl_event_msg_t *event, void *data)
-{
-	switch (ntoh32(event->event_type)) {
-
-	default:
-		break;
-	}
+/* LGE_CHANGE_S [yoohoo@lge.com] 2009-04-03, configs */
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+#include <linux/fs.h>
+#include <linux/ctype.h>
+
+#if 0
+
+CONFIG FILE FORMAT
+==================
+
+AVAILABLE PARAMETERS
+~~~~~~~~~~~~~~~~~~~~
++====================+=========================================================+
+| VARIABLE NAME      | DESCRIPTION                                             |
++====================+=========================================================+
+| btc_mode           | BTCoexist                                               |
+|                    | 0: disable, 1: enable                                   |
++--------------------+---------------------------------------------------------+
+| country            | Country Code                                            |
+|                    | KR, EU, US or AU ...                                    |
++--------------------+---------------------------------------------------------+
+| vlan_mode          | Specifies the use of 802.1Q Tags (ON, OFF, AUTO).       |
+|                    | 0: off, 1: on, -1: auto                                 |
++--------------------+---------------------------------------------------------+
+| mpc                | Minimum Power Consumption                               |
+|                    | 0: disable, 1: enable                                   |
++--------------------+---------------------------------------------------------+
+| wme                | WME QoS                                                 |
+|                    | 0: disable, 1: enable                                   |
++--------------------+---------------------------------------------------------+
+| wme_apsd           | WME APSD (Advanced Power Save Delivery)                 |
+|                    | 0: disable, 1: enable                                   |
++--------------------+---------------------------------------------------------+
+| wme_qosinfo        | Set APSD parameters on STA.                             |
+|                    | - max_sp_len = number of frames per USP: 0 (all), 2, 4, |
+|                    |   or 6                                                  |
+|                    | - be, bk, vi, and vo = 0 to disable, 1 to enable U-APSD |
+|                    |   per AC                                                |
+|                    |        <max_sp_len> <be> <bk> <vi> <vo>                 |
+|                    | 0x0f =      0         1    1    1    1                  |
+|                    | 0x2f =      2         1    1    1    1                  |
+|                    | 0x4f =      4         1    1    1    1                  |
+|                    | 0x6f =      6         1    1    1    1                  |
+|                    | 0x03 =      0         0    0    1    1                  |
++--------------------+---------------------------------------------------------+
+| wme_auto_trigger   | 0: disable, 1: enable                                   |
++--------------------+---------------------------------------------------------+
+| wme_apsd_trigger   | in msec, 0: disable                                     |
++--------------------+---------------------------------------------------------+
+| roam_off           | 0: roaming on, 1: roaming off                           |
++--------------------+---------------------------------------------------------+
+| roam_scan_period   | in sec                                                  |
++--------------------+---------------------------------------------------------+
+| roam_delta         | in dB                                                   |
++--------------------+---------------------------------------------------------+
+| roam_trigger       | in dBm                                                  |
++--------------------+---------------------------------------------------------+
+| PM                 | Power Saving Mode                                       |
+|                    | 0: off, 1: max, 2: fast                                 |
++--------------------+---------------------------------------------------------+
+| assoc_listen       | The Listen Interval sent in association requests        |
+|                    | number of beacon                                        |
++--------------------+---------------------------------------------------------+
+
+EXAMPLE
+~~~~~~~
+btc_mode=1
+country=AU
+vlan_mode=0
+mpc=1
+wme=1
+wme_apsd=0
+wme_qosinfo=0x00
+wme_auto_trigger=1
+wme_apsd_trigger=0
+roam_off=0
+roam_scan_period=10
+roam_delta=20
+roam_trigger=-70
+PM=2
+assoc_listen=1
 
-	/* Call per-port handler. */
-	dhd_sendup_event(dhdp, event, data);
-}
+#endif
 
-#if defined(DONGLEOVERLAYS)
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
-#define DAEMONIZE(a) daemonize(a); \
-	allow_signal(SIGKILL); \
-	allow_signal(SIGTERM);
-#else /* Linux 2.4 (w/o preemption patch) */
-#define RAISE_RX_SOFTIRQ() \
-	cpu_raise_softirq(smp_processor_id(), NET_RX_SOFTIRQ)
-#define DAEMONIZE(a) daemonize(); \
-	do { if (a) \
-		strncpy(current->comm, a, MIN(sizeof(current->comm), (strlen(a) + 1))); \
-	} while (0);
-#endif /* LINUX_VERSION_CODE  */
-
-static void *
-pktdeq_safe(dhd_cmn_t *cmn)
+static int dhd_preinit_proc(dhd_pub_t *dhd, int ifidx, char *name, char *value)
 {
-	void *p;
-	unsigned long flags;
+	int var_int;
+
+	if (!strcmp(name, "country")) {
+		return dhdcdc_set_ioctl(dhd, ifidx, WLC_SET_COUNTRY,
+				value, WLC_CNTRY_BUF_SZ);
+	} else if (!strcmp(name, "roam_scan_period")) {
+		var_int = (int)simple_strtol(value, NULL, 0);
+		return dhdcdc_set_ioctl(dhd, ifidx, WLC_SET_ROAM_SCAN_PERIOD,
+				&var_int, sizeof(var_int));
+	} else if (!strcmp(name, "roam_delta") || !strcmp(name, "roam_trigger")) {
+		struct {
+			int val;
+			int band;
+		} x;
+		x.val = (int)simple_strtol(value, NULL, 0);
+		x.band = WLC_BAND_AUTO;
+		return dhdcdc_set_ioctl(dhd, ifidx, strcmp(name, "roam_delta") ?
+				WLC_SET_ROAM_TRIGGER : WLC_SET_ROAM_DELTA, &x, sizeof(x));
+	} else if (!strcmp(name, "PM")) {
+		var_int = (int)simple_strtol(value, NULL, 0);
+		return dhdcdc_set_ioctl(dhd, ifidx, WLC_SET_PM,
+				&var_int, sizeof(var_int));
+/* LGE_CHANGE_S, [jisung.yang@lge.com], 2010-06-28, < MAC write > */
+	} else if(!strcmp(name,"cur_etheraddr")){
+        struct ether_addr ea;
+        char buf[32];
+        uint iovlen;
+        int ret;
+
+		DHD_ERROR(("%s: cur_etheraddr", __FUNCTION__));
+
+        bcm_ether_atoe(value, &ea);
+//htclk fail patch
+/*        ret = memcmp( &ea.octet, dhd->mac.octet, ETHER_ADDR_LEN);
+
+        if(ret == 0){
+                DHD_ERROR(("%s: Same Macaddr\n",__FUNCTION__));
+                return 0;
+        }
+
+        DHD_ERROR(("%s: Change Macaddr = %02X:%02X:%02X:%02X:%02X:%02X\n",__FUNCTION__,
+                ea.octet[0], ea.octet[1], ea.octet[2],
+                ea.octet[3], ea.octet[4], ea.octet[5]));
+*/
+		printk("%s: Change Macaddr = %02X:%02X:%02X:%02X:%02X:%02X\n",__FUNCTION__,
+            	ea.octet[0], ea.octet[1], ea.octet[2],
+                ea.octet[3], ea.octet[4], ea.octet[5]);
+
+        iovlen = bcm_mkiovar("cur_etheraddr", (char*)&ea, ETHER_ADDR_LEN, buf, 32);
+
+        ret = dhdcdc_set_ioctl(dhd, ifidx, WLC_SET_VAR, buf, iovlen);
+        if (ret < 0) {
+            DHD_ERROR(("%s: can't set MAC address , error=%d\n", __FUNCTION__, ret));
+            return ret;
+        }
+        else{
+            memcpy(dhd->mac.octet, (void *)&ea, ETHER_ADDR_LEN);
+            return ret;
+        }
+/* LGE_CHANGE_E, [jisung.yang@lge.com], 2010-06-28, < MAC write > */		
+	} else {
+		uint iovlen;
+		char iovbuf[WLC_IOCTL_SMLEN];
+
+		/* wlu_iovar_setint */
+		var_int = (int)simple_strtol(value, NULL, 0);
+
+		/* Setup timeout bcn_timeout from dhd driver 4.217.48 */
+		if(!strcmp(name, "roam_off")) {
+			/* Setup timeout if Beacons are lost to report link down */
+			if (var_int) {
+				uint bcn_timeout = 2;
+				bcm_mkiovar("bcn_timeout", (char *)&bcn_timeout, 4, iovbuf, sizeof(iovbuf));
+				dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+			}
+		}
+		/* Setup timeout bcm_timeout from dhd driver 4.217.48 */
 
-	spin_lock_irqsave(&cmn->lock, flags);
-	p = pktdeq(&cmn->overlay_req);
-	spin_unlock_irqrestore(&cmn->lock, flags);
+		iovlen = bcm_mkiovar(name, (char *)&var_int, sizeof(var_int),
+				iovbuf, sizeof(iovbuf));
+		return dhdcdc_set_ioctl(dhd, ifidx, WLC_SET_VAR,
+				iovbuf, iovlen);
+	}
 
-	return p;
+	return 0;
 }
 
-static int
-_overlay_req_sysioc_thread(void *data)
+static int dhd_preinit_config(dhd_pub_t *dhd, int ifidx)
 {
-	dhd_cmn_t *cmn = (dhd_cmn_t *)data;
-	wl_ioctl_t ioc;
-	bool found;
-	uint32 idx;
-	char *buf;
-	wl_event_msg_t event;
-	char *event_data;
-	int datalen, ret = BCME_OK;
-	void *p;
-	char *cp;
+	mm_segment_t old_fs;
+	struct kstat stat;
+	struct file *fp = NULL;
+	unsigned int len;
+	char *buf = NULL, *p, *name, *value;
+	int ret = 0;
+
+	if (!*config_path)
+		return 0;
+
+	old_fs = get_fs();
+	set_fs(get_ds());
+	if ((ret = vfs_stat(config_path, &stat))) {
+		set_fs(old_fs);
+		printk(KERN_ERR "%s: Failed to get information (%d)\n",
+				config_path, ret);
+		return ret;
+		}
+	set_fs(old_fs);
+
+	if (!(buf = MALLOC(dhd->osh, stat.size + 1))) {
+		printk(KERN_ERR "Failed to allocate memory %llu bytes\n", stat.size);
+		return -ENOMEM;
+	}
 
-	DAEMONIZE("overlay_req_sysioc");
+	if (!(fp = dhd_os_open_image(config_path)) ||
+		(len = dhd_os_get_image_block(buf, stat.size, fp)) < 0)
+		goto err;
 
-	while (down_interruptible(&cmn->sysioc_sem) == 0) {
-		/* signals can accumulate (one goes with each packet) */
-		if (pktq_empty(&cmn->overlay_req) || cmn->overlay_thread_terminate)
+	buf[stat.size] = '\0';
+	for (p = buf; *p; p++) {
+		if (isspace(*p))
 			continue;
-
-		while ((p = pktdeq_safe(cmn))) {
-			cp = (char *)PKTDATA(cmn->osh, p);
-
-			event_data = cp + sizeof(wl_event_msg_t);
-
-			/* memcpy since BRCM event pkt may be unaligned. */
-			memcpy(&event, cp, sizeof(wl_event_msg_t));
-
-			ioc.cmd = ntoh32_ua((void*)event_data);
-			idx = ntoh32_ua(((void*)(event_data + sizeof(uint32))));
-			buf = event_data + (sizeof(uint32) * 2);
-			ioc.buf = buf;
-			datalen = ntoh32(event.datalen);
-			ioc.len = datalen - (sizeof(uint32) * 2);
-			ioc.action = WL_IOCTL_ACTION_SET;
-
-			DHD_TRACE(("%s: WLC_E_OVERLAY_REQ cmd %d, idx %d: %s\n",
-			           __FUNCTION__, ioc.cmd, idx,
-			           bcm_isalnum(*buf) ? buf : ""));
-
-			ASSERT(cmn->dhd);
-			/* serialize here since overlays entail an initial overlay memory write */
-			dhd_os_proto_block(cmn->dhd);
-			ret = dhd_wl_ioctl_overlay(cmn->dhd, 0, &ioc, buf, ioc.len, idx, &found);
-			dhd_os_proto_unblock(cmn->dhd);
-			DHD_ERROR(("%s: WLC_E_OVERLAY_REQ cmd %d, idx %d: %s done\n",
-			           __FUNCTION__, ioc.cmd, idx,
-			           bcm_isalnum(*buf) ? buf : ""));
-			if (ret) {
-				DHD_ERROR(("%s: OVERLAY_REQ failed with status %d; ioctl %d %s\n",
-				           __FUNCTION__, ret, ioc.cmd,
-				           bcm_isalnum(*buf) ? buf : ""));
+		for (name = p++; *p && !isspace(*p); p++) {
+			if (*p == '=') {
+				*p = '\0';
+				p++;
+				for (value = p; *p && !isspace(*p); p++);
+				*p = '\0';
+				if ((ret = dhd_preinit_proc(dhd, ifidx, name, value)) < 0)
+					printk(KERN_ERR "%s: %s=%s\n",
+							bcmerrorstr(ret), name, value);
+				break;
 			}
-			PKTFREE(cmn->osh, p, TRUE);
 		}
 	}
+	ret = 0;
 
-	/* clean up */
-	while ((p = pktdeq_safe(cmn)))
-		PKTFREE(cmn->osh, p, TRUE);
+out:
+	if (fp)
+		dhd_os_close_image(fp);
+	if (buf)
+		MFREE(dhd->osh, buf, stat.size+1);
+	return ret;
 
-	complete_and_exit(&cmn->sysioc_exited, 0);
-	DHD_TRACE(("%s: complete_and_exit\n", __FUNCTION__));
-	return 0;
+err:
+	ret = -1;
+	goto out;
 }
-#endif /* DONGLEOVERLAYS */
+#endif /* CONFIG_LGE_BCM432X_PATCH */
+/* LGE_CHANGE_E [yoohoo@lge.com] 2009-04-03, configs */
 
+/* LGE_CHANGE_S [bill.park@lge.com] 2010-12-10, mac write */
+#ifdef GET_CUSTOM_MAC_ENABLE
+static uint32 dhd_util_hex2num(uchar c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if (c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return -1;
+}
 
-#ifdef SIMPLE_ISCAN
+static int dhd_util_ascii_to_hex(char* keystr, uint32 keystrlen, char* dst)
+{
+	#define TEMP_BUF_LEN 10
+	char temp_buf[TEMP_BUF_LEN] = {0,};
+	uint32 hex_len = keystrlen;
+	uint32 i1 = 0, i2 = 0, num1, num2;
 
-uint iscan_thread_id;
-iscan_buf_t * iscan_chain = 0;
+	if (!keystr) {
+		return -1;
+	}
 
-iscan_buf_t *
-dhd_iscan_allocate_buf(dhd_pub_t *dhd, iscan_buf_t **iscanbuf)
-{
-	iscan_buf_t *iscanbuf_alloc = 0;
-	iscan_buf_t *iscanbuf_head;
+	if (hex_len > (TEMP_BUF_LEN*2)) {
+		printk(KERN_INFO "keystrlen is too long %u\n", keystrlen);
+		return -1;
+	}
 
-	DHD_TRACE(("%s: Entered\n", __FUNCTION__));
-	dhd_iscan_lock();
+	while (hex_len)
+	{
+		num1 = dhd_util_hex2num(keystr[i1++]);
+		num2 = dhd_util_hex2num(keystr[i1++]);
+		if (num1 < 0 || num2 < 0)
+		{
+			// error
+			return -1;
+		}
+		num1 <<= 4;
+		temp_buf[i2++] = num1 | num2;
+		hex_len -= 2;
+	}
 
-	iscanbuf_alloc = (iscan_buf_t*)MALLOC(dhd->osh, sizeof(iscan_buf_t));
-	if (iscanbuf_alloc == NULL)
-		goto fail;
+	bcopy(temp_buf, dst, keystrlen/2);
+	return keystrlen/2;
+}
 
-	iscanbuf_alloc->next = NULL;
-	iscanbuf_head = *iscanbuf;
+/* plz refer to this journal. http://www.linuxjournal.com/node/8110/print */
+static int dhd_custom_read_nvdata(
+	dhd_pub_t *dhd,
+	char *filename,
+	char *nvreadbuf,
+	uint nmemb
+)
+{
+	mm_segment_t old_fs;
+	struct kstat stat;
+	struct file *fp = NULL;
+	unsigned int len;
+	char *buf = NULL;
+	int ret = 0;
+
+	if (!dhd || !filename || !nvreadbuf) {
+		return (ret = -1);
+	}
 
-	DHD_ISCAN(("%s: addr of allocated node = 0x%X"
-		   "addr of iscanbuf_head = 0x%X dhd = 0x%X\n",
-		   __FUNCTION__, iscanbuf_alloc, iscanbuf_head, dhd));
+	old_fs = get_fs();
+	set_fs(get_ds());
+	if ((ret = vfs_stat(filename, &stat))) {
+		set_fs(old_fs);
+		printk(KERN_ERR "%s: Failed to get information (%d)\n",
+				filename, ret);
+		return ret;
+	}
+	set_fs(old_fs);
 
-	if (iscanbuf_head == NULL) {
-		*iscanbuf = iscanbuf_alloc;
-		DHD_ISCAN(("%s: Head is allocated\n", __FUNCTION__));
-		goto fail;
+	if (!(buf = MALLOC(dhd->osh, nmemb/*stat.size*/ + 1))) {
+		printk(KERN_ERR "Failed to allocate memory nmemb : %u, stat.size : %llu bytes\n", nmemb, stat.size);
+		return (ret = -ENOMEM);
 	}
 
-	while (iscanbuf_head->next)
-		iscanbuf_head = iscanbuf_head->next;
+	if (!(fp = dhd_os_open_image(filename)) ||
+		(len = dhd_os_get_image_block(buf, nmemb/*stat.size*/, fp)) < 0) {
+		printk(KERN_ERR "Failed to read file");
+		ret = -1;
+		goto out;
+	}
 
-	iscanbuf_head->next = iscanbuf_alloc;
+	buf[nmemb/*stat.size*/] = '\0';
+	bcopy(buf, nvreadbuf, nmemb+1);
 
-fail:
-	dhd_iscan_unlock();
-	return iscanbuf_alloc;
+out:
+	if (fp)
+		dhd_os_close_image(fp);
+	if (buf)
+		MFREE(dhd->osh, buf, nmemb/*stat.size*/+1);
+	return ret;
 }
 
-void
-dhd_iscan_free_buf(void *dhdp, iscan_buf_t *iscan_delete)
+
+static bool dhd_check_nvmac_is_valid(char* nvmac)
 {
-	iscan_buf_t *iscanbuf_free = 0;
-	iscan_buf_t *iscanbuf_prv = 0;
-	iscan_buf_t *iscanbuf_cur;
-	dhd_pub_t *dhd = dhd_bus_pub(dhdp);
-	DHD_TRACE(("%s: Entered\n", __FUNCTION__));
+	bool ret = TRUE;
+	const char init_val[3][ETHER_ADDR_LEN] = {
+		{0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
+		{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
+		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	};
 
-	dhd_iscan_lock();
+	if (!nvmac
+		|| !bcmp(nvmac, init_val[0], ETHER_ADDR_LEN)
+		|| !bcmp(nvmac, init_val[1], ETHER_ADDR_LEN)
+		|| !bcmp(nvmac, init_val[2], ETHER_ADDR_LEN)) {
+		ret = FALSE;
+	}
+	return ret;
+}
 
-	iscanbuf_cur = iscan_chain;
+static int dhd_get_curr_etheraddr(dhd_pub_t *dhd, char* macaddr)
+{
+	int ret = 0;
+	char buf[128]= {0,};
 
-	/* If iscan_delete is null then delete the entire 
-	 * chain or else delete specific one provided
-	 */
-	if (!iscan_delete) {
+	if (!dhd || !macaddr)
+		ret = -1;
+
+	if (!ret)	{
+		strcpy(buf, "cur_etheraddr");
+		ret = dhdcdc_query_ioctl(dhd, 0, WLC_GET_VAR, buf, sizeof(buf));
+		if (ret < 0) {
+			DHD_ERROR(("dhdcdc_query_ioctl: dhd_get_curr_etheraddr failed w/status %d\n", ret));
+		}
+		else {
+			bcopy(buf, macaddr, ETHER_ADDR_LEN);
+			ret = 0;
+		}
+	}
+
+	return ret;
+}
+
+#endif // GET_CUSTOM_MAC_ENABLE
+
+/* LGE_CHANGE_E [bill.park@lge.com] 2010-12-10, mac write */
+
+int
+dhd_preinit_ioctls(dhd_pub_t *dhd)
+{
+	char iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" + '\0' + bitvec  */
+	uint up = 0;
+	char buf[128], *ptr;
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+	uint power_mode = PM_FAST;
+#endif /* CONFIG_LGE_BCM432X_PATCH */
+	uint32 dongle_align = DHD_SDALIGN;
+	uint32 glom = 0;
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+	uint bcn_timeout = 4;
+#endif /* CONFIG_LGE_BCM432X_PATCH */
+	int scan_assoc_time = 40;
+	int scan_unassoc_time = 40;
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+	uint32 listen_interval = LISTEN_INTERVAL; /* Default Listen Interval in Beacons */
+#endif /* CONFIG_LGE_BCM432X_PATCH */
+#if defined(SOFTAP)
+	uint dtim = 1;
+#endif 
+	int ret = 0;
+#ifdef GET_CUSTOM_MAC_ENABLE
+	struct ether_addr ea_addr;
+/* LGE_CHANGE_S [bill.park@lge.com] 2010-12-10, mac write */
+	char nvbuf_ether_addr_tmp[ETHER_ADDR_LEN*2 + 1] = {0,};		// +1 for NULL
+//	char nvbuf_ether_addr_flag[2] = {0,};		// +1 for NULL
+	char nvbuf_ether_addr[ETHER_ADDR_LEN] = {0,};
+/* LGE_CHANGE_E [bill.park@lge.com] 2010-12-10, mac write */
+
+#endif /* GET_CUSTOM_MAC_ENABLE */
+
+	dhd_os_proto_block(dhd);
+
+#ifdef GET_CUSTOM_MAC_ENABLE
+	/* Read MAC address from external customer place
+	** NOTE that default mac address has to be present in otp or nvram file to bring up
+	** firmware but unique per board mac address maybe provided by customer code
+	*/
+
+/* LGE_CHANGE_S [bill.park@lge.com] 2010-12-10, mac write */
+//	ret = dhd_custom_read_nvdata(dhd, NV_WIFI_MACFLAG, nvbuf_ether_addr_flag, sizeof(char));
+
+//	if (!ret) {
+//		if (nvbuf_ether_addr_flag[0] != '1') {
+//			// skip mac write...
+//			ret = -1;
+//		}
+//		else {
+			// read NV MAC address
+			ret = dhd_custom_read_nvdata(dhd, NV_WIFI_MACADDR, nvbuf_ether_addr_tmp, ETHER_ADDR_LEN *2);
+//		}
+//	} else {
+//		printk(KERN_ERR "%s failed to get NV_MAC_FLAG"
+//				"use orig dhd->mac.octet\n", __FUNCTION__);
+//	}
+
+	if (!ret) {
+		if (dhd_util_ascii_to_hex(nvbuf_ether_addr_tmp, ETHER_ADDR_LEN*2, nvbuf_ether_addr) <= 0) {
+			printk(KERN_INFO "mac convert error\n");
+			ret = -1;
+		}
+	}
+
+	if (!ret) {
+		if (dhd_check_nvmac_is_valid(nvbuf_ether_addr) == TRUE)	{
+			//read current dhd mac...
+			if (!dhd_get_curr_etheraddr(dhd, ea_addr.octet)) {
+				if (bcmp(nvbuf_ether_addr, ea_addr.octet, ETHER_ADDR_LEN)){
+					// use NV mac...
+					bcopy(nvbuf_ether_addr, &ea_addr.octet, sizeof(struct ether_addr));
+				}
+				else {
+					printk(KERN_INFO "the value of NV & DHD MAC is same,"
+						"no need to set mac address, just skip... \n");
+					ret = -1;
+				}
+			}
+			else {
+				DHD_ERROR(("%s: can't get current MAC address skip set mac address, error=%d\n", __FUNCTION__, ret));
+				ret = -1;
+			}
+		}
+		else {
+			printk(KERN_INFO "NV mac is invalid, no need to set mac address, just skip...\n");
+			ret = -1;
+		}
+	}
+
+	//ret = dhd_custom_get_mac_address(ea_addr.octet);
+/* LGE_CHANGE_E [bill.park@lge.com] 2010-12-10, mac write */
+
+	if (!ret) {
+		bcm_mkiovar("cur_etheraddr", (void *)&ea_addr, ETHER_ADDR_LEN, buf, sizeof(buf));
+		ret = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, buf, sizeof(buf));
+		if (ret < 0) {
+			DHD_ERROR(("%s: can't set MAC address , error=%d\n", __FUNCTION__, ret));
+		}
+		else
+			memcpy(dhd->mac.octet, (void *)&ea_addr, ETHER_ADDR_LEN);
+	}
+#endif  /* GET_CUSTOM_MAC_ENABLE */
+/* LGE_CHANGE_S [yoohoo@lge.com] 2009-04-03, configs */
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+	dhd_preinit_config(dhd, 0);
+#endif /* CONFIG_LGE_BCM432X_PATCH */
+/* LGE_CHANGE_E [yoohoo@lge.com] 2009-04-03, configs */
+
+	/* Set Country code */
+	if (dhd->dhd_cspec.ccode[0] != 0) {
+		bcm_mkiovar("country", (char *)&dhd->dhd_cspec, \
+			sizeof(wl_country_t), iovbuf, sizeof(iovbuf));
+		if ((ret = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf))) < 0)
+			DHD_ERROR(("%s: country code setting failed\n", __FUNCTION__));
+	}
+
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+	/* Set Listen Interval */
+	bcm_mkiovar("assoc_listen", (char *)&listen_interval, 4, iovbuf, sizeof(iovbuf));
+	if ((ret = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf))) < 0)
+		DHD_ERROR(("%s assoc_listen failed %d\n", __FUNCTION__, ret));
+#endif /* CONFIG_LGE_BCM432X_PATCH */
+
+	/* query for 'ver' to get version info from firmware */
+	memset(buf, 0, sizeof(buf));
+	ptr = buf;
+	bcm_mkiovar("ver", 0, 0, buf, sizeof(buf));
+	dhdcdc_query_ioctl(dhd, 0, WLC_GET_VAR, buf, sizeof(buf));
+	bcmstrtok(&ptr, "\n", 0);
+	/* Print fw version info */
+	DHD_ERROR(("Firmware version = %s\n", buf));
+
+/* LGE_CHANGE_S [yoohoo@lge.com] 2009-08-27, already PM setup is configured */
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+	/* Set PowerSave mode */
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_PM, (char *)&power_mode, sizeof(power_mode));
+#endif /* CONFIG_LGE_BCM432X_PATCH */
+/* LGE_CHANGE_E [yoohoo@lge.com] 2009-08-27, already PM setup is configured */
+
+	/* Match Host and Dongle rx alignment */
+	bcm_mkiovar("bus:txglomalign", (char *)&dongle_align, 4, iovbuf, sizeof(iovbuf));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+
+	/* disable glom option per default */
+	bcm_mkiovar("bus:txglom", (char *)&glom, 4, iovbuf, sizeof(iovbuf));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+
+/* LGE_CHANGE_S [yoohoo@lge.com] 2009-04-08, roam_off */
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+	/* Setup timeout if Beacons are lost and roam is off to report link down */
+	bcm_mkiovar("bcn_timeout", (char *)&bcn_timeout, 4, iovbuf, sizeof(iovbuf));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+
+	/* Enable/Disable build-in roaming to allowed ext supplicant to take of romaing */
+	bcm_mkiovar("roam_off", (char *)&dhd_roam, 4, iovbuf, sizeof(iovbuf));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+#endif /* CONFIG_LGE_BCM432X_PATCH */
+/* LGE_CHANGE_E [yoohoo@lge.com] 2009-04-08, roam_off */
+
+#if defined(SOFTAP)
+	if (ap_fw_loaded == TRUE) {
+		dhdcdc_set_ioctl(dhd, 0, WLC_SET_DTIMPRD, (char *)&dtim, sizeof(dtim));
+	}
+#endif 
+
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+	if (dhd_roam == 0)
+	{
+		/* set internal roaming roaming parameters */
+		int roam_scan_period = 30; /* in sec */
+		int roam_fullscan_period = 120; /* in sec */
+		int roam_trigger = -85;
+		int roam_delta = 15;
+		int band;
+		int band_temp_set = WLC_BAND_2G;
+
+		if (dhdcdc_set_ioctl(dhd, 0, WLC_SET_ROAM_SCAN_PERIOD, \
+			(char *)&roam_scan_period, sizeof(roam_scan_period)) < 0)
+			DHD_ERROR(("%s: roam scan setup failed\n", __FUNCTION__));
+
+		bcm_mkiovar("fullroamperiod", (char *)&roam_fullscan_period, \
+					 4, iovbuf, sizeof(iovbuf));
+		if (dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, \
+			iovbuf, sizeof(iovbuf)) < 0)
+			DHD_ERROR(("%s: roam fullscan setup failed\n", __FUNCTION__));
+
+		if (dhdcdc_query_ioctl(dhd, 0, WLC_GET_BAND, \
+				(char *)&band, sizeof(band)) < 0)
+			DHD_ERROR(("%s: roam delta setting failed\n", __FUNCTION__));
+		else {
+			if ((band == WLC_BAND_AUTO) || (band == WLC_BAND_ALL))
+			{
+				/* temp set band to insert new roams values */
+				if (dhdcdc_set_ioctl(dhd, 0, WLC_SET_BAND, \
+					(char *)&band_temp_set, sizeof(band_temp_set)) < 0)
+					DHD_ERROR(("%s: local band seting failed\n", __FUNCTION__));
+			}
+			if (dhdcdc_set_ioctl(dhd, 0, WLC_SET_ROAM_DELTA, \
+				(char *)&roam_delta, sizeof(roam_delta)) < 0)
+				DHD_ERROR(("%s: roam delta setting failed\n", __FUNCTION__));
+
+			if (dhdcdc_set_ioctl(dhd, 0, WLC_SET_ROAM_TRIGGER, \
+				(char *)&roam_trigger, sizeof(roam_trigger)) < 0)
+				DHD_ERROR(("%s: roam trigger setting failed\n", __FUNCTION__));
+
+			/* Restore original band settinngs */
+			if (dhdcdc_set_ioctl(dhd, 0, WLC_SET_BAND, \
+				(char *)&band, sizeof(band)) < 0)
+				DHD_ERROR(("%s: Original band restore failed\n", __FUNCTION__));
+		}
+	}
+#endif /* CONFIG_LGE_BCM432X_PATCH */
+
+	/* Force STA UP */
+	if (dhd_radio_up)
+		dhdcdc_set_ioctl(dhd, 0, WLC_UP, (char *)&up, sizeof(up));
+
+	/* Setup event_msgs */
+	bcm_mkiovar("event_msgs", dhd->eventmask, WL_EVENTING_MASK_LEN, iovbuf, sizeof(iovbuf));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_SCAN_CHANNEL_TIME, (char *)&scan_assoc_time,
+		sizeof(scan_assoc_time));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_SCAN_UNASSOC_TIME, (char *)&scan_unassoc_time,
+		sizeof(scan_unassoc_time));
+
+#ifdef ARP_OFFLOAD_SUPPORT
+	/* Set and enable ARP offload feature */
+	if (dhd_arp_enable)
+		dhd_arp_offload_set(dhd, dhd_arp_mode);
+	dhd_arp_offload_enable(dhd, dhd_arp_enable);
+#endif /* ARP_OFFLOAD_SUPPORT */
+
+#ifdef PKT_FILTER_SUPPORT
+	{
+		int i;
+		/* Set up pkt filter */
+		if (dhd_pkt_filter_enable) {
+			for (i = 0; i < dhd->pktfilter_count; i++) {
+				dhd_pktfilter_offload_set(dhd, dhd->pktfilter[i]);
+				dhd_pktfilter_offload_enable(dhd, dhd->pktfilter[i],
+					dhd_pkt_filter_init, dhd_master_mode);
+			}
+		}
+	}
+#endif /* PKT_FILTER_SUPPORT */
+
+#if defined(KEEP_ALIVE)
+	{
+	/* Set Keep Alive : be sure to use FW with -keepalive */
+	int res;
+
+	if (ap_fw_loaded == FALSE) {
+		if ((res = dhd_keep_alive_onoff(dhd, 1)) < 0)
+			DHD_ERROR(("%s set keeplive failed %d\n", \
+		__FUNCTION__, res));
+		}
+	}
+#endif
+
+	dhd_os_proto_unblock(dhd);
+
+	return 0;
+}
+
+#ifdef SIMPLE_ISCAN
+
+uint iscan_thread_id;
+iscan_buf_t * iscan_chain = 0;
+
+iscan_buf_t *
+dhd_iscan_allocate_buf(dhd_pub_t *dhd, iscan_buf_t **iscanbuf)
+{
+	iscan_buf_t *iscanbuf_alloc = 0;
+	iscan_buf_t *iscanbuf_head;
+
+	dhd_iscan_lock();
+
+	iscanbuf_alloc = (iscan_buf_t*)MALLOC(dhd->osh, sizeof(iscan_buf_t));
+	if (iscanbuf_alloc == NULL)
+		goto fail;
+
+	iscanbuf_alloc->next = NULL;
+	iscanbuf_head = *iscanbuf;
+
+	DHD_ISCAN(("%s: addr of allocated node = 0x%X"
+		   "addr of iscanbuf_head = 0x%X dhd = 0x%X\n",
+		   __FUNCTION__, iscanbuf_alloc, iscanbuf_head, dhd));
+
+	if (iscanbuf_head == NULL) {
+		*iscanbuf = iscanbuf_alloc;
+		DHD_ISCAN(("%s: Head is allocated\n", __FUNCTION__));
+		goto fail;
+	}
+
+	while (iscanbuf_head->next)
+		iscanbuf_head = iscanbuf_head->next;
+
+	iscanbuf_head->next = iscanbuf_alloc;
+
+fail:
+	dhd_iscan_unlock();
+	return iscanbuf_alloc;
+}
+
+void
+dhd_iscan_free_buf(void *dhdp, iscan_buf_t *iscan_delete)
+{
+	iscan_buf_t *iscanbuf_free = 0;
+	iscan_buf_t *iscanbuf_prv = 0;
+	iscan_buf_t *iscanbuf_cur = iscan_chain;
+	dhd_pub_t *dhd = dhd_bus_pub(dhdp);
+
+	dhd_iscan_lock();
+	/* If iscan_delete is null then delete the entire 
+	 * chain or else delete specific one provided
+	 */
+	if (!iscan_delete) {
 		while (iscanbuf_cur) {
 			iscanbuf_free = iscanbuf_cur;
 			iscanbuf_cur = iscanbuf_cur->next;
@@ -1968,11 +1951,66 @@ dhd_iscan_result_buf(void)
 	return iscan_chain;
 }
 
+
+
 /*
-* delete disappeared AP from specific scan cache
+* print scan cache
+* print partial iscan_skip list differently
 */
 int
-dhd_iscan_delete_bss(/* TBD void *dhdp, */ void *addr)
+dhd_iscan_print_cache(iscan_buf_t *iscan_skip)
+{
+	int i = 0, l = 0;
+	iscan_buf_t *iscan_cur;
+	wl_iscan_results_t *list;
+	wl_scan_results_t *results;
+	wl_bss_info_t UNALIGNED *bi;
+
+	dhd_iscan_lock();
+
+	iscan_cur = dhd_iscan_result_buf();
+
+	while (iscan_cur) {
+		list = (wl_iscan_results_t *)iscan_cur->iscan_buf;
+		if (!list)
+			break;
+
+		results = (wl_scan_results_t *)&list->results;
+		if (!results)
+			break;
+
+		if (results->version != WL_BSS_INFO_VERSION) {
+			DHD_ISCAN(("%s: results->version %d != WL_BSS_INFO_VERSION\n",
+				__FUNCTION__, results->version));
+			goto done;
+		}
+
+		bi = results->bss_info;
+		for (i = 0; i < results->count; i++) {
+			if (!bi)
+				break;
+
+			DHD_ISCAN(("%s[%2.2d:%2.2d] %X:%X:%X:%X:%X:%X\n",
+				iscan_cur != iscan_skip?"BSS":"bss", l, i,
+				bi->BSSID.octet[0], bi->BSSID.octet[1], bi->BSSID.octet[2],
+				bi->BSSID.octet[3], bi->BSSID.octet[4], bi->BSSID.octet[5]));
+
+			bi = (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length));
+		}
+		iscan_cur = iscan_cur->next;
+		l++;
+	}
+
+done:
+	dhd_iscan_unlock();
+	return 0;
+}
+
+/*
+* delete disappeared AP from specific scan cache but skip partial list in iscan_skip
+*/
+int
+dhd_iscan_delete_bss(void *dhdp, void *addr, iscan_buf_t *iscan_skip)
 {
 	int i = 0, j = 0, l = 0;
 	iscan_buf_t *iscan_cur;
@@ -1981,19 +2019,16 @@ dhd_iscan_delete_bss(/* TBD void *dhdp, */ void *addr)
 	wl_bss_info_t UNALIGNED *bi, *bi_new, *bi_next;
 
 	uchar *s_addr = addr;
-	DHD_TRACE(("%s: Entered\n", __FUNCTION__));
 
 	dhd_iscan_lock();
-	DHD_TRACE(("%s: BSS to remove %X:%X:%X:%X:%X:%X\n",
+	DHD_ISCAN(("%s: BSS to remove %X:%X:%X:%X:%X:%X\n",
 	__FUNCTION__, s_addr[0], s_addr[1], s_addr[2],
 	s_addr[3], s_addr[4], s_addr[5]));
 
-	DHD_TRACE(("%s: Scan cache before delete\n",
-	__FUNCTION__));
-
 	iscan_cur = dhd_iscan_result_buf();
 
 	while (iscan_cur) {
+		if (iscan_cur != iscan_skip) {
 			list = (wl_iscan_results_t *)iscan_cur->iscan_buf;
 			if (!list)
 				break;
@@ -2014,20 +2049,31 @@ dhd_iscan_delete_bss(/* TBD void *dhdp, */ void *addr)
 					break;
 
 				if (!memcmp(bi->BSSID.octet, addr, ETHER_ADDR_LEN)) {
-					DHD_TRACE(("%s: Del BSS[%2.2d:%2.2d] %X:%X:%X:%X:%X:%X\n",
-					__FUNCTION__, l, i, bi->BSSID.octet[0], bi->BSSID.octet[1],
-					bi->BSSID.octet[2], bi->BSSID.octet[3], bi->BSSID.octet[4],
+					DHD_ISCAN(("%s: Del BSS[%2.2d:%2.2d] %X:%X:%X:%X:%X:%X\n",
+					__FUNCTION__, l, i, bi->BSSID.octet[0],
+					bi->BSSID.octet[1], bi->BSSID.octet[2],
+					bi->BSSID.octet[3], bi->BSSID.octet[4],
 					bi->BSSID.octet[5]));
 
 					bi_new = bi;
 					bi = (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length));
-
+/*
+					if(bi && bi_new) {
+						bcopy(bi, bi_new, results->buflen -
+						dtoh32(bi_new->length));
+						results->buflen -= dtoh32(bi_new->length);
+					}
+*/
+					results->buflen -= dtoh32(bi_new->length);
+					results->count--;
 
 					for (j = i; j < results->count; j++) {
-					DHD_TRACE(("%s: Moved up BSS[%2.2d:%2.2d]"
-					" %X:%X:%X:%X:%X:%X\n",
-					__FUNCTION__, l, j, bi->BSSID.octet[0], bi->BSSID.octet[1],
-					bi->BSSID.octet[2], bi->BSSID.octet[3], bi->BSSID.octet[4],
+						if (bi && bi_new) {
+							DHD_ISCAN(("%s: Moved up BSS[%2.2d:%2.2d]"
+							"%X:%X:%X:%X:%X:%X\n",
+							__FUNCTION__, l, j, bi->BSSID.octet[0],
+							bi->BSSID.octet[1], bi->BSSID.octet[2],
+							bi->BSSID.octet[3], bi->BSSID.octet[4],
 					bi->BSSID.octet[5]));
 
 					bi_next = (wl_bss_info_t *)((uintptr)bi +
@@ -2037,27 +2083,86 @@ dhd_iscan_delete_bss(/* TBD void *dhdp, */ void *addr)
 						dtoh32(bi_new->length));
 							bi = bi_next;
 						}
-				results->count--;
+					}
+
 					if (results->count == 0) {
 						/* Prune now empty partial scan list */
+						dhd_iscan_free_buf(dhdp, iscan_cur);
 						goto done;
 					}
 					break;
 				}
-
 				bi = (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length));
 			}
+		}
 		iscan_cur = iscan_cur->next;
 		l++;
 	}
 
 done:
-	DHD_TRACE(("%s: Scan cache after delete\n",
+	dhd_iscan_unlock();
+	return 0;
+}
+
+int
+dhd_iscan_remove_duplicates(void * dhdp, iscan_buf_t *iscan_cur)
+{
+	int i = 0;
+	wl_iscan_results_t *list;
+	wl_scan_results_t *results;
+	wl_bss_info_t UNALIGNED *bi, *bi_new, *bi_next;
+
+	dhd_iscan_lock();
+
+	DHD_ISCAN(("%s: Scan cache before delete\n",
 		__FUNCTION__));
+	dhd_iscan_print_cache(iscan_cur);
+
+	if (!iscan_cur)
+		goto done;
+
+	list = (wl_iscan_results_t *)iscan_cur->iscan_buf;
+	if (!list)
+		goto done;
+
+	results = (wl_scan_results_t *)&list->results;
+	if (!results)
+		goto done;
+
+	if (results->version != WL_BSS_INFO_VERSION) {
+		DHD_ERROR(("%s: results->version %d != WL_BSS_INFO_VERSION\n",
+			__FUNCTION__, results->version));
+		goto done;
+	}
+
+	bi = results->bss_info;
+	for (i = 0; i < results->count; i++) {
+		if (!bi)
+			break;
+
+		DHD_ISCAN(("%s: Find dups for BSS[%2.2d] %X:%X:%X:%X:%X:%X\n",
+			__FUNCTION__, i, bi->BSSID.octet[0], bi->BSSID.octet[1], bi->BSSID.octet[2],
+			bi->BSSID.octet[3], bi->BSSID.octet[4], bi->BSSID.octet[5]));
+
+		dhd_iscan_delete_bss(dhdp, bi->BSSID.octet, iscan_cur);
+
+		bi = (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length));
+	}
+
+done:
+	DHD_ISCAN(("%s: Scan cache after delete\n", __FUNCTION__));
+	dhd_iscan_print_cache(iscan_cur);
 	dhd_iscan_unlock();
 	return 0;
 }
 
+void
+dhd_iscan_ind_scan_confirm(void *dhdp, bool status)
+{
+
+	dhd_ind_scan_confirm(dhdp, status);
+}
+
 int
 dhd_iscan_request(void * dhdp, uint16 action)
 {
@@ -2066,7 +2171,6 @@ dhd_iscan_request(void * dhdp, uint16 action)
 	dhd_pub_t *dhd = dhd_bus_pub(dhdp);
 	char buf[WLC_IOCTL_SMLEN];
 
-	DHD_TRACE(("%s: Entered\n", __FUNCTION__));
 
 	memset(&params, 0, sizeof(wl_iscan_params_t));
 	memcpy(&params.params.bssid, &ether_bcast, ETHER_ADDR_LEN);
@@ -2085,7 +2189,7 @@ dhd_iscan_request(void * dhdp, uint16 action)
 	params.scan_duration = htod16(0);
 
 	bcm_mkiovar("iscan", (char *)&params, sizeof(wl_iscan_params_t), buf, WLC_IOCTL_SMLEN);
-	rc = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, buf, WLC_IOCTL_SMLEN, TRUE, 0);
+	rc = dhd_wl_ioctl(dhdp, WLC_SET_VAR, buf, WLC_IOCTL_SMLEN);
 
 	return rc;
 }
@@ -2101,14 +2205,12 @@ dhd_iscan_get_partial_result(void *dhdp, uint *scan_count)
 	dhd_pub_t *dhd = dhd_bus_pub(dhdp);
 	int rc;
 
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
 	iscan_cur = dhd_iscan_allocate_buf(dhd, &iscan_chain);
 	if (!iscan_cur) {
 		DHD_ERROR(("%s: Failed to allocate node\n", __FUNCTION__));
 		dhd_iscan_free_buf(dhdp, 0);
 		dhd_iscan_request(dhdp, WL_SCAN_ACTION_ABORT);
-		dhd_ind_scan_confirm(dhdp, FALSE);
 		goto fail;
 	}
 
@@ -2125,68 +2227,33 @@ dhd_iscan_get_partial_result(void *dhdp, uint *scan_count)
 	list.results.buflen = htod32(WLC_IW_ISCAN_MAXLEN);
 	bcm_mkiovar("iscanresults", (char *)&list, WL_ISCAN_RESULTS_FIXED_SIZE,
 		iscan_cur->iscan_buf, WLC_IW_ISCAN_MAXLEN);
-	rc = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, iscan_cur->iscan_buf,
-	                      WLC_IW_ISCAN_MAXLEN, FALSE, 0);
+	rc = dhd_wl_ioctl(dhdp, WLC_GET_VAR, iscan_cur->iscan_buf, WLC_IW_ISCAN_MAXLEN);
 
 	results->buflen = dtoh32(results->buflen);
 	results->version = dtoh32(results->version);
 	*scan_count = results->count = dtoh32(results->count);
 	status = dtoh32(list_buf->status);
-	DHD_TRACE(("%s: Got %d resuls\n", __FUNCTION__, results->count));
 
 	dhd_iscan_unlock();
 
-	if (!(*scan_count)) {
+	if (!(*scan_count))
 		dhd_iscan_free_buf(dhdp, iscan_cur);
-	}
+	else
+		dhd_iscan_remove_duplicates(dhdp, iscan_cur);
+
+
 fail:
 	return status;
 }
 
 #endif 
 
-/*
- * returns = TRUE if associated, FALSE if not associated
- */
-bool dhd_is_associated(dhd_pub_t *dhd, void *bss_buf)
-{
-	char bssid[6], zbuf[6];
-	int ret = -1;
-
-	bzero(bssid, 6);
-	bzero(zbuf, 6);
-
-	ret  = dhd_wl_ioctl_cmd(dhd, WLC_GET_BSSID, (char *)&bssid, ETHER_ADDR_LEN, FALSE, 0);
-	DHD_TRACE((" %s WLC_GET_BSSID ioctl res = %d\n", __FUNCTION__, ret));
-
-	if (ret == BCME_NOTASSOCIATED) {
-		DHD_TRACE(("%s: not associated! res:%d\n", __FUNCTION__, ret));
-	}
-
-	if (ret < 0)
-		return FALSE;
-
-	if ((memcmp(bssid, zbuf, ETHER_ADDR_LEN) != 0)) {
-		/*  STA is assocoated BSSID is non zero */
-
-		if (bss_buf) {
-			/* return bss if caller provided buf */
-			memcpy(bss_buf, bssid, ETHER_ADDR_LEN);
-		}
-		return TRUE;
-	} else {
-		DHD_TRACE(("%s: WLC_GET_BSSID ioctl returned zero bssid\n", __FUNCTION__));
-		return FALSE;
-	}
-}
-
-
 /* Function to estimate possible DTIM_SKIP value */
-int
-dhd_get_dtim_skip(dhd_pub_t *dhd)
+int dhd_get_dtim_skip(dhd_pub_t *dhd)
 {
 	int bcn_li_dtim;
-	int ret = -1;
+	char buf[128];
+	int ret;
 	int dtim_assoc = 0;
 
 	if ((dhd->dtim_skip == 0) || (dhd->dtim_skip == 1))
@@ -2194,20 +2261,18 @@ dhd_get_dtim_skip(dhd_pub_t *dhd)
 	else
 		bcn_li_dtim = dhd->dtim_skip;
 
-	/* Check if associated */
-	if (dhd_is_associated(dhd, NULL) == FALSE) {
-		DHD_ERROR(("%s NOT assoc ret %d\n", __FUNCTION__, ret));
-		goto exit;
-	}
-
-	/* if assoc grab ap's dtim value */
-	if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_DTIMPRD,
-		&dtim_assoc, sizeof(dtim_assoc), FALSE, 0)) < 0) {
+	/* Read DTIM value if associated */
+	memset(buf, 0, sizeof(buf));
+	bcm_mkiovar("dtim_assoc", 0, 0, buf, sizeof(buf));
+	if ((ret = dhdcdc_query_ioctl(dhd, 0, WLC_GET_VAR, buf, sizeof(buf))) < 0) {
 		DHD_ERROR(("%s failed code %d\n", __FUNCTION__, ret));
+		bcn_li_dtim = 1;
 		goto exit;
 	}
+	else
+		dtim_assoc = dtoh32(*(int *)buf);
 
-	DHD_ERROR(("%s bcn_li_dtim=%d DTIM=%d Listen=%d\n",
+	DHD_ERROR(("%s bcn_li_dtim=%d DTIM=%d Listen=%d\n", \
 		__FUNCTION__, bcn_li_dtim, dtim_assoc, LISTEN_INTERVAL));
 
 	/* if not assocated just eixt */
@@ -2219,7 +2284,7 @@ dhd_get_dtim_skip(dhd_pub_t *dhd)
 	if (dtim_assoc > LISTEN_INTERVAL) {
 		/* AP DTIM to big for our Listen Interval : no dtim skiping */
 		bcn_li_dtim = 1;
-		DHD_ERROR(("%s DTIM=%d > Listen=%d : too big ...\n",
+		DHD_ERROR(("%s DTIM=%d > Listen=%d : too big ...\n", \
 			__FUNCTION__, dtim_assoc, LISTEN_INTERVAL));
 		goto exit;
 	}
@@ -2233,3 +2298,457 @@ dhd_get_dtim_skip(dhd_pub_t *dhd)
 exit:
 	return bcn_li_dtim;
 }
+
+#ifdef PNO_SUPPORT
+int dhd_pno_clean(dhd_pub_t *dhd)
+{
+	char iovbuf[128];
+	int pfn_enabled = 0;
+	int iov_len = 0;
+	int ret;
+
+	/* Disable pfn */
+	iov_len = bcm_mkiovar("pfn", (char *)&pfn_enabled, 4, iovbuf, sizeof(iovbuf));
+	if ((ret = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf))) >= 0) {
+		/* clear pfn */
+		iov_len = bcm_mkiovar("pfnclear", 0, 0, iovbuf, sizeof(iovbuf));
+		if (iov_len) {
+			if ((ret = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, iov_len)) < 0) {
+				DHD_ERROR(("%s failed code %d\n", __FUNCTION__, ret));
+			}
+		}
+		else {
+			ret = -1;
+			DHD_ERROR(("%s failed code %d\n", __FUNCTION__, iov_len));
+		}
+	}
+	else
+		DHD_ERROR(("%s failed code %d\n", __FUNCTION__, ret));
+
+	return ret;
+}
+
+int dhd_pno_enable(dhd_pub_t *dhd, int pfn_enabled)
+{
+	char iovbuf[128];
+	int ret = -1;
+
+	if ((!dhd) && ((pfn_enabled != 0) || (pfn_enabled != 1))) {
+		DHD_ERROR(("%s error exit\n", __FUNCTION__));
+		return ret;
+	}
+
+	/* Enable/disable PNO */
+	if ((ret = bcm_mkiovar("pfn", (char *)&pfn_enabled, 4, iovbuf, sizeof(iovbuf))) > 0) {
+		if ((ret = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf))) < 0) {
+			DHD_ERROR(("%s failed for error=%d\n", __FUNCTION__, ret));
+			return ret;
+		}
+		else {
+			dhd->pno_enable = pfn_enabled;
+			DHD_TRACE(("%s set pno as %d\n", __FUNCTION__, dhd->pno_enable));
+		}
+	}
+	else DHD_ERROR(("%s failed err=%d\n", __FUNCTION__, ret));
+
+	return ret;
+}
+
+/* Function to execute combined scan */
+int
+dhd_pno_set(dhd_pub_t *dhd, wlc_ssid_t* ssids_local, int nssid, ushort scan_fr)
+{
+	int err = -1;
+	char iovbuf[128];
+	int k, i;
+	wl_pfn_param_t pfn_param;
+	wl_pfn_t	pfn_element;
+
+	DHD_TRACE(("%s nssid=%d nchan=%d\n", __FUNCTION__, nssid, scan_fr));
+
+	if ((!dhd) && (!ssids_local)) {
+		DHD_ERROR(("%s error exit\n", __FUNCTION__));
+		err = -1;
+	}
+
+	/* Check for broadcast ssid */
+	for (k = 0; k < nssid; k++) {
+		if (!ssids_local[k].SSID_len) {
+			DHD_ERROR(("%d: Broadcast SSID is ilegal for PNO setting\n", k));
+			return err;
+		}
+	}
+#define  PNO_DUMP 1
+#ifdef PNO_DUMP
+	{
+		int j;
+		for (j = 0; j < nssid; j++) {
+			DHD_ERROR(("%d: scan  for  %s size =%d\n", j,
+				ssids_local[j].SSID, ssids_local[j].SSID_len));
+		}
+	}
+#endif /* PNO_DUMP */
+
+	/* clean up everything */
+	if  ((err = dhd_pno_clean(dhd)) < 0) {
+		DHD_ERROR(("%s failed error=%d\n", __FUNCTION__, err));
+		return err;
+	}
+	memset(&pfn_param, 0, sizeof(pfn_param));
+	memset(&pfn_element, 0, sizeof(pfn_element));
+
+	/* set pfn parameters */
+	pfn_param.version = htod32(PFN_VERSION);
+	pfn_param.flags = htod16((PFN_LIST_ORDER << SORT_CRITERIA_BIT));
+
+	/* set up pno scan fr */
+	if (scan_fr  != 0)
+		pfn_param.scan_freq = htod32(scan_fr);
+
+	if (pfn_param.scan_freq > PNO_SCAN_MAX_FW) {
+		DHD_ERROR(("%s pno freq above %d sec\n", __FUNCTION__, PNO_SCAN_MAX_FW));
+		return err;
+	}
+
+	bcm_mkiovar("pfn_set", (char *)&pfn_param, sizeof(pfn_param), iovbuf, sizeof(iovbuf));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+
+	/* set all pfn ssid */
+	for (i = 0; i < nssid; i++) {
+
+		pfn_element.bss_type = htod32(DOT11_BSSTYPE_INFRASTRUCTURE);
+		pfn_element.auth = (DOT11_OPEN_SYSTEM);
+		pfn_element.wpa_auth = htod32(WPA_AUTH_PFN_ANY);
+		pfn_element.wsec = htod32(0);
+		pfn_element.infra = htod32(1);
+
+		memcpy((char *)pfn_element.ssid.SSID, ssids_local[i].SSID, ssids_local[i].SSID_len);
+		pfn_element.ssid.SSID_len = ssids_local[i].SSID_len;
+
+		if ((err =
+		bcm_mkiovar("pfn_add", (char *)&pfn_element,
+			sizeof(pfn_element), iovbuf, sizeof(iovbuf))) > 0) {
+			if ((err =
+			dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf))) < 0) {
+				DHD_ERROR(("%s failed for i=%d error=%d\n",
+					__FUNCTION__, i, err));
+				return err;
+			}
+			else
+				DHD_ERROR(("%s set OK with PNO time=%d\n", __FUNCTION__, \
+								pfn_param.scan_freq));
+		}
+		else DHD_ERROR(("%s failed err=%d\n", __FUNCTION__, err));
+	}
+
+	/* Enable PNO */
+	/* dhd_pno_enable(dhd, 1); */
+	return err;
+}
+
+int dhd_pno_get_status(dhd_pub_t *dhd)
+{
+	int ret = -1;
+
+	if (!dhd)
+		return ret;
+	else
+		return (dhd->pno_enable);
+}
+
+#endif /* PNO_SUPPORT */
+
+#if defined(KEEP_ALIVE)
+int dhd_keep_alive_onoff(dhd_pub_t *dhd, int ka_on)
+{
+	char buf[256];
+	char *buf_ptr = buf;
+	wl_keep_alive_pkt_t keep_alive_pkt;
+	char * str;
+	int str_len, buf_len;
+	int res = 0;
+	int keep_alive_period = KEEP_ALIVE_PERIOD; /* in ms */
+
+	DHD_TRACE(("%s: ka:%d\n", __FUNCTION__, ka_on));
+
+	if (ka_on) { /* on suspend */
+		keep_alive_pkt.period_msec = keep_alive_period;
+
+	} else {
+		/* on resume, turn off keep_alive packets  */
+		keep_alive_pkt.period_msec = 0;
+	}
+
+	/* IOC var name  */
+	str = "keep_alive";
+	str_len = strlen(str);
+	strncpy(buf, str, str_len);
+	buf[str_len] = '\0';
+	buf_len = str_len + 1;
+
+	/* set ptr to IOCTL payload after the var name */
+	buf_ptr += buf_len; /* include term Z */
+
+	/* copy Keep-alive attributes from local var keep_alive_pkt */
+	str = NULL_PKT_STR;
+	keep_alive_pkt.len_bytes = strlen(str);
+
+	memcpy(buf_ptr, &keep_alive_pkt, WL_KEEP_ALIVE_FIXED_LEN);
+	buf_ptr += WL_KEEP_ALIVE_FIXED_LEN;
+
+	/* copy packet data */
+	memcpy(buf_ptr, str, keep_alive_pkt.len_bytes);
+	buf_len += (WL_KEEP_ALIVE_FIXED_LEN + keep_alive_pkt.len_bytes);
+
+	res = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, buf, buf_len);
+	return res;
+}
+#endif /* defined(KEEP_ALIVE) */
+
+/* Androd ComboSCAN support */
+/*
+ *  data parsing from ComboScan tlv list
+*/
+int
+wl_iw_parse_data_tlv(char** list_str, void *dst, int dst_size, const char token,
+                     int input_size, int *bytes_left)
+{
+	char* str = *list_str;
+	uint16 short_temp;
+	uint32 int_temp;
+
+	if ((list_str == NULL) || (*list_str == NULL) ||(bytes_left == NULL) || (*bytes_left < 0)) {
+		DHD_ERROR(("%s error paramters\n", __FUNCTION__));
+		return -1;
+	}
+
+	/* Clean all dest bytes */
+	memset(dst, 0, dst_size);
+	while (*bytes_left > 0) {
+
+		if (str[0] != token) {
+			DHD_TRACE(("%s NOT Type=%d get=%d left_parse=%d \n",
+				__FUNCTION__, token, str[0], *bytes_left));
+			return -1;
+		}
+
+		*bytes_left -= 1;
+		str += 1;
+
+		if (input_size == 1) {
+			memcpy(dst, str, input_size);
+		}
+		else if (input_size == 2) {
+			memcpy(dst, (char *)htod16(memcpy(&short_temp, str, input_size)),
+				input_size);
+		}
+		else if (input_size == 4) {
+			memcpy(dst, (char *)htod32(memcpy(&int_temp, str, input_size)),
+				input_size);
+		}
+
+		*bytes_left -= input_size;
+		str += input_size;
+		*list_str = str;
+		return 1;
+	}
+	return 1;
+}
+
+/*
+ *  channel list parsing from cscan tlv list
+*/
+int
+wl_iw_parse_channel_list_tlv(char** list_str, uint16* channel_list,
+                             int channel_num, int *bytes_left)
+{
+	char* str = *list_str;
+	int idx = 0;
+
+	if ((list_str == NULL) || (*list_str == NULL) ||(bytes_left == NULL) || (*bytes_left < 0)) {
+		DHD_ERROR(("%s error paramters\n", __FUNCTION__));
+		return -1;
+	}
+
+	while (*bytes_left > 0) {
+
+		if (str[0] != CSCAN_TLV_TYPE_CHANNEL_IE) {
+			*list_str = str;
+			DHD_TRACE(("End channel=%d left_parse=%d %d\n", idx, *bytes_left, str[0]));
+			return idx;
+		}
+		/* Get proper CSCAN_TLV_TYPE_CHANNEL_IE */
+		*bytes_left -= 1;
+		str += 1;
+
+		if (str[0] == 0) {
+			/* All channels */
+			channel_list[idx] = 0x0;
+		}
+		else {
+			channel_list[idx] = (uint16)str[0];
+			DHD_TRACE(("%s channel=%d \n", __FUNCTION__,  channel_list[idx]));
+		}
+		*bytes_left -= 1;
+		str += 1;
+
+		if (idx++ > 255) {
+			DHD_ERROR(("%s Too many channels \n", __FUNCTION__));
+			return -1;
+		}
+	}
+
+	*list_str = str;
+	return idx;
+}
+
+/*
+ *  SSIDs list parsing from cscan tlv list
+ */
+int
+wl_iw_parse_ssid_list_tlv(char** list_str, wlc_ssid_t* ssid, int max, int *bytes_left)
+{
+	char* str =  *list_str;
+	int idx = 0;
+
+	if ((list_str == NULL) || (*list_str == NULL) || (*bytes_left < 0)) {
+		DHD_ERROR(("%s error paramters\n", __FUNCTION__));
+		return -1;
+	}
+
+	while (*bytes_left > 0) {
+
+		if (str[0] != CSCAN_TLV_TYPE_SSID_IE) {
+			*list_str = str;
+			DHD_TRACE(("nssid=%d left_parse=%d %d\n", idx, *bytes_left, str[0]));
+			return idx;
+		}
+
+		/* Get proper CSCAN_TLV_TYPE_SSID_IE */
+		*bytes_left -= 1;
+		str += 1;
+
+		if (str[0] == 0) {
+			/* Broadcast SSID */
+			ssid[idx].SSID_len = 0;
+			memset((char*)ssid[idx].SSID, 0x0, DOT11_MAX_SSID_LEN);
+			*bytes_left -= 1;
+			str += 1;
+
+			DHD_TRACE(("BROADCAST SCAN  left=%d\n", *bytes_left));
+		}
+		else if (str[0] <= DOT11_MAX_SSID_LEN) {
+			/* Get proper SSID size */
+			ssid[idx].SSID_len = str[0];
+			*bytes_left -= 1;
+			str += 1;
+
+			/* Get SSID */
+			if (ssid[idx].SSID_len > *bytes_left) {
+				DHD_ERROR(("%s out of memory range len=%d but left=%d\n",
+				__FUNCTION__, ssid[idx].SSID_len, *bytes_left));
+				return -1;
+			}
+
+			memcpy((char*)ssid[idx].SSID, str, ssid[idx].SSID_len);
+
+			*bytes_left -= ssid[idx].SSID_len;
+			str += ssid[idx].SSID_len;
+
+			DHD_TRACE(("%s :size=%d left=%d\n",
+				(char*)ssid[idx].SSID, ssid[idx].SSID_len, *bytes_left));
+		}
+		else {
+			DHD_ERROR(("### SSID size more that %d\n", str[0]));
+			return -1;
+		}
+
+		if (idx++ >  max) {
+			DHD_ERROR(("%s number of SSIDs more that %d\n", __FUNCTION__, idx));
+			return -1;
+		}
+	}
+
+	*list_str = str;
+	return idx;
+}
+
+/* Parse a comma-separated list from list_str into ssid array, starting
+ * at index idx.  Max specifies size of the ssid array.  Parses ssids
+ * and returns updated idx; if idx >= max not all fit, the excess have
+ * not been copied.  Returns -1 on empty string, or on ssid too long.
+ */
+int
+wl_iw_parse_ssid_list(char** list_str, wlc_ssid_t* ssid, int idx, int max)
+{
+	char* str, *ptr;
+
+	if ((list_str == NULL) || (*list_str == NULL))
+		return -1;
+
+	for (str = *list_str; str != NULL; str = ptr) {
+
+		/* check for next TAG */
+		if (!strncmp(str, GET_CHANNEL, strlen(GET_CHANNEL))) {
+			*list_str	 = str + strlen(GET_CHANNEL);
+			return idx;
+		}
+
+		if ((ptr = strchr(str, ',')) != NULL) {
+			*ptr++ = '\0';
+		}
+
+		if (strlen(str) > DOT11_MAX_SSID_LEN) {
+			DHD_ERROR(("ssid <%s> exceeds %d\n", str, DOT11_MAX_SSID_LEN));
+			return -1;
+		}
+
+		if (strlen(str) == 0)
+			ssid[idx].SSID_len = 0;
+
+		if (idx < max) {
+			strcpy((char*)ssid[idx].SSID, str);
+			ssid[idx].SSID_len = strlen(str);
+		}
+		idx++;
+	}
+	return idx;
+}
+
+/*
+ * Parse channel list from iwpriv CSCAN
+ */
+int
+wl_iw_parse_channel_list(char** list_str, uint16* channel_list, int channel_num)
+{
+	int num;
+	int val;
+	char* str;
+	char* endptr = NULL;
+
+	if ((list_str == NULL)||(*list_str == NULL))
+		return -1;
+
+	str = *list_str;
+	num = 0;
+	while (strncmp(str, GET_NPROBE, strlen(GET_NPROBE))) {
+		val = (int)strtoul(str, &endptr, 0);
+		if (endptr == str) {
+			printf("could not parse channel number starting at"
+				" substring \"%s\" in list:\n%s\n",
+				str, *list_str);
+			return -1;
+		}
+		str = endptr + strspn(endptr, " ,");
+
+		if (num == channel_num) {
+			DHD_ERROR(("too many channels (more than %d) in channel list:\n%s\n",
+				channel_num, *list_str));
+			return -1;
+		}
+
+		channel_list[num++] = (uint16)val;
+	}
+	*list_str = str;
+	return num;
+}
diff --git a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_custom_gpio.c b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_custom_gpio.c
index 6d823f4..3929144 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_custom_gpio.c
+++ b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_custom_gpio.c
@@ -20,7 +20,7 @@
 * software in any way with any other Broadcom software provided under a license
 * other than the GPL, without Broadcom's express prior written consent.
 *
-* $Id: dhd_custom_gpio.c,v 1.1.4.2.20.4.2.2 2010/11/09 02:06:54 Exp $
+* $Id: dhd_custom_gpio.c,v 1.1.4.8.4.3 2011/01/20 02:30:58 Exp $
 */
 
 
@@ -42,16 +42,9 @@
 #endif /* CONFIG_LGE_BCM432X_PATCH */
 /* LGE_CHANGE_E [yoohoo@lge.com] 2009-05-14, support start/stop */
 
-#define WL_ERROR(x) printk x
+#define WL_ERROR(x) printf x
 #define WL_TRACE(x)
 
-#include <linux/wlan_plat.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/mmc/host.h>
-#include <mach/hardware.h>
-//#include <mach/gpio-names.h>
-
 #ifdef CUSTOMER_HW
 extern  void bcm_wlan_power_off(int);
 extern  void bcm_wlan_power_on(int);
@@ -60,7 +53,6 @@ extern  void bcm_wlan_power_on(int);
 int wifi_set_carddetect(int on);
 int wifi_set_power(int on, unsigned long msec);
 int wifi_get_irq_number(unsigned long *irq_flags_ptr);
-int wifi_get_mac_addr(unsigned char *buf);
 #endif
 
 #if defined(OOB_INTR_ONLY)
@@ -73,22 +65,11 @@ extern int sdioh_mmc_irq(int irq);
 #endif
 
 /* Customer specific Host GPIO defintion  */
-static int dhd_oob_gpio_num = -1;
+static int dhd_oob_gpio_num = -1; /* GG 19 */
 
 module_param(dhd_oob_gpio_num, int, 0644);
 MODULE_PARM_DESC(dhd_oob_gpio_num, "DHD oob gpio number");
 
-/* that function will returns :
-    1) return :  Host gpio interrupt number per customer platform
-    2) irq_flags_ptr : Type of Host interrupt as Level or Edge
-
-    NOTE :
-    Customer should check his platform definitions
-    and hist Host Interrupt  spec
-    to figure out the proper setting for his platform.
-    BRCM provides just reference settings as example.
-
-*/
 int dhd_customer_oob_irq_map(unsigned long *irq_flags_ptr)
 {
 	int  host_oob_irq = 0;
@@ -137,6 +118,11 @@ dhd_customer_gpio_wlan_ctrl(int onoff)
 		case WLAN_RESET_OFF:
 			WL_TRACE(("%s: call customer specific GPIO to insert WLAN RESET\n",
 				__FUNCTION__));
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+			//star_wifi_power(0);
+			//gpio_set_value(177, 0);
+#endif
+
 #ifdef CUSTOMER_HW
 			bcm_wlan_power_off(2);
 #endif /* CUSTOMER_HW */
@@ -149,6 +135,11 @@ dhd_customer_gpio_wlan_ctrl(int onoff)
 		case WLAN_RESET_ON:
 			WL_TRACE(("%s: callc customer specific GPIO to remove WLAN RESET\n",
 				__FUNCTION__));
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+			//star_wifi_power(1);
+			//gpio_set_value(177, 1);
+			//mdelay(200);
+#endif
 #ifdef CUSTOMER_HW
 			bcm_wlan_power_on(2);
 #endif /* CUSTOMER_HW */
@@ -161,26 +152,32 @@ dhd_customer_gpio_wlan_ctrl(int onoff)
 		case WLAN_POWER_OFF:
 			WL_TRACE(("%s: call customer specific GPIO to turn off WL_REG_ON\n",
 				__FUNCTION__));
+#if defined(CONFIG_WIFI_CONTROL_FUNC)
+			//star_wifi_power(0);
+			wifi_set_power(0, 200);
+			
+#endif
 #ifdef CUSTOMER_HW
 			bcm_wlan_power_off(1);
 #endif /* CUSTOMER_HW */
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-			wifi_set_power(0, 200);
-#endif
-		WL_ERROR(("=========== WLAN placed in RESET (POWER OFF)========\n"));
 		break;
 
 		case WLAN_POWER_ON:
 			WL_TRACE(("%s: call customer specific GPIO to turn on WL_REG_ON\n",
 				__FUNCTION__));
+#if defined(CONFIG_WIFI_CONTROL_FUNC)
+
+			printk("[Wi-Fi] WLAN_RESET : %d\n",	gpio_get_value(177));
+			//star_wifi_power(1);
+			wifi_set_power(1, 200);
+			//mdelay(200);
+			printk("[Wi-Fi] WLAN_RESET : %d\n",	gpio_get_value(177));
+#endif
 #ifdef CUSTOMER_HW
 			bcm_wlan_power_on(1);
 #endif /* CUSTOMER_HW */
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-			wifi_set_power(1, 200);
-#endif
-			OSL_DELAY(200);
-			WL_ERROR(("=========== WLAN going back to live (POWER ON)  ========\n"));
+			/* Lets customer power to get stable */
+			OSL_DELAY(500);
 		break;
 	}
 }
@@ -190,17 +187,11 @@ dhd_customer_gpio_wlan_ctrl(int onoff)
 int
 dhd_custom_get_mac_address(unsigned char *buf)
 {
-	int ret = 0;
-
 	WL_TRACE(("%s Enter\n", __FUNCTION__));
 	if (!buf)
 		return -EINVAL;
 
 	/* Customer access to MAC address stored outside of DHD driver */
-#if defined(CONFIG_MACH_MAHIMAHI) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
-	/* Lin - this will call wifi_control_data->get_mac_addr (dhd_linux.c) */
-	ret = wifi_get_mac_addr(buf);
-#endif
 
 #ifdef EXAMPLE_GET_MAC
 	/* EXAMPLE code */
@@ -210,6 +201,50 @@ dhd_custom_get_mac_address(unsigned char *buf)
 	}
 #endif /* EXAMPLE_GET_MAC */
 
-	return ret;
+	return 0;
 }
 #endif /* GET_CUSTOM_MAC_ENABLE */
+
+/* Customized Locale table : OPTIONAL feature */
+const struct cntry_locales_custom translate_custom_table[] = {
+/* Table should be filled out based on custom platform regulatory requirement */
+#ifdef EXMAPLE_TABLE
+	{"US", "US", 69}, /* input ISO "US" to : US regrev 69 */
+	{"CA", "US", 69}, /* input ISO "CA" to : US regrev 69 */
+	{"FR", "EU", 05},
+	{"DE", "EU", 05},
+	{"IR", "EU", 05},
+	{"UK", "EU", 05}, /* input ISO "UK" to : EU regrev 05 */
+	{"KR", "XY", 03},
+	{"AU", "XY", 03},
+	{"CH", "XY", 03}, /* input ISO "CH" to : XY regrev 03 */
+	{"TW", "XY", 03},
+	{"AR", "XY", 03}
+#endif /* EXMAPLE_TABLE */
+};
+
+
+/* Customized Locale convertor
+*  input : ISO 3166-1 country abbreviation
+*  output: customized cspec
+*/
+void get_customized_country_code(char *country_iso_code, wl_country_t *cspec)
+{
+	int size, i;
+
+	size = ARRAYSIZE(translate_custom_table);
+
+	if (cspec == 0)
+		 return;
+
+	if (size == 0)
+		 return;
+
+	for (i = 0; i < size; i++) {
+	if (strcmp(country_iso_code, translate_custom_table[i].iso_abbrev) == 0) {
+		memcpy(cspec->ccode,  translate_custom_table[i].custom_locale, WLC_CNTRY_BUF_SZ);
+		cspec->rev = translate_custom_table[i].custom_locale_rev;
+		}
+	}
+	return;
+}
diff --git a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_dbg.h b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_dbg.h
index eb89734..007fe2a 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_dbg.h
+++ b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_dbg.h
@@ -21,16 +21,16 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhd_dbg.h,v 1.5.6.2.4.2.14.2.70.1 2010/11/06 00:35:05 Exp $
+ * $Id: dhd_dbg.h,v 1.5.6.2.4.2.14.10 2010/05/21 21:49:38 Exp $
  */
 
 #ifndef _dhd_dbg_
 #define _dhd_dbg_
 
-#if (defined DHD_DEBUG)
-
+#if 0 || (defined DHD_DEBUG)
 #define DHD_ERROR(args)	       do {if ((dhd_msg_level & DHD_ERROR_VAL) && (net_ratelimit())) \
 								printf args;} while (0)
+#define DHD_ERROR(args)		do {if (dhd_msg_level & DHD_ERROR_VAL) printf args;} while (0)
 #define DHD_TRACE(args)		do {if (dhd_msg_level & DHD_TRACE_VAL) printf args;} while (0)
 #define DHD_INFO(args)		do {if (dhd_msg_level & DHD_INFO_VAL) printf args;} while (0)
 #define DHD_DATA(args)		do {if (dhd_msg_level & DHD_DATA_VAL) printf args;} while (0)
diff --git a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_linux.c b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_linux.c
index 86d792e..4ff3d92 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_linux.c
+++ b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_linux.c
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhd_linux.c,v 1.65.4.9.2.12.2.26.4.33.2.13 2010/11/11 04:36:23 Exp $
+ * $Id: dhd_linux.c,v 1.65.4.9.2.12.2.104.4.39 2011/01/14 22:40:45 Exp $
  */
 
 #ifdef CONFIG_WIFI_CONTROL_FUNC
@@ -43,6 +43,8 @@
 #include <linux/ethtool.h>
 #include <linux/fcntl.h>
 #include <linux/fs.h>
+#include <linux/inetdevice.h>
+#include <linux/mutex.h>
 
 #include <asm/uaccess.h>
 #include <asm/unaligned.h>
@@ -57,22 +59,20 @@
 #include <dhd_bus.h>
 #include <dhd_proto.h>
 #include <dhd_dbg.h>
-#ifdef CONFIG_HAS_WAKELOCK
-#include <linux/wakelock.h>
-#endif
-#ifdef CONFIG_CFG80211
-#include <wl_cfg80211.h>
-#endif
-
-
-#ifdef PROP_TXSTATUS
-#include <wlfc_proto.h>
-#include <dhd_wlfc.h>
-#endif
+#include <wl_iw.h>
+/*
+ * NOTE: to enable keep alive, define KEEP_ALIVE here
+ * or in the makefile, also must use -keepalive- firmware
+ * keep_alive needs htodXX(), le/be  macro
+ */
 
-// louislee
-#define alloc_etherdev2(sizeof_priv) \
+/* LGE_CHANGE_S [yoohoo@lge.com] 2009-03-30, change ifname to wlan%d */
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+#undef alloc_etherdev
+#define alloc_etherdev(sizeof_priv) \
 	alloc_netdev(sizeof_priv, "wlan%d", ether_setup)
+#endif /* CONFIG_LGE_BCM432X_PATCH */
+/* LGE_CHANGE_E [yoohoo@lge.com] 2009-03-30, change ifname to wlan%d */
 
 #ifdef CONFIG_WIFI_CONTROL_FUNC
 #if defined(CONFIG_LGE_BCM432X_PATCH)
@@ -210,9 +210,10 @@ void wifi_del_dev(void)
 	DHD_TRACE(("## Unregister platform_driver_register\n"));
 	platform_driver_unregister(&wifi_device);
 }
-#endif /* defined(CONFIG_WIFI_CONTROL_FUNC) */
+#endif /* defined(CUSTOMER_HW2) && defined(CONFIG_WIFI_CONTROL_FUNC) */
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && 1 && defined(CONFIG_PM_SLEEP)
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP)
 #include <linux/suspend.h>
 volatile bool dhd_mmc_suspend = FALSE;
 DECLARE_WAIT_QUEUE_HEAD(dhd_dpc_wait);
@@ -236,11 +237,12 @@ print_tainted()
 /* Linux wireless extension support */
 #if defined(CONFIG_WIRELESS_EXT)
 #include <wl_iw.h>
+extern wl_iw_extra_params_t  g_wl_iw_params;
 #endif /* defined(CONFIG_WIRELESS_EXT) */
 
 #if defined(CONFIG_HAS_EARLYSUSPEND)
 #include <linux/earlysuspend.h>
-extern int dhd_get_dtim_skip(dhd_pub_t *dhd);
+extern int dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len);
 #endif /* defined(CONFIG_HAS_EARLYSUSPEND) */
 
 #ifdef PKT_FILTER_SUPPORT
@@ -261,7 +263,6 @@ typedef struct dhd_if {
 	bool			attached;		/* Delayed attachment when unset */
 	bool			txflowcontrol;	/* Per interface flow control indicator */
 	char			name[IFNAMSIZ+1]; /* linux interface name */
-	uint8			bssidx;			/* bsscfg index for the interface */
 } dhd_if_t;
 
 /* Local private structure (extension of pub) */
@@ -280,52 +281,48 @@ typedef struct dhd_info {
 #else 
 	struct semaphore proto_sem;
 #endif
-
-#ifdef PROP_TXSTATUS
-	spinlock_t	wlfc_spinlock;
-#endif
 	wait_queue_head_t ioctl_resp_wait;
 	struct timer_list timer;
 	bool wd_timer_valid;
 	struct tasklet_struct tasklet;
 	spinlock_t	sdlock;
 	spinlock_t	txqlock;
+	spinlock_t	dhd_lock;
 	/* Thread based operation */
 	bool threads_only;
+
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))     
 	struct mutex sdsem; 
 #else 
 	struct semaphore sdsem;
 #endif
-	long watchdog_pid;
-	struct semaphore watchdog_sem;
-	struct completion watchdog_exited;
-	long dpc_pid;
-	struct semaphore dpc_sem;
-	struct completion dpc_exited;
+//	long watchdog_pid;
+//	struct semaphore watchdog_sem;
+//	struct completion watchdog_exited;
+//	long dpc_pid;
+//	struct semaphore dpc_sem;
+//	struct completion dpc_exited;
 
-	/* Wakelocks */
-#if defined(CONFIG_HAS_WAKELOCK) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
-	struct wake_lock wl_wifi;   /* Wifi wakelock */
-	/* Lin - wl_rxwake is needed for wake_lock_timeout (as wl_wifi may be released) */
-	struct wake_lock wl_rxwake; /* Wifi rx wakelock */
-#endif
-	spinlock_t wakelock_spinlock;
-	int wakelock_counter;
-	int wakelock_timeout_enable;
+/* XXXX andrey: new dhd thread controls */
+        tsk_ctl_t       thr_dpc_ctl;
+        tsk_ctl_t       thr_wdt_ctl;
+        tsk_ctl_t       thr_sysioc_ctl;
+/*      --------------------------  */
 
-	int hang_was_sent;
 
+    int hang_was_sent; /* flag that message was send at least once */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+	struct mutex wl_start_lock; /* mutex when START called to prevent any other Linux calls */
+#endif 
 	/* Thread to issue ioctl for multicast */
-	long sysioc_pid;
-	struct semaphore sysioc_sem;
-	struct completion sysioc_exited;
+//	long sysioc_pid;
+//	struct semaphore sysioc_sem;
+//	struct completion sysioc_exited;
 	bool set_multicast;
 	bool set_macaddress;
 	struct ether_addr macvalue;
 	wait_queue_head_t ctrl_wait;
 	atomic_t pend_8021x_cnt;
-    dhd_attach_states_t dhd_state;
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 	struct early_suspend early_suspend;
@@ -335,25 +332,24 @@ typedef struct dhd_info {
 /* Definitions to provide path to the firmware and nvram
  * example nvram_path[MOD_PARAM_PATHLEN]="/projects/wlan/nvram.txt"
  */
+char firmware_path[MOD_PARAM_PATHLEN];
+char nvram_path[MOD_PARAM_PATHLEN];
 
-/* LGE_CHANGE_S, [WiFi][jaeoh.oh@lge.com], 2011-05-06, modify fw_path */
-char firmware_path[MOD_PARAM_PATHLEN]="/system/etc/wifi/fw_bcm4329.bin"; 
-char nvram_path[MOD_PARAM_PATHLEN]="/system/etc/wifi/nvram.txt";
-/* LGE_CHANGE_E, [WiFi][jaeoh.oh@lge.com], 2011-05-06, modify fw_path */
+
+#if !defined(CONFIG_HAS_EARLYSUSPEND)
+extern int dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len);
+#endif
 
 extern int wl_control_wl_start(struct net_device *dev);
-extern int net_os_send_hang_message(struct net_device *dev);
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 struct semaphore dhd_registration_sem;
-
-#define DHD_REGISTRATION_TIMEOUT  8000  /* msec : allowed time to finished dhd registration */
+#define DHD_REGISTRATION_TIMEOUT  12000  /* msec : allowed time to finished dhd registration */
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
 /* load firmware and/or nvram values from the filesystem */
 module_param_string(firmware_path, firmware_path, MOD_PARAM_PATHLEN, 0);
 module_param_string(nvram_path, nvram_path, MOD_PARAM_PATHLEN, 0);
 /* LGE_CHANGE_S [yoohoo@lge.com] 2009-04-03, configs */
 #if defined(CONFIG_LGE_BCM432X_PATCH)
-extern char config_path[MOD_PARAM_PATHLEN];
 module_param_string(config_path, config_path, MOD_PARAM_PATHLEN, 0);
 #endif /* CONFIG_LGE_BCM432X_PATCH */
 /* LGE_CHANGE_E [yoohoo@lge.com] 2009-04-03, configs */
@@ -369,11 +365,11 @@ module_param(dhd_sysioc, uint, 0);
 uint dhd_watchdog_ms = 10;
 module_param(dhd_watchdog_ms, uint, 0);
 
-#if defined(DHD_DEBUG)
+#ifdef DHD_DEBUG
 /* Console poll interval */
-uint dhd_console_ms = 250;
+uint dhd_console_ms = 0;
 module_param(dhd_console_ms, uint, 0);
-#endif /* defined(DHD_DEBUG) */
+#endif /* DHD_DEBUG */
 
 /* ARP offload agent mode : Enable ARP Host Auto-Reply and ARP Peer Auto-Reply */
 uint dhd_arp_mode = 0xb;
@@ -392,7 +388,14 @@ uint dhd_pkt_filter_init = 0;
 module_param(dhd_pkt_filter_init, uint, 0);
 
 /* Pkt filter mode control */
+// 20101008 byoungwook.baek@lge.com, bug-fix: When LCD turned off, multicast packet is filtered [START]
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+/* Pkt filter deny mode */
+uint dhd_master_mode = FALSE;
+#else
 uint dhd_master_mode = TRUE;
+#endif
+// 20101008 byoungwook.baek@lge.com, bug-fix: When LCD turned off, multicast packet is filtered [END]
 module_param(dhd_master_mode, uint, 1);
 
 /* Watchdog thread priority, -1 to use kernel timer */
@@ -407,15 +410,11 @@ module_param(dhd_dpc_prio, int, 0);
 extern int dhd_dongle_memsize;
 module_param(dhd_dongle_memsize, int, 0);
 
-// louislee : to distinct P2P and SoftAP
-int dhd_use_p2p=0;
-module_param(dhd_use_p2p, int, 0);
-
-/* Control fw roaming */
-#if defined(CONFIG_MACH_MAHIMAHI)
-uint dhd_roam_disable = 0;
+/* Contorl fw roaming */
+#ifdef CUSTOMER_HW2
+uint dhd_roam = 0;
 #else
-uint dhd_roam_disable = 1;
+uint dhd_roam = 1;
 #endif
 
 /* Control radio state */
@@ -457,11 +456,6 @@ module_param(dhd_idletime, int, 0);
 uint dhd_poll = FALSE;
 module_param(dhd_poll, uint, 0);
 
-#ifdef CONFIG_CFG80211
-/* Use cfg80211 */
-uint dhd_cfg80211 = FALSE;
-module_param(dhd_cfg80211, uint, 0);
-#endif
 
 /* Use interrupts */
 uint dhd_intr = TRUE;
@@ -481,6 +475,11 @@ module_param(dhd_rxbound, uint, 0);
 extern uint dhd_deferred_tx;
 module_param(dhd_deferred_tx, uint, 0);
 
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//20110121
+extern bool ap_priv_running;
+int ap_suspend_status;
+struct wake_lock ap_suspend_wake_lock;
+#endif
 
 
 #ifdef SDTEST
@@ -493,12 +492,6 @@ uint dhd_pktgen_len = 0;
 module_param(dhd_pktgen_len, uint, 0);
 #endif
 
-#ifdef CONFIG_CFG80211
-#define FAVORITE_WIFI_CP	(!!dhd_cfg80211)
-#define IS_CFG80211_FAVORITE() FAVORITE_WIFI_CP
-#define DBG_CFG80211_GET() ((dhd_cfg80211 & WL_DBG_MASK) >> 1)
-#define NO_FW_REQ() (dhd_cfg80211 & 0x80)
-#endif
 
 /* Version string to report */
 #ifdef DHD_DEBUG
@@ -533,7 +526,7 @@ static int dhd_toe_set(dhd_info_t *dhd, int idx, uint32 toe_ol);
 static int dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,
                              wl_event_msg_t *event_ptr, void **data_ptr);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && 1 && defined(CONFIG_PM_SLEEP)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP) && 1
 static int dhd_sleep_pm_callback(struct notifier_block *nfb, unsigned long action, void *ignored)
 {
 	int ret = NOTIFY_DONE;
@@ -560,8 +553,8 @@ static struct notifier_block dhd_sleep_pm_notifier = {
 };
 extern int register_pm_notifier(struct notifier_block *nb);
 extern int unregister_pm_notifier(struct notifier_block *nb);
-#endif 
-	/* && defined(CONFIG_PM_SLEEP) */
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP) */
+	/* && defined(DHD_GPL) */
 static void dhd_set_packet_filter(int value, dhd_pub_t *dhd)
 {
 #ifdef PKT_FILTER_SUPPORT
@@ -581,89 +574,120 @@ static void dhd_set_packet_filter(int value, dhd_pub_t *dhd)
 }
 
 
+
 #if defined(CONFIG_HAS_EARLYSUSPEND)
+#if defined(CONFIG_BRCM_LGE_WL_ARPOFFLOAD)	/*Setting dtim.	20110120*/
+extern uint wl_dtim_val;
+#endif
 static int dhd_set_suspend(int value, dhd_pub_t *dhd)
 {
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
-	// bill.jung@lge.com - Don't use legacy power save mode.
-	//int power_mode = PM_MAX;
-	int power_mode = PM_FAST;
+#if 0 //                                                                                               
+	int power_mode = PM_MAX;
 	/* wl_pkt_filter_enable_t	enable_parm; */
-#endif /* !defined(CONFIG_LGE_BCM432X_PATCH) */
 	char iovbuf[32];
 	int bcn_li_dtim = 3;
-#if defined(CONFIG_MACH_MAHIMAHI) && 0 // louislee commented out because use dongle roaming
+#endif
+#if defined(CONFIG_BRCM_LGE_WL_ARPOFFLOAD)	/*Setting dtim.	20110120*/
+	char iovbuf[32];
+	int bcn_li_dtim = 0;
+#endif
+//                                                                                                                                                                 
+#if 1
 	uint roamvar = 1;
-#endif /* CONFIG_MACH_MAHIMAHI */
+	//char iovbuf[32];
+#endif /* if 1 */
 
-	DHD_TRACE(("%s: enter, value = %d in_suspend=%d\n",
+	DHD_TRACE(("%s: enter, value = %d in_suspend=%d\n", \
 	           __FUNCTION__, value, dhd->in_suspend));
 
-	if (dhd && dhd->up) {
+	if (dhd && dhd->up) {  //                                                                                    
+//	if (dhd ) {
 		if (value && dhd->in_suspend) {
+
 				/* Kernel suspended */
 				DHD_TRACE(("%s: force extra Suspend setting \n", __FUNCTION__));
 
+#if 0 //                                                                                               
+				dhdcdc_set_ioctl(dhd, 0, WLC_SET_PM,
+					(char *)&power_mode, sizeof(power_mode));
+#endif
+
 				/* Enable packet filter, only allow unicast packet to send up */
 				dhd_set_packet_filter(1, dhd);
 
-				/* If DTIM skip is set up as default, force it to wake
-				 * each third DTIM for better power savings.  Note that
-				 * one side effect is a chance to miss BC/MC packet.
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//20110121
+				if(ap_priv_running == TRUE)
+					ap_suspend_status = 1;
+#endif
+				/* if dtim skip setup as default force it to wake each thrid dtim
+				 *  for better power saving.
+				 *  Note that side effect is chance to miss BC/MC packet
 				 */
+#if 0 //                                                                                               
 				bcn_li_dtim = dhd_get_dtim_skip(dhd);
 				bcm_mkiovar("bcn_li_dtim", (char *)&bcn_li_dtim,
 					4, iovbuf, sizeof(iovbuf));
-				dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
-
-				dhd_wl_ioctl_cmd(dhd, WLC_SET_PM, (char *)&power_mode,
-				                 sizeof(power_mode), TRUE, 0);
-
-#if defined(CONFIG_MACH_MAHIMAHI) && 0 // louislee commented out because use dongle roaming
-				/* Disable build-in roaming to allowed \
-				* supplicant to take of romaing
-				*/
-				bcm_mkiovar("roam_off", (char *)&roamvar, 4,
+				dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+#endif
+#if defined(CONFIG_BRCM_LGE_WL_ARPOFFLOAD)	/*Setting dtim.	20110120 */
+				bcn_li_dtim = wl_dtim_val;
+				printk("%s:%d wl_dtim_val = %d\n",__func__,__LINE__,wl_dtim_val);
+				if(bcn_li_dtim > 0){
+					bcm_mkiovar("bcn_li_dtim", (char *)&bcn_li_dtim,
+							4, iovbuf, sizeof(iovbuf));
+					dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+				}
+#endif
+//                                                                                                                                                                 
+#if 1
+				/* Disable build-in roaming during suspend */
+				bcm_mkiovar("roam_off", (char *)&roamvar, 4, \
 				            iovbuf, sizeof(iovbuf));
-				dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
-#endif /* CONFIG_MACH_MAHIMAHI */
+				dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+#endif /* if 1 */
 
-#endif /* !defined(CONFIG_LGE_BCM432X_PATCH) */
 			} else {
 
 				/* Kernel resumed  */
 				DHD_TRACE(("%s: Remove extra suspend setting \n", __FUNCTION__));
 
+#if 0 //                                                                                               
+				power_mode = PM_FAST;
+				dhdcdc_set_ioctl(dhd, 0, WLC_SET_PM, (char *)&power_mode,
+					sizeof(power_mode));
+#endif
+
 				/* disable pkt filter */
 				dhd_set_packet_filter(0, dhd);
 
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//20110121
+				if(ap_priv_running == TRUE)
+					ap_suspend_status = 0;
+#endif
+#if 0 //                                                                                               
 				/* restore pre-suspend setting for dtim_skip */
 				bcm_mkiovar("bcn_li_dtim", (char *)&dhd->dtim_skip,
 					4, iovbuf, sizeof(iovbuf));
-				dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
-				DHD_ERROR(("%s: resume bcn_li_dtim = %d\n", __FUNCTION__, dhd->dtim_skip));
-
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
 
-				power_mode = PM_FAST;
-				dhd_wl_ioctl_cmd(dhd, WLC_SET_PM, (char *)&power_mode,
-				                 sizeof(power_mode), TRUE, 0);
+				dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+#endif
+#if defined(CONFIG_BRCM_LGE_WL_ARPOFFLOAD)	/*Setting dtim.	20110120*/
+				bcn_li_dtim = 0;
+				bcm_mkiovar("bcn_li_dtim", (char *)&bcn_li_dtim,
+					4, iovbuf, sizeof(iovbuf));
 
-#if defined(CONFIG_MACH_MAHIMAHI) && 0 // louislee commented out because use dongle roaming
-				roamvar = dhd_roam_disable;
-				bcm_mkiovar("roam_off", (char *)&roamvar, 4, iovbuf,
+				dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+#endif
+//                                                                                                                                                                 
+#if 1
+				roamvar = 0; /* default - roaming enabled */
+				bcm_mkiovar("roam_off", (char *)&roamvar, 4, iovbuf, \
 				            sizeof(iovbuf));
-				dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
-#endif /* CONFIG_MACH_MAHIMAHI */
-
-#endif /* !defined(CONFIG_LGE_BCM432X_PATCH) */
+				dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+#endif /* if 1 */
 			}
 	}
 
-	DHD_ERROR(("%s: exit, value = %d in_suspend=%d\n",
-	           __FUNCTION__, value, dhd->in_suspend));
-
 	return 0;
 }
 
@@ -671,14 +695,12 @@ static void dhd_suspend_resume_helper(struct dhd_info *dhd, int val)
 {
 	dhd_pub_t *dhdp = &dhd->pub;
 
-	DHD_OS_WAKE_LOCK(dhdp);
-	//dhd_os_proto_block(dhdp); // louislee commented out : RC17 lock bug , dhd_prot_ioctl() function already has a lock
+	dhd_os_proto_block(dhdp);
 	/* Set flag when early suspend was called */
 	dhdp->in_suspend = val;
 	if (!dhdp->suspend_disable_flag)
 		dhd_set_suspend(val, dhdp);
-	//dhd_os_proto_unblock(dhdp); // louislee commented out : RC17 lock bug , dhd_prot_ioctl() function already has a lock
-	DHD_OS_WAKE_UNLOCK(dhdp);
+	dhd_os_proto_unblock(dhdp);
 }
 
 static void dhd_early_suspend(struct early_suspend *h)
@@ -818,20 +840,6 @@ dhd_ifname(dhd_pub_t *dhdp, int ifidx)
 	return "<if_none>";
 }
 
-uint8 *
-dhd_bssidx2bssid(dhd_pub_t *dhdp, int idx)
-{
-	int i;
-	dhd_info_t *dhd = (dhd_info_t *)dhdp;
-
-	ASSERT(dhd);
-	for (i = 0; i < DHD_MAX_IFS; i++)
-	if (dhd->iflist[i] && dhd->iflist[i]->bssidx == idx)
-		return dhd->iflist[i]->mac_addr;
-
-	return NULL;
-}
-
 static void
 _dhd_set_multicast_list(dhd_info_t *dhd, int ifidx)
 {
@@ -850,17 +858,14 @@ _dhd_set_multicast_list(dhd_info_t *dhd, int ifidx)
 
 	ASSERT(dhd && dhd->iflist[ifidx]);
 	dev = dhd->iflist[ifidx]->net;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-	netif_addr_lock_bh(dev);
-#endif
+
+	NETIF_ADDR_LOCK(dev);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
 	cnt = netdev_mc_count(dev);
 #else
 	cnt = dev->mc_count;
 #endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-	netif_addr_unlock_bh(dev);
-#endif
+	NETIF_ADDR_UNLOCK(dev);
 
 	/* Determine initial value of allmulti flag */
 	allmulti = (dev->flags & IFF_ALLMULTI) ? TRUE : FALSE;
@@ -882,9 +887,7 @@ _dhd_set_multicast_list(dhd_info_t *dhd, int ifidx)
 	memcpy(bufp, &cnt, sizeof(cnt));
 	bufp += sizeof(cnt);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-	netif_addr_lock_bh(dev);
-#endif
+	NETIF_ADDR_LOCK(dev);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
 	netdev_for_each_mc_addr(ha, dev) {
 		if (!cnt)
@@ -899,21 +902,15 @@ _dhd_set_multicast_list(dhd_info_t *dhd, int ifidx)
 		bufp += ETHER_ADDR_LEN;
 	}
 #endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-	netif_addr_unlock_bh(dev);
-#endif
+	NETIF_ADDR_UNLOCK(dev);
 
 	memset(&ioc, 0, sizeof(ioc));
 	ioc.cmd = WLC_SET_VAR;
 	ioc.buf = buf;
 	ioc.len = buflen;
-#ifdef DONGLEOVERLAYS
-	ioc.action = WL_IOCTL_ACTION_SET;
-#else
 	ioc.set = TRUE;
-#endif
 
-	ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
+	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
 	if (ret < 0) {
 		DHD_ERROR(("%s: set mcast_list failed, cnt %d\n",
 			dhd_ifname(&dhd->pub, ifidx), cnt));
@@ -946,13 +943,9 @@ _dhd_set_multicast_list(dhd_info_t *dhd, int ifidx)
 	ioc.cmd = WLC_SET_VAR;
 	ioc.buf = buf;
 	ioc.len = buflen;
-#ifdef DONGLEOVERLAYS
-	ioc.action = WL_IOCTL_ACTION_SET;
-#else
 	ioc.set = TRUE;
-#endif
 
-	ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
+	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
 	if (ret < 0) {
 		DHD_ERROR(("%s: set allmulti %d failed\n",
 		           dhd_ifname(&dhd->pub, ifidx), ltoh32(allmulti)));
@@ -969,13 +962,9 @@ _dhd_set_multicast_list(dhd_info_t *dhd, int ifidx)
 	ioc.cmd = WLC_SET_PROMISC;
 	ioc.buf = &allmulti;
 	ioc.len = sizeof(allmulti);
-#ifdef DONGLEOVERLAYS
-	ioc.action = WL_IOCTL_ACTION_SET;
-#else
 	ioc.set = TRUE;
-#endif
 
-	ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
+	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
 	if (ret < 0) {
 		DHD_ERROR(("%s: set promisc %d failed\n",
 		           dhd_ifname(&dhd->pub, ifidx), ltoh32(allmulti)));
@@ -990,6 +979,7 @@ _dhd_set_mac_address(dhd_info_t *dhd, int ifidx, struct ether_addr *addr)
 	wl_ioctl_t ioc;
 	int ret;
 
+	DHD_TRACE(("%s enter\n", __FUNCTION__));
 	if (!bcm_mkiovar("cur_etheraddr", (char*)addr, ETHER_ADDR_LEN, buf, 32)) {
 		DHD_ERROR(("%s: mkiovar failed for cur_etheraddr\n", dhd_ifname(&dhd->pub, ifidx)));
 		return -1;
@@ -998,13 +988,9 @@ _dhd_set_mac_address(dhd_info_t *dhd, int ifidx, struct ether_addr *addr)
 	ioc.cmd = WLC_SET_VAR;
 	ioc.buf = buf;
 	ioc.len = 32;
-#ifdef DONGLEOVERLAYS
-	ioc.action = WL_IOCTL_ACTION_SET;
-#else
 	ioc.set = TRUE;
-#endif
 
-	ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
+	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
 	if (ret < 0) {
 		DHD_ERROR(("%s: set cur_etheraddr failed\n", dhd_ifname(&dhd->pub, ifidx)));
 	} else {
@@ -1016,6 +1002,8 @@ _dhd_set_mac_address(dhd_info_t *dhd, int ifidx, struct ether_addr *addr)
 
 #ifdef SOFTAP
 extern struct net_device *ap_net_dev;
+extern tsk_ctl_t ap_eth_ctl; /* ap netdev heper thread ctl */
+//extern struct semaphore ap_eth_sema;
 #endif
 
 static void
@@ -1023,12 +1011,15 @@ dhd_op_if(dhd_if_t *ifp)
 {
 	dhd_info_t	*dhd;
 	int			ret = 0, err = 0;
+#ifdef SOFTAP
+	unsigned long flags;
+#endif
 
 	ASSERT(ifp && ifp->info && ifp->idx);	/* Virtual interfaces only */
 
 	dhd = ifp->info;
 
-	DHD_TRACE(("%s: idx %d, state %d\n", __FUNCTION__, ifp->idx, ifp->state));
+	DHD_ERROR(("%s: idx %d, state %d\n", __FUNCTION__, ifp->idx, ifp->state));
 
 	switch (ifp->state) {
 	case WLC_E_IF_ADD:
@@ -1058,19 +1049,17 @@ dhd_op_if(dhd_if_t *ifp)
 			} else {
 #ifdef SOFTAP
 				 /* semaphore that the soft AP CODE waits on */
-				extern struct semaphore  ap_eth_sema;
+				flags = dhd_os_spin_lock(&dhd->pub);
 				
-#if defined(WLP2P) // louislee
-				if(!dhd_use_p2p) { // louislee : P2P
-#endif /* defined(WLP2P) */
 					/* save ptr to wl0.1 netdev for use in wl_iw.c  */
 					ap_net_dev = ifp->net;
 					 /* signal to the SOFTAP 'sleeper' thread, wl0.1 is ready */
-					up(&ap_eth_sema);
-#if defined(WLP2P) // louislee
-				} // louislee : P2P
-#endif /* defined(WLP2P) */
-
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//20110121
+				if(ap_priv_running == TRUE)
+#endif
+				//up(&ap_eth_sema);
+                                up(&ap_eth_ctl.sema);
+				dhd_os_spin_unlock(&dhd->pub, flags);
 #endif
 				DHD_TRACE(("\n ==== pid:%x, net_device for if:%s created ===\n\n",
 					current->pid, ifp->net->name));
@@ -1082,6 +1071,7 @@ dhd_op_if(dhd_if_t *ifp)
 		if (ifp->net != NULL) {
 			DHD_TRACE(("\n%s: got 'WLC_E_IF_DEL' state\n", __FUNCTION__));
 			netif_stop_queue(ifp->net);
+			unregister_netdev(ifp->net);
 			ret = DHD_DEL_IF;	/* Make sure the free_netdev() is called */
 		}
 		break;
@@ -1093,14 +1083,15 @@ dhd_op_if(dhd_if_t *ifp)
 
 	if (ret < 0) {
 		if (ifp->net) {
-			unregister_netdev(ifp->net);
 			free_netdev(ifp->net);
 		}
 		dhd->iflist[ifp->idx] = NULL;
 		MFREE(dhd->pub.osh, ifp, sizeof(*ifp));
 #ifdef SOFTAP
+		flags = dhd_os_spin_lock(&dhd->pub);
 		if (ifp->net == ap_net_dev)
 			ap_net_dev = NULL;   /*  NULL  SOFTAP global wl0.1 as well */
+		dhd_os_spin_unlock(&dhd->pub, flags);
 #endif /*  SOFTAP */
 	}
 }
@@ -1108,20 +1099,38 @@ dhd_op_if(dhd_if_t *ifp)
 static int
 _dhd_sysioc_thread(void *data)
 {
-	dhd_info_t *dhd = (dhd_info_t *)data;
+	tsk_ctl_t *tsk = (tsk_ctl_t *)data;
+	dhd_info_t *dhd = (dhd_info_t *)tsk->parent;
+
+//	dhd_info_t *dhd = (dhd_info_t *)data;
 	int i;
 #ifdef SOFTAP
 	bool in_ap = FALSE;
+	unsigned long flags;
 #endif
 
 	DAEMONIZE("dhd_sysioc");
 
-	while (down_interruptible(&dhd->sysioc_sem) == 0) {
-		DHD_OS_WAKE_LOCK(&dhd->pub);
+	complete(&tsk->completed);
+
+	while (down_interruptible(&tsk->sema) == 0) {
+
+		SMP_RD_BARRIER_DEPENDS();
+		if (tsk->terminated) {
+			break;
+		}
+		
+//	while (down_interruptible(&dhd->sysioc_sem) == 0) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+		dhd_os_start_lock(&dhd->pub);
+#endif 
 		for (i = 0; i < DHD_MAX_IFS; i++) {
 			if (dhd->iflist[i]) {
+				DHD_TRACE(("%s: interface %d\n", __FUNCTION__, i));
 #ifdef SOFTAP
+				flags = dhd_os_spin_lock(&dhd->pub);
 				in_ap = (ap_net_dev != NULL);
+				dhd_os_spin_unlock(&dhd->pub, flags);
 #endif /* SOFTAP */
 				if (dhd->iflist[i]->state)
 					dhd_op_if(dhd->iflist[i]);
@@ -1156,9 +1165,13 @@ _dhd_sysioc_thread(void *data)
 				}
 			}
 		}
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+		dhd_os_start_unlock(&dhd->pub);
+#endif 
 	}
-	complete_and_exit(&dhd->sysioc_exited, 0);
+	DHD_TRACE(("%s: stopped\n", __FUNCTION__));
+//	complete_and_exit(&dhd->sysioc_exited, 0);
+	complete_and_exit(&tsk->completed, 0);
 }
 
 static int
@@ -1174,11 +1187,12 @@ dhd_set_mac_address(struct net_device *dev, void *addr)
 	if (ifidx == DHD_BAD_IF)
 		return -1;
 
-	ASSERT(dhd->sysioc_pid >= 0);
+//	ASSERT(dhd->sysioc_pid >= 0);
+        ASSERT(&dhd->thr_sysioc_ctl.thr_pid >= 0);
 	memcpy(&dhd->macvalue, sa->sa_data, ETHER_ADDR_LEN);
 	dhd->set_macaddress = TRUE;
-	up(&dhd->sysioc_sem);
-
+//	up(&dhd->sysioc_sem);
+        up(&dhd->thr_sysioc_ctl.sema);
 	return ret;
 }
 
@@ -1192,53 +1206,29 @@ dhd_set_multicast_list(struct net_device *dev)
 	if (ifidx == DHD_BAD_IF)
 		return;
 
-	ASSERT(dhd->sysioc_pid >= 0);
-	dhd->set_multicast = TRUE;
-	up(&dhd->sysioc_sem);
-}
-
-#ifdef PROP_TXSTATUS
-int
-dhd_os_wlfc_block(dhd_pub_t *pub)
-{
-	dhd_info_t *di = (dhd_info_t *)(pub->info);
-	ASSERT(di != NULL);
-	spin_lock_bh(&di->wlfc_spinlock);
-	return 1;
-}
+//	ASSERT(dhd->sysioc_pid >= 0);
+        ASSERT(&dhd->thr_sysioc_ctl.thr_pid >= 0);
 
-int
-dhd_os_wlfc_unblock(dhd_pub_t *pub)
-{
-	dhd_info_t *di = (dhd_info_t *)(pub->info);
-	ASSERT(di != NULL);
-	spin_unlock_bh(&di->wlfc_spinlock);
-	return 1;
+	dhd->set_multicast = TRUE;
+        up(&dhd->thr_sysioc_ctl.sema);
+//	up(&dhd->sysioc_sem);
 }
 
-const uint8 wme_fifo2ac[] = { 0, 1, 2, 3, 1, 1 };
-uint8 prio2fifo[8] = { 1, 0, 0, 1, 2, 2, 3, 3 };
-#define WME_PRIO2AC(prio)	wme_fifo2ac[prio2fifo[(prio)]]
-
-#endif /* PROP_TXSTATUS */
 int
 dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pktbuf)
 {
 	int ret;
 	dhd_info_t *dhd = (dhd_info_t *)(dhdp->info);
-	struct ether_header *eh = NULL;
 
 	/* Reject if down */
 	if (!dhdp->up || (dhdp->busstate == DHD_BUS_DOWN)) {
-		/* free the packet here since the caller won't */
-		PKTFREE(dhdp->osh, pktbuf, TRUE);
 		return -ENODEV;
 	}
 
 	/* Update multicast statistic */
 	if (PKTLEN(dhdp->osh, pktbuf) >= ETHER_ADDR_LEN) {
 		uint8 *pktdata = (uint8 *)PKTDATA(dhdp->osh, pktbuf);
-		eh = (struct ether_header *)pktdata;
+		struct ether_header *eh = (struct ether_header *)pktdata;
 
 		if (ETHER_ISMULTI(eh->ether_dhost))
 			dhdp->tx_multicast++;
@@ -1250,46 +1240,15 @@ dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pktbuf)
 	if ((PKTPRIO(pktbuf) == 0))
 		pktsetprio(pktbuf, FALSE);
 
-#ifdef PROP_TXSTATUS
-	/* store the interface ID */
-	DHD_PKTTAG_SETIF(PKTTAG(pktbuf), ifidx);
-
-	/* store destination MAC in the tag as well */
-	DHD_PKTTAG_SETDSTN(PKTTAG(pktbuf), eh->ether_dhost);
-
-	/* decide which FIFO this packet belongs to */
-	if (ETHER_ISMULTI(eh->ether_dhost))
-		/* one additional queue index (highest AC + 1) is used for bc/mc queue */
-		DHD_PKTTAG_SETFIFO(PKTTAG(pktbuf), AC_COUNT);
-	else
-		DHD_PKTTAG_SETFIFO(PKTTAG(pktbuf), WME_PRIO2AC(PKTPRIO(pktbuf)));
-#else
 	/* If the protocol uses a data header, apply it */
 	dhd_prot_hdrpush(dhdp, ifidx, pktbuf);
-#endif /* PROP_TXSTATUS */
 
 	/* Use bus module to send data frame */
 #ifdef BCMDBUS
 	ret = dbus_send_pkt(dhdp->dbus, pktbuf, NULL /* pktinfo */);
 #else
-#ifdef PROP_TXSTATUS
-	if (((athost_wl_status_info_t*)dhdp->wlfc_state)->proptxstatus_mode != WLFC_FCMODE_NONE) {
-		dhd_os_wlfc_block(dhdp);
-		ret = dhd_wlfc_enque_sendq(dhdp->wlfc_state, DHD_PKTTAG_FIFO(PKTTAG(pktbuf)),
-			pktbuf);
-		dhd_wlfc_commit_packets(dhdp->wlfc_state,  (f_commitpkt_t)dhd_bus_txdata,
-			dhdp->bus);
-		if (((athost_wl_status_info_t*)dhdp->wlfc_state)->toggle_host_if) {
-			((athost_wl_status_info_t*)dhdp->wlfc_state)->toggle_host_if = 0;
-		}
-		dhd_os_wlfc_unblock(dhdp);
-	}
-	else
-		/* non-proptxstatus way */
-		ret = dhd_bus_txdata(dhdp->bus, pktbuf);
-#else
+	WAKE_LOCK_TIMEOUT(dhdp, WAKE_LOCK_TMOUT, 25);
 	ret = dhd_bus_txdata(dhdp->bus, pktbuf);
-#endif /* PROP_TXSTATUS */
 #endif /* BCMDBUS */
 
 	return ret;
@@ -1305,8 +1264,6 @@ dhd_start_xmit(struct sk_buff *skb, struct net_device *net)
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-	DHD_OS_WAKE_LOCK(&dhd->pub);
-
 	/* Reject if down */
 	if (!dhd->pub.up || (dhd->pub.busstate == DHD_BUS_DOWN)) {
 		DHD_ERROR(("%s: xmit rejected pub.up=%d busstate=%d \n",
@@ -1314,10 +1271,9 @@ dhd_start_xmit(struct sk_buff *skb, struct net_device *net)
 		netif_stop_queue(net);
 		/* Send Event when bus down detected during data session */
 		if (dhd->pub.busstate == DHD_BUS_DOWN)  {
-			DHD_ERROR(("%s: Event HANG send up\n", __FUNCTION__));
+			DHD_ERROR(("%s: Event RELOAD send up\n", __FUNCTION__));
 			net_os_send_hang_message(net);
 		}
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
 		return -ENODEV;
 	}
 
@@ -1325,7 +1281,6 @@ dhd_start_xmit(struct sk_buff *skb, struct net_device *net)
 	if (ifidx == DHD_BAD_IF) {
 		DHD_ERROR(("%s: bad ifidx %d\n", __FUNCTION__, ifidx));
 		netif_stop_queue(net);
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
 		return -ENODEV;
 	}
 
@@ -1364,8 +1319,6 @@ done:
 	else
 		dhd->pub.tx_packets++;
 
-	DHD_OS_WAKE_UNLOCK(&dhd->pub);
-
 	/* Return ok: we always eat the packet */
 	return 0;
 }
@@ -1409,18 +1362,6 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt)
 		PKTSETNEXT(wl->sh.osh, pktbuf, NULL);
 
 
-#ifdef PROP_TXSTATUS
-		if (PKTLEN(wl->sh.osh, pktbuf) == 0) {
-			/* WLFC may send header only packet when
-			there is an urgent message but no packet to
-			piggy-back on
-			*/
-			((athost_wl_status_info_t*)dhdp->wlfc_state)->stats.wlfc_header_only_pkt++;
-			PKTFREE(dhdp->osh, pktbuf, TRUE);
-			continue;
-		}
-#endif
-
 		skb = PKTTONATIVE(dhdp->osh, pktbuf);
 
 		/* Get the protocol, maintain skb around eth_type_trans()
@@ -1494,7 +1435,6 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt)
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0) */
 		}
 	}
-	DHD_OS_WAKE_LOCK_TIMEOUT_ENABLE(dhdp);
 }
 
 void
@@ -1558,7 +1498,11 @@ dhd_get_stats(struct net_device *net)
 static int
 dhd_watchdog_thread(void *data)
 {
-	dhd_info_t *dhd = (dhd_info_t *)data;
+
+	tsk_ctl_t *tsk = (tsk_ctl_t *)data;
+	dhd_info_t *dhd = (dhd_info_t *)tsk->parent;
+//	dhd_info_t *dhd = (dhd_info_t *)data;
+	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_WATCHDOG, "dhd_watchdog_thread");
 
 	/* This thread doesn't need any user-level access,
 	 * so get rid of all our resources
@@ -1575,26 +1519,41 @@ dhd_watchdog_thread(void *data)
 	DAEMONIZE("dhd_watchdog");
 
 	/* Run until signal received */
+	complete(&tsk->completed);
+
 	while (1) {
-		if (down_interruptible (&dhd->watchdog_sem) == 0) {
+//		if (down_interruptible (&dhd->watchdog_sem) == 0) {
+		if (down_interruptible (&tsk->sema) == 0) {
+
+			SMP_RD_BARRIER_DEPENDS();
+			if (tsk->terminated) {
+				break;
+			}
+
+			dhd_os_sdlock(&dhd->pub);
 			if (dhd->pub.dongle_reset == FALSE) {
+				DHD_TIMER(("%s:\n", __FUNCTION__));
+				WAKE_LOCK(&dhd->pub, WAKE_LOCK_WATCHDOG);
 				/* Call the bus module watchdog */
 				dhd_bus_watchdog(&dhd->pub);
-			}
+
 			/* Count the tick for reference */
 			dhd->pub.tickcnt++;
-
 			/* Reschedule the watchdog */
-			if (dhd->wd_timer_valid) {
-				mod_timer(&dhd->timer, jiffies + dhd_watchdog_ms * HZ / 1000);
-			}
-			DHD_OS_WAKE_UNLOCK(&dhd->pub);
+				if (dhd->wd_timer_valid)
+					mod_timer(&dhd->timer, \
+							  jiffies + dhd_watchdog_ms * HZ / 1000);
+				WAKE_UNLOCK(&dhd->pub, WAKE_LOCK_WATCHDOG);
 		}
-		else
+			dhd_os_sdunlock(&dhd->pub);
+		} else {
 			break;
 	}
+	}
 
-	complete_and_exit(&dhd->watchdog_exited, 0);
+	WAKE_LOCK_DESTROY(&dhd->pub, WAKE_LOCK_WATCHDOG);
+		complete_and_exit(&tsk->completed, 0);
+//	complete_and_exit(&dhd->watchdog_exited, 0);
 }
 
 static void
@@ -1602,12 +1561,21 @@ dhd_watchdog(ulong data)
 {
 	dhd_info_t *dhd = (dhd_info_t *)data;
 
-	DHD_OS_WAKE_LOCK(&dhd->pub);
+	if (dhd->pub.dongle_reset) {
+		return;
+	}
+#if 0
 	if (dhd->watchdog_pid >= 0) {
 		up(&dhd->watchdog_sem);
 		return;
 	}
-
+#else
+        if (dhd->thr_wdt_ctl.thr_pid >= 0) {
+                up(&dhd->thr_wdt_ctl.sema);
+                return;
+        }
+#endif
+	dhd_os_sdlock(&dhd->pub);
 	/* Call the bus module watchdog */
 	dhd_bus_watchdog(&dhd->pub);
 
@@ -1617,14 +1585,26 @@ dhd_watchdog(ulong data)
 	/* Reschedule the watchdog */
 	if (dhd->wd_timer_valid)
 		mod_timer(&dhd->timer, jiffies + dhd_watchdog_ms * HZ / 1000);
-	DHD_OS_WAKE_UNLOCK(&dhd->pub);
+	dhd_os_sdunlock(&dhd->pub);
 }
 
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//htclk fail patch
+extern int ht_err_cnt;
+void htclk_fail_reset(void *bus);
+#endif
 static int
 dhd_dpc_thread(void *data)
 {
-	dhd_info_t *dhd = (dhd_info_t *)data;
+	tsk_ctl_t *tsk = (tsk_ctl_t *)data;
+	dhd_info_t *dhd = (dhd_info_t *)tsk->parent;
+//	dhd_info_t *dhd = (dhd_info_t *)data;
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//htclk fail patch
+	int reset_flag = FALSE;
+
+reset:
+#endif
 
+	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_DPC, "dhd_dpc_thread");
 	/* This thread doesn't need any user-level access,
 	 * so get rid of all our resources
 	 */
@@ -1638,29 +1618,63 @@ dhd_dpc_thread(void *data)
 #endif /* DHD_SCHED */
 
 	DAEMONIZE("dhd_dpc");
-	/* DHD_OS_WAKE_LOCK is called in dhd_sched_dpc[dhd_linux.c] down below */
 
+	/*  signal: thread has started */
+	complete(&tsk->completed);
 	/* Run until signal received */
 	while (1) {
-		if (down_interruptible(&dhd->dpc_sem) == 0) {
+//		if (down_interruptible(&dhd->dpc_sem) == 0) {
+		if (down_interruptible(&tsk->sema) == 0) {
+
+			SMP_RD_BARRIER_DEPENDS();
+			if (tsk->terminated) {
+				break;
+			}
+
 			/* Call bus dpc unless it indicated down (then clean stop) */
 			if (dhd->pub.busstate != DHD_BUS_DOWN) {
+				WAKE_LOCK(&dhd->pub, WAKE_LOCK_DPC);
 				if (dhd_bus_dpc(dhd->pub.bus)) {
-					up(&dhd->dpc_sem);
-				}
-				else {
-					DHD_OS_WAKE_UNLOCK(&dhd->pub);
+//					up(&dhd->dpc_sem);
+					up(&dhd->thr_dpc_ctl.sema);
+					WAKE_LOCK_TIMEOUT(&dhd->pub, WAKE_LOCK_TMOUT, 25);
 				}
+				WAKE_UNLOCK(&dhd->pub, WAKE_LOCK_DPC);
 			} else {
 				dhd_bus_stop(dhd->pub.bus, TRUE);
-				DHD_OS_WAKE_UNLOCK(&dhd->pub);
 			}
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//htclk fail patch
+			if(ht_err_cnt > 10)
+			{
+				printk("%s:%d\n",__func__,__LINE__);
+				reset_flag = TRUE;
+				break;
+			}
+#endif
 		}
 		else
 			break;
 	}
 
-	complete_and_exit(&dhd->dpc_exited, 0);
+	WAKE_LOCK_DESTROY(&dhd->pub, WAKE_LOCK_DPC);
+
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//htclk fail patch
+	if(reset_flag == TRUE)
+	{
+		printk("%s:%d : htclk_fail_reset call\n",__func__,__LINE__);
+		
+		htclk_fail_reset((void*)dhd);
+		reset_flag = FALSE;
+
+		ht_err_cnt = 0;
+//		init_completion(&dhd->dpc_exited);
+//		dhd->dpc_pid = kernel_thread(dhd_dpc_thread, dhd, 0);
+		mdelay(500);
+		goto reset;
+	}
+#endif
+//	complete_and_exit(&dhd->dpc_exited, 0);
+	complete_and_exit(&tsk->completed, 0);
 }
 
 static void
@@ -1670,19 +1684,12 @@ dhd_dpc(ulong data)
 
 	dhd = (dhd_info_t *)data;
 
-	/* this (tasklet) can be scheduled in dhd_sched_dpc[dhd_linux.c]
-	 * down below , wake lock is set,
-	 * the tasklet is initialized in dhd_attach()
-	 */
 	/* Call bus dpc unless it indicated down (then clean stop) */
 	if (dhd->pub.busstate != DHD_BUS_DOWN) {
 		if (dhd_bus_dpc(dhd->pub.bus))
 			tasklet_schedule(&dhd->tasklet);
-		else
-			DHD_OS_WAKE_UNLOCK(&dhd->pub); /* Added by Lin, google doesn't have this */
 	} else {
 		dhd_bus_stop(dhd->pub.bus, TRUE);
-		DHD_OS_WAKE_UNLOCK(&dhd->pub); /* Added by Lin, google doesn't have this */
 	}
 }
 
@@ -1690,12 +1697,19 @@ void
 dhd_sched_dpc(dhd_pub_t *dhdp)
 {
 	dhd_info_t *dhd = (dhd_info_t *)dhdp->info;
-
-	DHD_OS_WAKE_LOCK(dhdp);
+#if 0
 	if (dhd->dpc_pid >= 0) {
 		up(&dhd->dpc_sem);
 		return;
 	}
+#else
+
+        if (dhd->thr_dpc_ctl.thr_pid >= 0) {
+                up(&dhd->thr_dpc_ctl.sema);
+                return;
+        }
+
+#endif
 
 	tasklet_schedule(&dhd->tasklet);
 }
@@ -1714,14 +1728,10 @@ dhd_toe_get(dhd_info_t *dhd, int ifidx, uint32 *toe_ol)
 	ioc.cmd = WLC_GET_VAR;
 	ioc.buf = buf;
 	ioc.len = (uint)sizeof(buf);
-#ifdef DONGLEOVERLAYS
-	ioc.action = WL_IOCTL_ACTION_GET;
-#else
 	ioc.set = FALSE;
-#endif
 
 	strcpy(buf, "toe_ol");
-	if ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {
+	if ((ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {
 		/* Check for older dongle image that doesn't support toe_ol */
 		if (ret == -EIO) {
 			DHD_ERROR(("%s: toe not supported by device\n",
@@ -1750,18 +1760,14 @@ dhd_toe_set(dhd_info_t *dhd, int ifidx, uint32 toe_ol)
 	ioc.cmd = WLC_SET_VAR;
 	ioc.buf = buf;
 	ioc.len = (uint)sizeof(buf);
-#ifdef DONGLEOVERLAYS
-	ioc.action = WL_IOCTL_ACTION_SET;
-#else
 	ioc.set = TRUE;
-#endif
 
 	/* Set toe_ol as requested */
 
 	strcpy(buf, "toe_ol");
 	memcpy(&buf[sizeof("toe_ol")], &toe_ol, sizeof(uint32));
 
-	if ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {
+	if ((ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {
 		DHD_ERROR(("%s: could not set toe_ol: ret=%d\n",
 			dhd_ifname(&dhd->pub, ifidx), ret));
 		return ret;
@@ -1774,7 +1780,7 @@ dhd_toe_set(dhd_info_t *dhd, int ifidx, uint32 toe_ol)
 	strcpy(buf, "toe");
 	memcpy(&buf[sizeof("toe")], &toe, sizeof(uint32));
 
-	if ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {
+	if ((ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {
 		DHD_ERROR(("%s: could not set toe: ret=%d\n", dhd_ifname(&dhd->pub, ifidx), ret));
 		return ret;
 	}
@@ -1919,41 +1925,29 @@ dhd_ioctl_entry(struct net_device *net, struct ifreq *ifr, int cmd)
 	void *buf = NULL;
 	uint driver = 0;
 	int ifidx;
-	bool is_tx_queue_flush_required;
-	int ret;
-
-	DHD_OS_WAKE_LOCK(&dhd->pub);
+	bool is_set_key_cmd;
 
 	ifidx = dhd_net2idx(dhd, net);
 	DHD_TRACE(("%s: ifidx %d, cmd 0x%04x\n", __FUNCTION__, ifidx, cmd));
 
-	if (ifidx == DHD_BAD_IF) {
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
+	if (ifidx == DHD_BAD_IF)
 		return -1;
-	}
 
 #if defined(CONFIG_WIRELESS_EXT)
 	/* linux wireless extensions */
 	if ((cmd >= SIOCIWFIRST) && (cmd <= SIOCIWLAST)) {
 		/* may recurse, do NOT lock */
-		ret = wl_iw_ioctl(net, ifr, cmd);
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
-		return ret;
+		return wl_iw_ioctl(net, ifr, cmd);
 	}
 #endif /* defined(CONFIG_WIRELESS_EXT) */
 
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 4, 2)
-	if (cmd == SIOCETHTOOL) {
-		ret = dhd_ethtool(dhd, (void*)ifr->ifr_data);
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
-		return ret;
-	}
+	if (cmd == SIOCETHTOOL)
+		return (dhd_ethtool(dhd, (void*)ifr->ifr_data));
 #endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 4, 2) */
 
-	if (cmd != SIOCDEVPRIVATE) {
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
+	if (cmd != SIOCDEVPRIVATE)
 		return -EOPNOTSUPP;
-	}
 
 	memset(&ioc, 0, sizeof(ioc));
 
@@ -2018,29 +2012,29 @@ dhd_ioctl_entry(struct net_device *net, struct ifreq *ifr, int cmd)
 	}
 
 	/* Intercept WLC_SET_KEY IOCTL - serialize M4 send and set key IOCTL to
-	 * prevent M4 encryption and
-	 * intercept WLC_DISASSOC IOCTL - serialize WPS-DONE and WLC_DISASSOC IOCTL to
-	 * prevent disassoc frame being sent before WPS-DONE frame.
+	 * prevent M4 encryption.
 	 */
-	is_tx_queue_flush_required = ((ioc.cmd == WLC_SET_KEY) ||
+	is_set_key_cmd = ((ioc.cmd == WLC_SET_KEY) ||
 	                 ((ioc.cmd == WLC_SET_VAR) &&
 	                        !(strncmp("wsec_key", ioc.buf, 9))) ||
 	                 ((ioc.cmd == WLC_SET_VAR) &&
-	                        !(strncmp("bsscfg:wsec_key", ioc.buf, 15))) ||
-	                 ((ioc.cmd == WLC_DISASSOC)));
-	if (is_tx_queue_flush_required) {
+	                        !(strncmp("bsscfg:wsec_key", ioc.buf, 15))));
+	if (is_set_key_cmd) {
 		dhd_wait_pend8021x(net);
 	}
+	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_IOCTL, "dhd_ioctl_entry");
+	WAKE_LOCK(&dhd->pub, WAKE_LOCK_IOCTL);
 
-	bcmerror = dhd_wl_ioctl(&dhd->pub, ifidx, (wl_ioctl_t *)&ioc, buf, buflen);
+	bcmerror = dhd_prot_ioctl(&dhd->pub, ifidx, (wl_ioctl_t *)&ioc, buf, buflen);
 
-done:
-	if ((bcmerror == -ETIMEDOUT) || ((dhd->pub.busstate == DHD_BUS_DOWN) &&
+	WAKE_UNLOCK(&dhd->pub, WAKE_LOCK_IOCTL);
+	WAKE_LOCK_DESTROY(&dhd->pub, WAKE_LOCK_IOCTL);
+	if ((bcmerror == -ETIMEDOUT) || ((dhd->pub.busstate == DHD_BUS_DOWN) && \
 		(!dhd->pub.dongle_reset))) {
 		DHD_ERROR(("%s: Event HANG send up\n", __FUNCTION__));
 		net_os_send_hang_message(net);
 	}
-
+done:
 	if (!bcmerror && buf && ioc.buf) {
 		if (copy_to_user(ioc.buf, buf, buflen))
 			bcmerror = -EFAULT;
@@ -2049,8 +2043,6 @@ done:
 	if (buf)
 		MFREE(dhd->pub.osh, buf, buflen);
 
-	DHD_OS_WAKE_UNLOCK(&dhd->pub);
-
 	return OSL_ERROR(bcmerror);
 }
 
@@ -2060,19 +2052,11 @@ dhd_stop(struct net_device *net)
 #if !defined(IGNORE_ETH0_DOWN)
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(net);
 
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
-#ifdef CONFIG_CFG80211
-	if (IS_CFG80211_FAVORITE()) {
-		wl_cfg80211_down();
-	}
-#endif
+	DHD_TRACE(("%s: Enter %s\n", __FUNCTION__, net->name));
 	if (dhd->pub.up == 0) {
 		return 0;
 	}
 
-#ifdef PROP_TXSTATUS
-	dhd_wlfc_cleanup(&dhd->pub);
-#endif
 	/* Set state and stop OS transmissions */
 	dhd->pub.up = 0;
 	netif_stop_queue(net);
@@ -2091,20 +2075,21 @@ dhd_open(struct net_device *net)
 #ifdef TOE
 	uint32 toe_ol;
 #endif
-	int ifidx = 0;
+	int ifidx;
 	int32 ret = 0;
 
 	/*  Force start if ifconfig_up gets called before START command */
 	wl_control_wl_start(net);
 
 	ifidx = dhd_net2idx(dhd, net);
-	DHD_TRACE(("%s: ifidx %d\n", __FUNCTION__, ifidx));
 
-	if ((ifidx != DHD_BAD_IF) && (dhd->iflist[ifidx] != NULL) && (dhd->iflist[ifidx]->state == WLC_E_IF_DEL)) {
+	DHD_TRACE(("%s: ifidx %d\n", __FUNCTION__, ifidx));
+/*
+	if ((dhd->iflist[ifidx]) && (dhd->iflist[ifidx]->state == WLC_E_IF_DEL)) {
 		DHD_ERROR(("%s: Error: called when IF already deleted\n", __FUNCTION__));
 		return -1;
 	}
-
+*/
 	if (ifidx == 0) { /* do it only for primary eth0 */
 
 	atomic_set(&dhd->pend_8021x_cnt, 0);
@@ -2122,14 +2107,7 @@ dhd_open(struct net_device *net)
 	/* Allow transmit calls */
 	netif_start_queue(net);
 	dhd->pub.up = 1;
-#ifdef CONFIG_CFG80211
-	if (IS_CFG80211_FAVORITE()) {
-		if (unlikely(wl_cfg80211_up())) {
-			DHD_ERROR(("%s: failed to bring up cfg80211\n", __FUNCTION__));
-			return -1;
-		}
-	}
-#endif
+
 
 	OLD_MOD_INC_USE_COUNT;
 	return ret;
@@ -2148,9 +2126,9 @@ dhd_osl_detach(osl_t *osh)
 		DHD_ERROR(("%s: MEMORY LEAK %d bytes\n", __FUNCTION__, MALLOCED(osh)));
 	}
 	osl_detach(osh);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && 1
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 	up(&dhd_registration_sem);
-#endif 
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
 }
 
 int
@@ -2163,14 +2141,7 @@ dhd_add_if(dhd_info_t *dhd, int ifidx, void *handle, char *name,
 	ASSERT(dhd && (ifidx < DHD_MAX_IFS));
 
 	ifp = dhd->iflist[ifidx];
-	if (ifp != NULL) {
-		if (ifp->net != NULL) {
-			netif_stop_queue(ifp->net);
-			unregister_netdev(ifp->net);
-			free_netdev(ifp->net);
-		}
-	} else
-		if ((ifp = MALLOC(dhd->pub.osh, sizeof(dhd_if_t))) == NULL) {
+	if (!ifp && !(ifp = MALLOC(dhd->pub.osh, sizeof(dhd_if_t)))) {
 			DHD_ERROR(("%s: OOM - dhd_if_t\n", __FUNCTION__));
 			return -ENOMEM;
 		}
@@ -2186,9 +2157,10 @@ dhd_add_if(dhd_info_t *dhd, int ifidx, void *handle, char *name,
 	if (handle == NULL) {
 		ifp->state = WLC_E_IF_ADD;
 		ifp->idx = ifidx;
-		ifp->bssidx = bssidx;
-		ASSERT(dhd->sysioc_pid >= 0);
-		up(&dhd->sysioc_sem);
+//		ASSERT(dhd->sysioc_pid >= 0);
+//		up(&dhd->sysioc_sem);
+                ASSERT(&dhd->thr_sysioc_ctl.thr_pid >= 0);
+                up(&dhd->thr_sysioc_ctl.sema);
 	} else
 		ifp->net = (struct net_device *)handle;
 
@@ -2211,9 +2183,27 @@ dhd_del_if(dhd_info_t *dhd, int ifidx)
 
 	ifp->state = WLC_E_IF_DEL;
 	ifp->idx = ifidx;
-	ASSERT(dhd->sysioc_pid >= 0);
-	up(&dhd->sysioc_sem);
+//	ASSERT(dhd->sysioc_pid >= 0);
+//	up(&dhd->sysioc_sem);
+        ASSERT(&dhd->thr_sysioc_ctl.thr_pid >= 0);
+	up(&dhd->thr_sysioc_ctl.sema);
+}
+
+#if defined(CONFIG_LGE_BCM432X_PATCH)		//by sjpark 11-02-01
+struct net_device *g_net_dev;
+#endif
+
+#if 1	//reset work around 11-01-26
+void
+dhd_del_softap_if(struct net_device *dev)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
+	
+	dhd_del_if(dhd, 1);
 }
+#endif
 
 dhd_pub_t *
 dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
@@ -2221,9 +2211,7 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 	dhd_info_t *dhd = NULL;
 	struct net_device *net;
 
-	dhd_attach_states_t dhd_state = DHD_ATTACH_STATE_INIT;
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
-
 	/* updates firmware nvram path if it was provided as module paramters */
 	if ((firmware_path != NULL) && (firmware_path[0] != '\0'))
 		strcpy(fw_path, firmware_path);
@@ -2231,37 +2219,25 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 		strcpy(nv_path, nvram_path);
 
 	/* Allocate etherdev, including space for private structure */
-	// louislee : alloc_etherdev -> alloc_etherdev2
-	if (!(net = alloc_etherdev2(sizeof(dhd)))) {
+	if (!(net = alloc_etherdev(sizeof(dhd)))) {
 		DHD_ERROR(("%s: OOM - alloc_etherdev\n", __FUNCTION__));
 		goto fail;
 	}
-	dhd_state |= DHD_ATTACH_STATE_NET_ALLOC;
 
 	/* Allocate primary dhd_info */
 	if (!(dhd = MALLOC(osh, sizeof(dhd_info_t)))) {
 		DHD_ERROR(("%s: OOM - alloc dhd_info\n", __FUNCTION__));
 		goto fail;
 	}
-	memset(dhd, 0, sizeof(dhd_info_t));
 
-	dhd->dpc_pid = DHD_PID_KT_TL_INVALID;
-	dhd->watchdog_pid = DHD_PID_KT_INVALID;
-	dhd->sysioc_pid = DHD_PID_KT_INVALID;
-	dhd_state |= DHD_ATTACH_STATE_DHD_ALLOC;
+	memset(dhd, 0, sizeof(dhd_info_t));
 
 	/*
 	 * Save the dhd_info into the priv
 	 */
-	memcpy((void *)netdev_priv(net), &dhd, sizeof(dhd));
+	memcpy(netdev_priv(net), &dhd, sizeof(dhd));
 	dhd->pub.osh = osh;
 
-	/* Link to info module */
-	dhd->pub.info = dhd;
-	/* Link to bus module */
-	dhd->pub.bus = bus;
-	dhd->pub.hdrlen = bus_hdrlen;
-
 	/* Set network interface name if it was provided as module parameter */
 	if (iface_name[0]) {
 		int len;
@@ -2276,21 +2252,18 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 
 	if (dhd_add_if(dhd, 0, (void *)net, net->name, NULL, 0, 0) == DHD_BAD_IF)
 		goto fail;
-	dhd_state |= DHD_ATTACH_STATE_ADD_IF;
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31))
 	net->open = NULL;
-	#else
+#else
 		net->netdev_ops = NULL;
-	#endif
-#ifndef init_MUTEX
-	mutex_init( &dhd->proto_sem );
+#endif
+	
+#if (LINUX_VERSION_CODE >=  KERNEL_VERSION(2, 6, 38))
+	mutex_init(&dhd->proto_sem); 
 #else
 	init_MUTEX(&dhd->proto_sem);
 #endif
-#ifdef PROP_TXSTATUS
-	spin_lock_init(&dhd->wlfc_spinlock);
-#endif
 	/* Initialize other structure content */
 	init_waitqueue_head(&dhd->ioctl_resp_wait);
 	init_waitqueue_head(&dhd->ctrl_wait);
@@ -2298,48 +2271,30 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 	/* Initialize the spinlocks */
 	spin_lock_init(&dhd->sdlock);
 	spin_lock_init(&dhd->txqlock);
-
-	/* Initialize Wakelock stuff */
-	spin_lock_init(&dhd->wakelock_spinlock);
-	dhd->wakelock_counter = 0;
-	dhd->wakelock_timeout_enable = 0;
-#ifdef CONFIG_HAS_WAKELOCK
-	wake_lock_init(&dhd->wl_wifi, WAKE_LOCK_SUSPEND, "wlan_wake");
-	wake_lock_init(&dhd->wl_rxwake, WAKE_LOCK_SUSPEND, "wlan_rx_wake");
+	spin_lock_init(&dhd->dhd_lock);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+	mutex_init(&dhd->wl_start_lock);
 #endif
-	dhd_state |= DHD_ATTACH_STATE_WAKELOCKS_INIT;
+	/* Link to info module */
+	dhd->pub.info = dhd;
+
+	/* Link to bus module */
+	dhd->pub.bus = bus;
+	dhd->pub.hdrlen = bus_hdrlen;
 
 	/* Attach and link in the protocol */
 	if (dhd_prot_attach(&dhd->pub) != 0) {
 		DHD_ERROR(("dhd_prot_attach failed\n"));
 		goto fail;
 	}
-	dhd_state |= DHD_ATTACH_STATE_PROT_ATTACH;
-
 #if defined(CONFIG_WIRELESS_EXT)
 	/* Attach and link in the iw */
 	if (wl_iw_attach(net, (void *)&dhd->pub) != 0) {
 		DHD_ERROR(("wl_iw_attach failed\n"));
 		goto fail;
 	}
-	dhd_state |= DHD_ATTACH_STATE_WL_ATTACH;
 #endif /* defined(CONFIG_WIRELESS_EXT) */
 
-#ifdef CONFIG_CFG80211
-		/* Attach and link in the cfg80211 */
-	if (IS_CFG80211_FAVORITE()) {
-		if (unlikely(wl_cfg80211_attach(net, &dhd->pub))) {
-			DHD_ERROR(("wl_cfg80211_attach failed\n"));
-			goto fail;
-		}
-		if (!NO_FW_REQ()) {
-			strcpy(fw_path, wl_cfg80211_get_fwname());
-			strcpy(nv_path, wl_cfg80211_get_nvramname());
-		}
-		wl_cfg80211_dbg_level(DBG_CFG80211_GET());
-	}
-	dhd_state |= DHD_ATTACH_STATE_CFG80211;
-#endif
 
 	/* Set up the watchdog timer */
 	init_timer(&dhd->timer);
@@ -2347,7 +2302,7 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 	dhd->timer.function = dhd_watchdog;
 
 	/* Initialize thread based operation and lock */
-#ifndef init_MUTEX
+#if (LINUX_VERSION_CODE >=  KERNEL_VERSION(2, 6, 38))
 	mutex_init(&dhd->sdsem);
 #else
 	init_MUTEX(&dhd->sdsem);
@@ -2361,68 +2316,86 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 
 	if (dhd_dpc_prio >= 0) {
 		/* Initialize watchdog thread */
+#if 0	//hyeok-test
 		sema_init(&dhd->watchdog_sem, 0);
 		init_completion(&dhd->watchdog_exited);
 		dhd->watchdog_pid = kernel_thread(dhd_watchdog_thread, dhd, 0);
+#else
+		PROC_START(dhd_watchdog_thread, dhd, &dhd->thr_wdt_ctl, 0);
+#endif
 	} else {
-		dhd->watchdog_pid = -1;
+	//	dhd->watchdog_pid = -1;
+		dhd->thr_wdt_ctl.thr_pid = -1;
 	}
 
 	/* Set up the bottom half handler */
 	if (dhd_dpc_prio >= 0) {
 		/* Initialize DPC thread */
+#if 0
 		sema_init(&dhd->dpc_sem, 0);
 		init_completion(&dhd->dpc_exited);
 		dhd->dpc_pid = kernel_thread(dhd_dpc_thread, dhd, 0);
+#else
+		PROC_START(dhd_dpc_thread, dhd, &dhd->thr_dpc_ctl, 0);
+#endif
 	} else {
 		tasklet_init(&dhd->tasklet, dhd_dpc, (ulong)dhd);
-		dhd->dpc_pid = -1;
+//		dhd->dpc_pid = -1;
+                dhd->thr_dpc_ctl.thr_pid = -1;
+
 	}
 
 	if (dhd_sysioc) {
+#if 0
 		sema_init(&dhd->sysioc_sem, 0);
 		init_completion(&dhd->sysioc_exited);
 		dhd->sysioc_pid = kernel_thread(_dhd_sysioc_thread, dhd, 0);
+#else
+		PROC_START(_dhd_sysioc_thread, dhd, &dhd->thr_sysioc_ctl, 0);
+#endif
 	} else {
-		dhd->sysioc_pid = -1;
+		//dhd->sysioc_pid = -1;
+		dhd->thr_sysioc_ctl.thr_pid = -1;
 	}
-	dhd_state |= DHD_ATTACH_STATE_THREADS_CREATED;
 
 	/*
 	 * Save the dhd_info into the priv
 	 */
 	memcpy(netdev_priv(net), &dhd, sizeof(dhd));
 
-#ifdef CONFIG_WIFI_CONTROL_FUNC
+#if defined(CONFIG_LGE_BCM432X_PATCH)		//by sjpark 11-02-01
+	if(net)
+		g_net_dev = net;
+#endif
+
+#if defined(CONFIG_WIFI_CONTROL_FUNC)
 	g_bus = bus;
 #endif
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && 1 && defined(CONFIG_PM_SLEEP)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP) && 1
 	register_pm_notifier(&dhd_sleep_pm_notifier);
+#endif /*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP) */
+	/* && defined(DHD_GPL) */
+	/* Init lock suspend to prevent kernel going to suspend */
+	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_TMOUT, "dhd_wake_lock");
+	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_LINK_DOWN_TMOUT, "dhd_wake_lock_link_dw_event");
+	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_PNO_FIND_TMOUT, "dhd_wake_lock_link_pno_find_event");
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//20110121
+	wake_lock_init(&ap_suspend_wake_lock,WAKE_LOCK_SUSPEND,"ap_suspend_wake_lock");
 #endif 
-	/* && defined(CONFIG_PM_SLEEP) */
-
 #ifdef CONFIG_HAS_EARLYSUSPEND
 	dhd->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 20;
 	dhd->early_suspend.suspend = dhd_early_suspend;
 	dhd->early_suspend.resume = dhd_late_resume;
 	register_early_suspend(&dhd->early_suspend);
-	dhd_state |= DHD_ATTACH_STATE_EARLYSUSPEND_DONE;
 #endif
-	dhd_state |= DHD_ATTACH_STATE_DONE;
-	dhd->dhd_state = dhd_state;
+
 	return &dhd->pub;
 
 fail:
-	if (dhd_state < DHD_ATTACH_STATE_DHD_ALLOC) {
 	if (net)
 		free_netdev(net);
-	}
-	else {
-		DHD_TRACE(("%s: Calling dhd_detach dhd_state 0x%x &dhd->pub 0x%x\n",
-			__FUNCTION__, dhd_state, (unsigned)&dhd->pub));
-		dhd->dhd_state = dhd_state;
+	if (dhd)
 		dhd_detach(&dhd->pub);
-	}
 
 	return NULL;
 }
@@ -2442,13 +2415,19 @@ dhd_bus_start(dhd_pub_t *dhdp)
 
 	/* try to download image and nvram to the dongle */
 	if  (dhd->pub.busstate == DHD_BUS_DOWN) {
-		/* wake lock moved to dhdsdio_download_firmware */
+		WAKE_LOCK_INIT(dhdp, WAKE_LOCK_DOWNLOAD, "dhd_bus_start");
+		WAKE_LOCK(dhdp, WAKE_LOCK_DOWNLOAD);
 		if (!(dhd_bus_download_firmware(dhd->pub.bus, dhd->pub.osh,
 		                                fw_path, nv_path))) {
 			DHD_ERROR(("%s: dhdsdio_probe_download failed. firmware = %s nvram = %s\n",
 			           __FUNCTION__, fw_path, nv_path));
+			WAKE_UNLOCK(dhdp, WAKE_LOCK_DOWNLOAD);
+			WAKE_LOCK_DESTROY(dhdp, WAKE_LOCK_DOWNLOAD);
 			return -1;
 		}
+
+		WAKE_UNLOCK(dhdp, WAKE_LOCK_DOWNLOAD);
+		WAKE_LOCK_DESTROY(dhdp, WAKE_LOCK_DOWNLOAD);
 	}
 
 	/* Start the watchdog timer */
@@ -2463,9 +2442,8 @@ dhd_bus_start(dhd_pub_t *dhdp)
 #if defined(OOB_INTR_ONLY)
 	/* Host registration for OOB interrupt */
 	if (bcmsdh_register_oob_intr(dhdp)) {
-		/* deactivate a timer and wait for the handler to finish */
-		del_timer_sync(&dhd->timer);
 		dhd->wd_timer_valid = FALSE;
+		del_timer_sync(&dhd->timer);
 		DHD_ERROR(("%s Host failed to resgister for OOB\n", __FUNCTION__));
 		return -ENODEV;
 	}
@@ -2476,15 +2454,15 @@ dhd_bus_start(dhd_pub_t *dhdp)
 
 	/* If bus is not ready, can't come up */
 	if (dhd->pub.busstate != DHD_BUS_DATA) {
-		del_timer_sync(&dhd->timer);
 		dhd->wd_timer_valid = FALSE;
+		del_timer_sync(&dhd->timer);
 		DHD_ERROR(("%s failed bus is not ready\n", __FUNCTION__));
 		return -ENODEV;
 	}
 
 #ifdef EMBEDDED_PLATFORM
 	bcm_mkiovar("event_msgs", dhdp->eventmask, WL_EVENTING_MASK_LEN, iovbuf, sizeof(iovbuf));
-	dhd_wl_ioctl_cmd(dhdp, WLC_GET_VAR, iovbuf, sizeof(iovbuf), FALSE, 0);
+	dhdcdc_query_ioctl(dhdp, 0, WLC_GET_VAR, iovbuf, sizeof(iovbuf));
 	bcopy(iovbuf, dhdp->eventmask, WL_EVENTING_MASK_LEN);
 
 	setbit(dhdp->eventmask, WLC_E_SET_SSID);
@@ -2505,21 +2483,25 @@ dhd_bus_start(dhd_pub_t *dhdp)
 	setbit(dhdp->eventmask, WLC_E_TXFAIL);
 	setbit(dhdp->eventmask, WLC_E_JOIN_START);
 	setbit(dhdp->eventmask, WLC_E_SCAN_COMPLETE);
+	setbit(dhdp->eventmask, WLC_E_RELOAD);
 #ifdef PNO_SUPPORT
 	setbit(dhdp->eventmask, WLC_E_PFN_NET_FOUND);
 #endif /* PNO_SUPPORT */
 
 /* enable dongle roaming event */
-	setbit(dhdp->eventmask, WLC_E_ROAM);
+//	setbit(dhdp->eventmask, WLC_E_ROAM);
 
 	dhdp->pktfilter_count = 1;
-#ifdef FILTER_BROADCAST_ONLY
-	/* Setup filter to allow only unicast */
-	dhdp->pktfilter[0] = "100 1 0 0 0xFF 0xFF";
+
+// 20101008 byoungwook.baek@lge.com, bug-fix: When LCD turned off, multicast packet is filtered [START]
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+	/* Setup filter to deny only broadcast */
+	dhdp->pktfilter[0] = "100 0 0 0 0xff 0xff";
 #else
 	/* Setup filter to allow only unicast */
 	dhdp->pktfilter[0] = "100 0 0 0 0x01 0x00";
 #endif
+// 20101008 byoungwook.baek@lge.com, bug-fix: When LCD turned off, multicast packet is filtered [END]
 
 #endif /* EMBEDDED_PLATFORM */
 
@@ -2545,13 +2527,9 @@ dhd_iovar(dhd_pub_t *pub, int ifidx, char *name, char *cmd_buf, uint cmd_len, in
 	ioc.cmd = set? WLC_SET_VAR : WLC_GET_VAR;
 	ioc.buf = buf;
 	ioc.len = len;
-#ifdef DONGLEOVERLAYS
-	ioc.action = WL_IOCTL_ACTION_SET;
-#else
-	ioc.set = TRUE;
-#endif
+	ioc.set = set;
 
-	ret = dhd_wl_ioctl(pub, ifidx, &ioc, ioc.buf, ioc.len);
+	ret = dhd_prot_ioctl(pub, ifidx, &ioc, ioc.buf, ioc.len);
 	if (!set && ret >= 0)
 		memcpy(cmd_buf, buf, cmd_len);
 
@@ -2566,31 +2544,29 @@ static struct net_device_ops dhd_ops_pri = {
 	.ndo_do_ioctl = dhd_ioctl_entry,
 	.ndo_start_xmit = dhd_start_xmit,
 	.ndo_set_mac_address = dhd_set_mac_address,
-	.ndo_set_multicast_list = dhd_set_multicast_list,
-	};
+	.ndo_set_multicast_list = dhd_set_multicast_list
+};
 
 static struct net_device_ops dhd_ops_virt = {
 	.ndo_get_stats = dhd_get_stats,
 	.ndo_do_ioctl = dhd_ioctl_entry,
 	.ndo_start_xmit = dhd_start_xmit,
 	.ndo_set_mac_address = dhd_set_mac_address,
-	.ndo_set_multicast_list = dhd_set_multicast_list,
-	};
+	.ndo_set_multicast_list = dhd_set_multicast_list
+};
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31)) */
-
 int
 dhd_net_attach(dhd_pub_t *dhdp, int ifidx)
 {
 	dhd_info_t *dhd = (dhd_info_t *)dhdp->info;
 	struct net_device *net;
-	int err = 0;
 	uint8 temp_addr[ETHER_ADDR_LEN] = { 0x00, 0x90, 0x4c, 0x11, 0x22, 0x33 };
 
 	DHD_TRACE(("%s: ifidx %d\n", __FUNCTION__, ifidx));
 
 	ASSERT(dhd && dhd->iflist[ifidx]);
-	net = dhd->iflist[ifidx]->net;
 
+	net = dhd->iflist[ifidx]->net;
 	ASSERT(net);
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31))
@@ -2606,27 +2582,27 @@ dhd_net_attach(dhd_pub_t *dhdp, int ifidx)
 	net->netdev_ops = &dhd_ops_virt;
 #endif
 
-	/* Ok, link into the network layer... */
-	if (ifidx == 0) {
-		/*
-		 * device functions for the primary interface only
-		 */
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31))
 		net->open = dhd_open;
 		net->stop = dhd_stop;
 #else
 		net->netdev_ops = &dhd_ops_pri;
 #endif
-	} else {
+
 		/*
 		 * We have to use the primary MAC for virtual interfaces
 		 */
-		memcpy(temp_addr, dhd->iflist[ifidx]->mac_addr, ETHER_ADDR_LEN);
+	if (ifidx != 0) {
+		/* for virtual interfaces use the primary MAC  */
+		memcpy(temp_addr, dhd->pub.mac.octet, ETHER_ADDR_LEN);
+
+	}
+
 		if (ifidx == 1) {
 			DHD_TRACE(("%s ACCESS POINT MAC: \n", __FUNCTION__));
 			/*  ACCESSPOINT INTERFACE CASE */
-			temp_addr[0] |= 0x02;  /* set bit 2 , - Locally Administered address  */
-		}
+		temp_addr[0] |= 0X02;  /* set bit 2 , - Locally Administered address  */
+
 	}
 	net->hard_header_len = ETH_HLEN + dhd->pub.hdrlen;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
@@ -2634,26 +2610,21 @@ dhd_net_attach(dhd_pub_t *dhdp, int ifidx)
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24) */
 
 #if defined(CONFIG_WIRELESS_EXT)
-#if defined(CONFIG_CFG80211)
-	if (!IS_CFG80211_FAVORITE()) {
-#endif
 #if WIRELESS_EXT < 19
 	net->get_wireless_stats = dhd_get_wireless_stats;
 #endif /* WIRELESS_EXT < 19 */
 #if WIRELESS_EXT > 12
 	net->wireless_handlers = (struct iw_handler_def *)&wl_iw_handler_def;
 #endif /* WIRELESS_EXT > 12 */
-#if defined(CONFIG_CFG80211)
-	}
-#endif
 #endif /* defined(CONFIG_WIRELESS_EXT) */
 
+
 	dhd->pub.rxsz = net->mtu + net->hard_header_len + dhd->pub.hdrlen;
 
 	memcpy(net->dev_addr, temp_addr, ETHER_ADDR_LEN);
 
-	if ((err = register_netdev(net)) != 0) {
-		DHD_ERROR(("couldn't register the net device, err %d\n", err));
+	if (register_netdev(net) != 0) {
+		DHD_ERROR(("%s: couldn't register the net device\n", __FUNCTION__));
 		goto fail;
 	}
 
@@ -2661,7 +2632,8 @@ dhd_net_attach(dhd_pub_t *dhdp, int ifidx)
 		dhd->pub.mac.octet[0], dhd->pub.mac.octet[1], dhd->pub.mac.octet[2],
 		dhd->pub.mac.octet[3], dhd->pub.mac.octet[4], dhd->pub.mac.octet[5]);
 
-#if defined(CONFIG_WIRELESS_EXT) && 0
+#if defined(CONFIG_WIRELESS_EXT)
+#if defined(CONFIG_FIRST_SCAN)
 #ifdef SOFTAP
 	if (ifidx == 0)
 		/* Don't call for SOFTAP Interface in SOFTAP MODE */
@@ -2669,6 +2641,7 @@ dhd_net_attach(dhd_pub_t *dhdp, int ifidx)
 #else
 		wl_iw_iscan_set_scan_broadcast_prep(net, 1);
 #endif /* SOFTAP */
+#endif /* CONFIG_FIRST_SCAN */
 #endif /* CONFIG_WIRELESS_EXT */
 
 
@@ -2706,8 +2679,8 @@ dhd_bus_detach(dhd_pub_t *dhdp)
 #endif /* defined(OOB_INTR_ONLY) */
 
 			/* Clear the watchdog timer */
-			del_timer_sync(&dhd->timer);
 			dhd->wd_timer_valid = FALSE;
+			del_timer_sync(&dhd->timer);
 		}
 	}
 }
@@ -2717,54 +2690,44 @@ dhd_detach(dhd_pub_t *dhdp)
 {
 	dhd_info_t *dhd;
 
-	if (!dhdp)
-		return;
-	dhd = (dhd_info_t *)dhdp->info;
-	if (!dhd)
-		return;
-
-	DHD_TRACE(("%s: Enter state 0x%x\n", __FUNCTION__, dhd->dhd_state));
+	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-	if (!(dhd->dhd_state & DHD_ATTACH_STATE_DONE)) {
-		/* Give sufficient time for threads to start running in case
-		 * dhd_attach() has failed
-		 */
-		osl_delay(1000*100);
-	}
+	if (dhdp) {
+		dhd = (dhd_info_t *)dhdp->info;
+		if (dhd) {
+			dhd_if_t *ifp;
+			int i;
 
 #if defined(CONFIG_HAS_EARLYSUSPEND)
-	if (dhd->dhd_state & DHD_ATTACH_STATE_EARLYSUSPEND_DONE)	{
 		if (dhd->early_suspend.suspend)
 			unregister_early_suspend(&dhd->early_suspend);
-	}
 #endif	/* defined(CONFIG_HAS_EARLYSUSPEND) */
 
-
 #if defined(CONFIG_WIRELESS_EXT)
-	if (dhd->dhd_state & DHD_ATTACH_STATE_WL_ATTACH) {
-		/* Attach and link in the iw */
 		wl_iw_detach();
-	}
-#endif
+#endif     /* (CONFIG_WIRELESS_EXT) */
 
-	if (dhd->dhd_state & DHD_ATTACH_STATE_ADD_IF) {
-		int i;
-			for (i = 1; i < DHD_MAX_IFS; i++)
-				if (dhd->iflist[i])
-					dhd_del_if(dhd, i);
-	}
 
-	if (dhd->dhd_state & DHD_ATTACH_STATE_THREADS_CREATED) {
-		if (dhd->sysioc_pid >= 0) {
+//			if (dhd->sysioc_pid >= 0) {
+                if(&dhd->thr_sysioc_ctl.thr_pid >= 0){ 
+#if 0
 			KILL_PROC(dhd->sysioc_pid, SIGTERM);
 			wait_for_completion(&dhd->sysioc_exited);
+#else
+				PROC_STOP(&dhd->thr_sysioc_ctl); 
+#endif
 		}
+
+			for (i = 1; i < DHD_MAX_IFS; i++)
+				if (dhd->iflist[i]) {
+					dhd->iflist[i]->state = WLC_E_IF_DEL;
+					dhd->iflist[i]->idx = i;
+					dhd_op_if(dhd->iflist[i]);
 	}
 
-	if (dhd->dhd_state & DHD_ATTACH_STATE_ADD_IF) {
-		dhd_if_t *ifp;
+
 			ifp = dhd->iflist[0];
-		// ASSERT(ifp); /* ifp can not be NULL if we are in this state */
+			ASSERT(ifp);
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31))
 			if (ifp->net->open) {
 #else
@@ -2774,9 +2737,8 @@ dhd_detach(dhd_pub_t *dhdp)
 			unregister_netdev(ifp->net);
 		}
 
-	}
 
-	if (dhd->dhd_state & DHD_ATTACH_STATE_THREADS_CREATED) {
+#if 0
 		if (dhd->watchdog_pid >= 0)
 		{
 			KILL_PROC(dhd->watchdog_pid, SIGTERM);
@@ -2788,67 +2750,79 @@ dhd_detach(dhd_pub_t *dhdp)
 			KILL_PROC(dhd->dpc_pid, SIGTERM);
 			wait_for_completion(&dhd->dpc_exited);
 		}
-		else if (dhd->dpc_pid == -1)
+		else
 			tasklet_kill(&dhd->tasklet);
+#else
+
+                if (dhd->thr_wdt_ctl.thr_pid >= 0)
+                {
+                        PROC_STOP(&dhd->thr_wdt_ctl);
+                }
 
+                if (dhd->thr_dpc_ctl.thr_pid >= 0)
+                {
+                        PROC_STOP(&dhd->thr_dpc_ctl);
 		}
-	if (dhd->dhd_state & DHD_ATTACH_STATE_PROT_ATTACH) {
+                else
+                tasklet_kill(&dhd->tasklet);
+#endif
+
+
+
 		dhd_bus_detach(dhdp);
 
 		if (dhdp->prot)
 			dhd_prot_detach(dhdp);
-	}
-#ifdef CONFIG_CFG80211
-	if (dhd->dhd_state & DHD_ATTACH_STATE_CFG80211) {
-		if (IS_CFG80211_FAVORITE()) {
-			wl_cfg80211_detach();
-		}
-	}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP) && 1
+		unregister_pm_notifier(&dhd_sleep_pm_notifier);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP) */
+	/* && defined(DHD_GPL) */
+		WAKE_LOCK_DESTROY(dhdp, WAKE_LOCK_TMOUT);
+		WAKE_LOCK_DESTROY(dhdp, WAKE_LOCK_LINK_DOWN_TMOUT);
+		WAKE_LOCK_DESTROY(dhdp, WAKE_LOCK_PNO_FIND_TMOUT);
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//20110121
+		wake_lock_destroy(&ap_suspend_wake_lock);
 #endif
-	if (dhd->dhd_state & DHD_ATTACH_STATE_ADD_IF) {
-		dhd_if_t *ifp;
-		ifp = dhd->iflist[0];
 		free_netdev(ifp->net);
 		MFREE(dhd->pub.osh, ifp, sizeof(*ifp));
-	}
-	if (dhd->dhd_state & DHD_ATTACH_STATE_WAKELOCKS_INIT)
-	{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && 1 && defined(CONFIG_PM_SLEEP)
-		unregister_pm_notifier(&dhd_sleep_pm_notifier);
-#endif 
-	/* && defined(CONFIG_PM_SLEEP) */
-	#ifdef CONFIG_HAS_WAKELOCK
-		wake_lock_destroy(&dhd->wl_wifi);
-		wake_lock_destroy(&dhd->wl_rxwake);
-	#endif
-	}
-}
-
-void
-dhd_free(dhd_pub_t *dhdp)
-{
-	dhd_info_t *dhd;
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
-
-	if (dhdp) {
-		dhd = (dhd_info_t *)dhdp->info;
-		if (dhd)
 			MFREE(dhd->pub.osh, dhd, sizeof(*dhd));
 	}
 }
-
+}
 static void __exit
 dhd_module_cleanup(void)
 {
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
 	dhd_bus_unregister();
-#ifdef CONFIG_WIFI_CONTROL_FUNC
+#if defined(CONFIG_WIFI_CONTROL_FUNC)
 	wifi_del_dev();
 #endif
 	/* Call customer gpio to turn off power with WL_REG_ON signal */
 	dhd_customer_gpio_wlan_ctrl(WLAN_POWER_OFF);
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+	mdelay(500);
+#endif
+}
+
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+#include <linux/mm.h>
+/* check free memory at physical pool */
+int check_low_mem(unsigned int kbytes )
+{
+	struct sysinfo i;
+	si_meminfo(&i);
+#define __KBYTE(x) (((x) << (PAGE_SHIFT - 10)))
+
+	if( kbytes > __KBYTE(i.freeram))
+	{
+		printk("Low memory --> MemFree :     %8lukB\n", __KBYTE(i.freeram));
+		return -1; /* opps */	
+	}
+	return 0; /* ok go */
 }
+#endif	/* CONFIG_LGE_BCM432X_PATCH */
 
 static int __init
 dhd_module_init(void)
@@ -2857,6 +2831,12 @@ dhd_module_init(void)
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+	if(check_low_mem(1536/*1.5MBytes*/)){
+		return -ENOMEM;
+	}
+#endif	/* CONFIG_LGE_BCM432X_PATCH */
+
 	/* Sanity check on the module parameters */
 	do {
 		/* Both watchdog and DPC as tasklets are ok */
@@ -2867,30 +2847,29 @@ dhd_module_init(void)
 		if ((dhd_watchdog_prio >= 0) && (dhd_dpc_prio >= 0) && dhd_deferred_tx)
 			break;
 
-		printk("Invalid module parameters.\n");
+		DHD_ERROR(("Invalid module parameters.\n"));
 		return -EINVAL;
 	} while (0);
-
 	/* Call customer gpio to turn on power with WL_REG_ON signal */
 	dhd_customer_gpio_wlan_ctrl(WLAN_POWER_ON);
 
-#ifdef CONFIG_WIFI_CONTROL_FUNC
+#if defined(CONFIG_WIFI_CONTROL_FUNC)
 	sema_init(&wifi_control_sem, 0);
 
-	/* Added fail_0, fail_1 to do the right clean-up for failure case */
 	error = wifi_add_dev();
 	if (error) {
 		DHD_ERROR(("%s: platform_driver_register failed\n", __FUNCTION__));
-		goto fail_0;
+		goto faild;
 	}
 
 	/* Waiting callback after platform_driver_register is done or exit with error */
-	if (down_timeout(&wifi_control_sem,  msecs_to_jiffies(1000)) != 0) {
-		error = -EINVAL;
+	if (down_timeout(&wifi_control_sem,  msecs_to_jiffies(5000)) != 0) {
 		printk("%s: platform_driver_register timeout\n", __FUNCTION__);
-		goto fail_1;
+		/* renove device */
+		wifi_del_dev();
+		goto faild;
 	}
-#endif
+#endif /* #if defined(CUSTOMER_HW2) && defined(CONFIG_WIFI_CONTROL_FUNC) */
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 	sema_init(&dhd_registration_sem, 0);
@@ -2902,7 +2881,7 @@ dhd_module_init(void)
 		printf("\n%s\n", dhd_version);
 	else {
 		DHD_ERROR(("%s: sdio_register_driver failed\n", __FUNCTION__));
-		goto fail_1;
+		goto faild;
 	}
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 	/*
@@ -2913,24 +2892,16 @@ dhd_module_init(void)
 	if (down_timeout(&dhd_registration_sem,  msecs_to_jiffies(DHD_REGISTRATION_TIMEOUT)) != 0) {
 		error = -EINVAL;
 		DHD_ERROR(("%s: sdio_register_driver timeout\n", __FUNCTION__));
-		goto fail_2;
+		dhd_bus_unregister();
+		goto faild;
 	}
 #endif
 	return error;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && 1
-fail_2:
-	dhd_bus_unregister();
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
-fail_1:
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-	wifi_del_dev();
-fail_0:
-#endif
 
-	/* Call customer gpio to turn off power with WL_REG_ON signal */
+faild:
+	/* turn off power and exit */
 	dhd_customer_gpio_wlan_ctrl(WLAN_POWER_OFF);
-
-	return error;
+	return -EINVAL;
 }
 
 module_init(dhd_module_init);
@@ -2993,20 +2964,11 @@ dhd_os_ioctl_resp_wait(dhd_pub_t *pub, uint *condition, bool *pending)
 	int timeout = dhd_ioctl_timeout_msec;
 
 	/* Convert timeout in millsecond to jiffies */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
-	timeout = msecs_to_jiffies(timeout);
-#else
 	timeout = timeout * HZ / 1000;
-#endif
 
 	/* Wait until control frame is available */
 	add_wait_queue(&dhd->ioctl_resp_wait, &wait);
 	set_current_state(TASK_INTERRUPTIBLE);
-	/* Memory barrier to support multi-processing 
-	 * As the variable "condition", which points to dhd->rxlen (dhd_bus_rxctl[dhd_sdio.c])
-	 * Can be changed by another processor.
-	 */
-
 	smp_mb();
 	while (!(*condition) && (!signal_pending(current) && timeout)) {
 		timeout = schedule_timeout(timeout);
@@ -3038,44 +3000,29 @@ void
 dhd_os_wd_timer(void *bus, uint wdtick)
 {
 	dhd_pub_t *pub = bus;
-	static uint save_dhd_watchdog_ms = 0;
 	dhd_info_t *dhd = (dhd_info_t *)pub->info;
+	unsigned long flags;
+	int del_timer_flag = FALSE;
 
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
+	flags = dhd_os_spin_lock(pub);
 
-	/* don't start the wd until fw is loaded */
-	if (pub->busstate == DHD_BUS_DOWN)
-		return;
-
-	/* Totally stop the timer */
-	if (!wdtick && dhd->wd_timer_valid == TRUE) {
-		del_timer_sync(&dhd->timer);
-		dhd->wd_timer_valid = FALSE;
-		save_dhd_watchdog_ms = wdtick;
-		return;
-	}
 
+	/* don't start the wd until fw is loaded */
+	if (pub->busstate != DHD_BUS_DOWN) {
 	if (wdtick) {
 		dhd_watchdog_ms = (uint)wdtick;
-		if (save_dhd_watchdog_ms != dhd_watchdog_ms) {
-
-			if (dhd->wd_timer_valid == TRUE)
-				/* Stop timer and restart at new value */
-				del_timer_sync(&dhd->timer);
-
-			/* Create timer again when watchdog period is
-			   dynamically changed or in the first instance
-			*/
-			dhd->timer.expires = jiffies + dhd_watchdog_ms * HZ / 1000;
-			add_timer(&dhd->timer);
-		} else {
+			dhd->wd_timer_valid = TRUE;
 			/* Re arm the timer, at last watchdog period */
 			mod_timer(&dhd->timer, jiffies + dhd_watchdog_ms * HZ / 1000);
+		} else if (dhd->wd_timer_valid == TRUE) {
+			/* Totally stop the timer */
+			dhd->wd_timer_valid = FALSE;
+			del_timer_flag = TRUE;
 		}
-
-		dhd->wd_timer_valid = TRUE;
-
-		save_dhd_watchdog_ms = wdtick;
+	}
+	dhd_os_spin_unlock(pub, flags);
+	if (del_timer_flag) {
+		del_timer_sync(&dhd->timer);
 	}
 }
 
@@ -3084,10 +3031,6 @@ dhd_os_open_image(char *filename)
 {
 	struct file *fp;
 
-#ifdef CONFIG_CFG80211
-	if (IS_CFG80211_FAVORITE() && !NO_FW_REQ())
-		return wl_cfg80211_request_fw(filename);
-#endif
 
 	fp = filp_open(filename, O_RDONLY, 0);
 	/*
@@ -3108,10 +3051,6 @@ dhd_os_get_image_block(char *buf, int len, void *image)
 	struct file *fp = (struct file *)image;
 	int rdlen;
 
-#ifdef CONFIG_CFG80211
-	if (IS_CFG80211_FAVORITE() && !NO_FW_REQ())
-		return wl_cfg80211_read_fw(buf, len);
-#endif
 
 	if (!image)
 		return 0;
@@ -3126,10 +3065,6 @@ dhd_os_get_image_block(char *buf, int len, void *image)
 void
 dhd_os_close_image(void *image)
 {
-#ifdef CONFIG_CFG80211
-	if (IS_CFG80211_FAVORITE() && !NO_FW_REQ())
-		return wl_cfg80211_release_fw();
-#endif
 	if (image)
 		filp_close((struct file *)image, NULL);
 }
@@ -3213,40 +3148,36 @@ extern void* mem_prealloc( int section, unsigned long size);
 #endif /* defined(CONFIG_LGE_BCM432X_PATCH) && defined(CONFIG_BRCM_USE_STATIC_BUF) */
 void * dhd_os_prealloc(int section, unsigned long size)
 {
-/* BRCM_UPDATE_S 20110212 */
-#if 0 // #ifdef CONFIG_WIFI_CONTROL_FUNC
-/* BRCM_UPDATE_E 20110212 */
+#if defined(CONFIG_LGE_BCM432X_PATCH) && defined(CONFIG_BRCM_USE_STATIC_BUF)
 	void *alloc_ptr = NULL;
-	if (wifi_control_data && wifi_control_data->mem_prealloc)
-	{
-		alloc_ptr = wifi_control_data->mem_prealloc(section, size);
+
+	alloc_ptr = mem_prealloc(section, size);
 		if (alloc_ptr)
 		{
 			DHD_INFO(("success alloc section %d\n", section));
 			bzero(alloc_ptr, size);
 			return alloc_ptr;
 		}
-	}
-
 	DHD_ERROR(("can't alloc section %d\n", section));
 	return 0;
-#else
-#if defined(CONFIG_LGE_BCM432X_PATCH) && defined(CONFIG_BRCM_USE_STATIC_BUF)
+#elif defined(CUSTOMER_HW2) && defined(CONFIG_WIFI_CONTROL_FUNC)
 	void *alloc_ptr = NULL;
-
-	alloc_ptr = mem_prealloc(section, size);
+	if (wifi_control_data && wifi_control_data->mem_prealloc)
+	{
+		alloc_ptr = wifi_control_data->mem_prealloc(section, size);
 	if (alloc_ptr)
 	{
 		DHD_INFO(("success alloc section %d\n", section));
 		bzero(alloc_ptr, size);
 		return alloc_ptr;
 	}
+	}
+
 	DHD_ERROR(("can't alloc section %d\n", section));
 	return 0;
 #else
 return MALLOC(0, size);
-#endif /* defined(CONFIG_LGE_BCM432X_PATCH) && defined(CONFIG_BRCM_USE_STATIC_BUF) */
-#endif
+#endif /* #if defined(CUSTOMER_HW2) && defined(CONFIG_WIFI_CONTROL_FUNC) */
 }
 #endif /* DHD_USE_STATIC_BUF */
 #if defined(CONFIG_WIRELESS_EXT)
@@ -3256,10 +3187,6 @@ dhd_get_wireless_stats(struct net_device *dev)
 	int res = 0;
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 
-	if (!dhd->pub.up) {
-		return NULL;
-	}
-
 	res = wl_iw_get_wireless_stats(dev, &dhd->iw.wstats);
 
 	if (res == 0)
@@ -3274,37 +3201,29 @@ dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,
 	wl_event_msg_t *event, void **data)
 {
 	int bcmerror = 0;
-
 	ASSERT(dhd != NULL);
 
-	bcmerror = wl_host_event(&dhd->pub, ifidx, pktdata, event, data);
+
+	bcmerror = wl_host_event(dhd, ifidx, pktdata, event, data);
 	if (bcmerror != BCME_OK)
 		return (bcmerror);
 
 #if defined(CONFIG_WIRELESS_EXT)
-#if defined(CONFIG_CFG80211)
-	if (!IS_CFG80211_FAVORITE()) {
-#endif
 	ASSERT(dhd->iflist[*ifidx] != NULL);
 
-	/*
-	 * Wireless ext is on primary interface only
-	 */
-	if (dhd->iflist[*ifidx]->net && (event->bsscfgidx == 0))
-		wl_iw_event(dhd->iflist[*ifidx]->net, event, *data);
-#if defined(CONFIG_CFG80211)
+	if (ntoh32(event->event_type) == WLC_E_IF) {
+		DHD_INFO(("<0> interface:%d OP:%d don't pass to wext,"
+			"net_device might not be created yet\n",
+				*ifidx, ntoh32(event->event_type)));
+		return bcmerror;
 	}
-#endif
-#endif /* defined(CONFIG_WIRELESS_EXT)  */
 
-#ifdef CONFIG_CFG80211
-	if (IS_CFG80211_FAVORITE()) {
-		ASSERT(dhd->iflist[*ifidx] != NULL);
 		ASSERT(dhd->iflist[*ifidx]->net != NULL);
+
 		if (dhd->iflist[*ifidx]->net)
-			wl_cfg80211_event(dhd->iflist[*ifidx]->net, event, *data);
-	}
-#endif
+		wl_iw_event(dhd->iflist[*ifidx]->net, event, *data);
+#endif /* defined(CONFIG_WIRELESS_EXT)  */
+
 
 	return (bcmerror);
 }
@@ -3343,20 +3262,18 @@ void dhd_wait_event_wakeup(dhd_pub_t *dhd)
 int
 dhd_dev_reset(struct net_device *dev, uint8 flag)
 {
-	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
-
-	/* Turning off watchdog */
-	if (flag)
-		dhd_os_wd_timer(&dhd->pub, 0);
+	int ret;
 
-	dhd_bus_devreset(&dhd->pub, flag);
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 
-	/* Turning on watchdog back */
-	if (!flag)
-		dhd_os_wd_timer(&dhd->pub, dhd_watchdog_ms);
-	DHD_ERROR(("%s:  WLAN OFF DONE\n", __FUNCTION__));
+	ret = dhd_bus_devreset(&dhd->pub, flag);
+	if (ret) {
+		DHD_ERROR(("%s: dhd_bus_devreset: %d\n", __FUNCTION__, ret));
+		return ret;
+	}
+	DHD_ERROR(("%s: WLAN %s DONE\n", __FUNCTION__, flag ? "OFF" : "ON"));
 
-	return 1;
+	return ret;
 }
 
 int net_os_set_suspend_disable(struct net_device *dev, int val)
@@ -3378,9 +3295,9 @@ int net_os_set_suspend(struct net_device *dev, int val)
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 
 	if (dhd) {
-		//dhd_os_proto_block(&dhd->pub);  // louislee commented out : RC17 lock bug , dhd_prot_ioctl() function already has a lock
+		dhd_os_proto_block(&dhd->pub);
 		ret = dhd_set_suspend(val, &dhd->pub);
-		//dhd_os_proto_unblock(&dhd->pub);  // louislee commented out : RC17 lock bug , dhd_prot_ioctl() function already has a lock
+		dhd_os_proto_unblock(&dhd->pub);
 	}
 #endif /* defined(CONFIG_HAS_EARLYSUSPEND) */
 	return ret;
@@ -3407,12 +3324,12 @@ int net_os_set_packet_filter(struct net_device *dev, int val)
 	 * back ON only if suspend_disable_flag was not set
 	*/
 	if (dhd && dhd->pub.up) {
-		//dhd_os_proto_block(&dhd->pub); // louislee commented out : RC17 lock bug , dhd_prot_ioctl() function already has a lock
+		dhd_os_proto_block(&dhd->pub);
 		if (dhd->pub.in_suspend) {
 			if (!val || (val && !dhd->pub.suspend_disable_flag))
 				dhd_set_packet_filter(val, &dhd->pub);
 		}
-		//dhd_os_proto_unblock(&dhd->pub); // louislee commented out : RC17 lock bug , dhd_prot_ioctl() function already has a lock
+		dhd_os_proto_unblock(&dhd->pub);
 	}
 	return ret;
 }
@@ -3449,7 +3366,7 @@ dhd_dev_pno_enable(struct net_device *dev,  int pfn_enabled)
 
 /* Linux wrapper to call common dhd_pno_set */
 int
-dhd_dev_pno_set(struct net_device *dev, wlc_ssid_t* ssids_local, int nssid, uchar  scan_fr)
+dhd_dev_pno_set(struct net_device *dev, wlc_ssid_t* ssids_local, int nssid, ushort  scan_fr)
 {
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 
@@ -3467,6 +3384,73 @@ dhd_dev_get_pno_status(struct net_device *dev)
 
 #endif /* PNO_SUPPORT */
 
+int net_os_send_hang_message(struct net_device *dev)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+	int ret = 0;
+
+	if (dhd) {
+		if (!dhd->hang_was_sent) {
+			dhd->hang_was_sent = 1;
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+			ret = wl_iw_send_priv_event(dev, "HANGED");
+#else
+			ret = wl_iw_send_priv_event(dev, "HANG");
+#endif
+		}
+	}
+	return ret;
+}
+
+void dhd_bus_country_set(struct net_device *dev, wl_country_t *cspec)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	if (dhd && dhd->pub.up)
+			memcpy(&dhd->pub.dhd_cspec, cspec, sizeof(wl_country_t));
+}
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+void dhd_os_start_lock(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
+
+	if (dhd)
+		mutex_lock(&dhd->wl_start_lock);
+}
+
+void dhd_os_start_unlock(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
+
+	if (dhd)
+		mutex_unlock(&dhd->wl_start_lock);
+}
+
+#endif 
+
+#ifdef SOFTAP
+unsigned long dhd_os_spin_lock(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
+	unsigned long flags = 0;
+
+	if (dhd)
+		spin_lock_irqsave(&dhd->dhd_lock, flags);
+
+	return flags;
+}
+
+void dhd_os_spin_unlock(dhd_pub_t *pub, unsigned long flags)
+{
+	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
+
+	if (dhd)
+		spin_unlock_irqrestore(&dhd->dhd_lock, flags);
+}
+#endif /* SOFTAP */
+
 static int
 dhd_get_pend_8021x_cnt(dhd_info_t *dhd)
 {
@@ -3494,22 +3478,18 @@ dhd_wait_pend8021x(struct net_device *dev)
 	}
 	return pend;
 }
-#ifdef PROP_TXSTATUS
-extern int dhd_wlfc_interface_entry_update(void* state,	ewlfc_mac_entry_action_t action, uint8 ifid,
-	uint8 iftype, uint8* ea);
-extern int dhd_wlfc_FIFOcreditmap_update(void* state, uint8* credits);
 
-int dhd_wlfc_interface_event(struct dhd_info *dhd, uint8 action, uint8 ifid, uint8 iftype,
-	uint8* ea)
+/* LGE_CHANGE_S, [yoohoo@lge.com], 2009-11-19, Use deepsleep instead of dhd_dev_reset when driver start or stop */
+#if defined(CONFIG_LGE_BCM432X_PATCH) && defined(CONFIG_BRCM_USE_DEEPSLEEP)
+dhd_pub_t * get_dhd_pub_from_dev(struct net_device *dev)
 {
-	return dhd_wlfc_interface_entry_update(dhd->pub.wlfc_state, action, ifid, iftype, ea);
-}
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 
-int dhd_wlfc_FIFOcreditmap_event(struct dhd_info *dhd, uint8* event_data)
-{
-	return dhd_wlfc_FIFOcreditmap_update(dhd->pub.wlfc_state, event_data);
+	return &dhd->pub;
 }
-#endif /* PROP_TXSTATUS */
+/* LGE_CHANGE_S, [yoohoo@lge.com], 2009-11-19, Use deepsleep instead of dhd_dev_reset when driver start or stop */
+#endif /* CONFIG_LGE_BCM432X_PATCH && CONFIG_BRCM_USE_DEEPSLEEP */
+/* LGE_CHANGE_E, [yoohoo@lge.com], 2009-11-19, Use deepsleep instead of dhd_dev_reset when driver start or stop */
 
 #ifdef DHD_DEBUG
 int
@@ -3548,133 +3528,34 @@ exit:
 }
 #endif /* DHD_DEBUG */
 
-int dhd_os_wake_lock_timeout(dhd_pub_t *pub, uint32 timeout)
-{
-	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
-	unsigned long flags;
-	int ret = 0;
-
-	if (dhd) {
-		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
-		ret = dhd->wakelock_timeout_enable;
-#ifdef CONFIG_HAS_WAKELOCK
-		if (dhd->wakelock_timeout_enable)
-			wake_lock_timeout(&dhd->wl_rxwake, timeout);
-#endif
-		dhd->wakelock_timeout_enable = 0;
-		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
-	}
-	/* printk("%s: %d\n", __FUNCTION__, ret); */
-	return ret;
-}
-
-int net_os_wake_lock_timeout(struct net_device *dev)
-{
-	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
-	int ret = 0;
-
-	if (dhd)
-		ret = dhd_os_wake_lock_timeout(&dhd->pub, HZ);
-	return ret;
-}
-
-int dhd_os_wake_lock_timeout_enable(dhd_pub_t *pub)
-{
-	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
-	unsigned long flags;
-
-	if (dhd) {
-		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
-		dhd->wakelock_timeout_enable = 1;
-		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
-	}
-	/* printk("%s\n",__func__); */
-	return 0;
-}
-
-int net_os_wake_lock_timeout_enable(struct net_device *dev)
-{
-	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
-	int ret = 0;
-
-	if (dhd)
-		ret = dhd_os_wake_lock_timeout_enable(&dhd->pub);
-	return ret;
-}
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//htclk fail patch
+#include <bcmsdbus.h>
 
-int dhd_os_wake_lock(dhd_pub_t *pub)
+void htclk_fail_reset(void *bus)
 {
-	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
-	unsigned long flags;
-	int ret = 0;
+	dhd_info_t *dhd = (dhd_info_t *)bus;
 
-	if (dhd) {
-		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
-#ifdef CONFIG_HAS_WAKELOCK
-		if (!dhd->wakelock_counter)
-			wake_lock(&dhd->wl_wifi);
-#endif
-		dhd->wakelock_counter++;
-		ret = dhd->wakelock_counter;
-		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
-	}
-	/* printk("%s: %d\n", __FUNCTION__, ret); */
-	return ret;
-}
+	printk("Enter %s:%d\n",__func__,__LINE__);
+	/* Turning off watchdog */
+	dhd_os_wd_timer(&dhd->pub, 0);
 
-int net_os_wake_lock(struct net_device *dev)
-{
-	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
-	int ret = 0;
+	dhd_bus_devreset(&dhd->pub, 1);
 
-	if (dhd)
-		ret = dhd_os_wake_lock(&dhd->pub);
-	return ret;
-}
+	sdioh_stop(NULL);
 
-int dhd_os_wake_unlock(dhd_pub_t *pub)
-{
-	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
-	unsigned long flags;
-	int ret = 0;
+	dhd_customer_gpio_wlan_ctrl(WLAN_RESET_OFF);
+	mdelay(200);		// 200ms
+	dhd_customer_gpio_wlan_ctrl(WLAN_RESET_ON);
 
-	dhd_os_wake_lock_timeout(pub, HZ);
-	if (dhd) {
-		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
-		if (dhd->wakelock_counter) {
-			dhd->wakelock_counter--;
-#ifdef CONFIG_HAS_WAKELOCK
-			if (!dhd->wakelock_counter)
-				wake_unlock(&dhd->wl_wifi);
-#endif
-			ret = dhd->wakelock_counter;
-		}
-		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
-	}
-	/* printk("%s: %d\n", __FUNCTION__, ret); */
-	return ret;
-}
+	sdioh_start(NULL, 0);
 
-int net_os_wake_unlock(struct net_device *dev)
-{
-	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
-	int ret = 0;
+	dhd_bus_devreset(&dhd->pub, 0);
 
-	if (dhd)
-		ret = dhd_os_wake_unlock(&dhd->pub);
-	return ret;
-}
+	/* Turning on watchdog back */
+	dhd_os_wd_timer(&dhd->pub, dhd_watchdog_ms);
 
-int net_os_send_hang_message(struct net_device *dev)
-{
-	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
-	int ret = 0;
+	sdioh_start(NULL, 1);
 
-	if (dhd) {
-		if (!dhd->hang_was_sent) {
-			dhd->hang_was_sent = 1;
-			ret = wl_iw_send_priv_event(dev, "HANG");
-		}
-	}
-	return ret;
+	dhd_preinit_ioctls(&dhd->pub);
 }
+#endif
diff --git a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_proto.h b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_proto.h
index 40aa6d1..382785a 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_proto.h
+++ b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_proto.h
@@ -24,7 +24,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhd_proto.h,v 1.2.82.1.4.1.16.5.20.3.14.1 2010/11/09 02:06:54 Exp $
+ * $Id: dhd_proto.h,v 1.2.82.1.4.1.16.7 2010/05/10 12:54:59 Exp $
  */
 
 #ifndef _dhd_proto_h_
@@ -37,6 +37,10 @@
 #define IOCTL_RESP_TIMEOUT  2000 /* In milli second */
 #endif
 
+#ifndef IOCTL_CHIP_ACTIVE_TIMEOUT
+#define IOCTL_CHIP_ACTIVE_TIMEOUT  10 /* In milli second */
+#endif
+
 /*
  * Exported from the dhd protocol module (dhd_cdc, dhd_rndis)
  */
@@ -65,8 +69,6 @@ extern void dhd_prot_hdrpush(dhd_pub_t *, int ifidx, void *txp);
 /* Remove any protocol-specific data header. */
 extern int dhd_prot_hdrpull(dhd_pub_t *, int *ifidx, void *rxp);
 
-extern int dhd_prot_hdrpull_txside(dhd_pub_t *dhd, int *ifidx, void *pktbuf);
-
 /* Use protocol to issue ioctl to dongle */
 extern int dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx, wl_ioctl_t * ioc, void * buf, int len);
 
@@ -84,12 +86,6 @@ extern int dhd_ioctl(dhd_pub_t * dhd_pub, dhd_ioctl_t *ioc, void * buf, uint buf
 
 extern int dhd_preinit_ioctls(dhd_pub_t *dhd);
 
-#ifdef PROP_TXSTATUS
-extern int dhd_wlfc_enque_sendq(void* state, int prec, void* p);
-extern int dhd_wlfc_commit_packets(void* state, f_commitpkt_t fcommit, void* commit_ctx);
-extern void dhd_wlfc_cleanup(dhd_pub_t *dhd);
-#endif /* PROP_TXSTATUS */
-
 /********************************
  * For version-string expansion *
  */
diff --git a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_sdio.c b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_sdio.c
index 5c9f8a8..367b9f4 100644
--- a/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_sdio.c
+++ b/drivers/net/wireless/bcm43291/src/dhd/sys/dhd_sdio.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhd_sdio.c,v 1.157.2.27.2.33.2.71.4.25.2.16 2010/11/10 00:25:20 Exp $
+ * $Id: dhd_sdio.c,v 1.157.2.27.2.33.2.129.4.9 2011/01/06 00:54:32 Exp $
  */
 
 #include <typedefs.h>
@@ -40,10 +40,10 @@
 #include <siutils.h>
 #include <hndpmu.h>
 #include <hndsoc.h>
-#if defined(DHD_DEBUG)
+#ifdef DHD_DEBUG
 #include <hndrte_armtrap.h>
 #include <hndrte_cons.h>
-#endif /* defined(DHD_DEBUG) */
+#endif /* DHD_DEBUG */
 #include <sbchipc.h>
 #include <sbhnddma.h>
 
@@ -75,20 +75,13 @@
 
 #define TXRETRIES	2	/* # of retries for tx frames */
 
-// bill.jung@lge.com RX Tunning
-#if 0
 #if defined(CONFIG_MACH_SANDGATE2G)
 #define DHD_RXBOUND	250	/* Default for max rx frames in one scheduling */
 #else
 #define DHD_RXBOUND	50	/* Default for max rx frames in one scheduling */
 #endif /* defined(CONFIG_MACH_SANDGATE2G) */
-#endif
-
-#define DHD_RXBOUND	10
 
-// bill.jung@lge.com RX Tunning
-//#define DHD_TXBOUND	20	/* Default for max tx frames in one scheduling */
-#define DHD_TXBOUND	10	/* Default for max tx frames in one scheduling */
+#define DHD_TXBOUND	20	/* Default for max tx frames in one scheduling */
 
 #define DHD_TXMINMAX	1	/* Max tx frames if rx still pending */
 
@@ -134,7 +127,7 @@
 /* Bump up limit on waiting for HT to account for first startup;
  * if the image is doing a CRC calculation before programming the PMU
  * for HT availability, it could take a couple hundred ms more, so
- * max out at a 1 second (1000000us). // 0.5->1 louislee
+ * max out at a 1 second (1000000us).
  */
 #if (PMU_MAX_TRANSITION_DLY <= 1000000)
 #undef PMU_MAX_TRANSITION_DLY
@@ -154,12 +147,7 @@
 #define PKTFREE2()		if ((bus->bus != SPI_BUS) || bus->usebufpool) \
 					PKTFREE(bus->dhd->osh, pkt, FALSE);
 DHD_SPINWAIT_SLEEP_INIT(sdioh_spinwait_sleep);
-
-#ifdef PROP_TXSTATUS
-extern void dhd_wlfc_txcomplete(dhd_pub_t *dhd, void *txp, bool success);
-#endif
-
-int gDK8 = FALSE; // louislee addd
+extern int dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len);
 
 #ifdef DHD_DEBUG
 /* Device console log buffer state */
@@ -441,8 +429,9 @@ static void dhdsdio_sdtest_set(dhd_bus_t *bus, bool start);
 
 #ifdef DHD_DEBUG
 static int dhdsdio_checkdied(dhd_bus_t *bus, uint8 *data, uint size);
-static int dhdsdio_mem_dump(dhd_bus_t *bus);
 #endif /* DHD_DEBUG  */
+
+
 static int dhdsdio_download_state(dhd_bus_t *bus, bool enter);
 
 static void dhdsdio_release(dhd_bus_t *bus, osl_t *osh);
@@ -474,6 +463,11 @@ static int dhdsdio_download_nvram(struct dhd_bus *bus);
 static int dhdsdio_download_code_array(struct dhd_bus *bus);
 #endif
 
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//20110121
+#include <linux/wakelock.h>
+extern int ap_suspend_status;
+extern struct wake_lock ap_suspend_wake_lock;
+#endif
 
 static void
 dhd_dongle_setmemsize(struct dhd_bus *bus, int mem_size)
@@ -501,6 +495,14 @@ dhdsdio_set_siaddr_window(dhd_bus_t *bus, uint32 address)
 		                 (address >> 24) & SBSDIO_SBADDRHIGH_MASK, &err);
 	return err;
 }
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//htclk fail patch
+unsigned long old_jiff;
+unsigned long cur_jiff;
+
+int ht_err_cnt;
+extern void htclk_fail_reset(void *bus);
+extern volatile bool dhd_mmc_suspend;
+#endif
 
 
 /* Turn backplane clock on or off */
@@ -532,6 +534,18 @@ dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 
 		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, clkreq, &err);
 		if (err) {
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//htclk fail patch
+			if( ht_err_cnt == 0 )
+				old_jiff = jiffies;
+
+			cur_jiff = jiffies;
+			
+			if( (cur_jiff < old_jiff) || (cur_jiff - old_jiff) > 500 )
+				ht_err_cnt = 0;
+			else
+				ht_err_cnt++;
+#endif
+//			printk("[DEBUG] %s:%d dhd_mmc_suspend %d\n",__func__,__LINE__,dhd_mmc_suspend);
 			DHD_ERROR(("%s: HT Avail request error: %d\n", __FUNCTION__, err));
 			return BCME_ERROR;
 		}
@@ -579,6 +593,7 @@ dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 			          !SBSDIO_CLKAV(clkctl, bus->alp_only)), PMU_MAX_TRANSITION_DLY);
 		}
 		if (err) {
+//			printk("[DEBUG] %s:%d dhd_mmc_suspend %d\n",__func__,__LINE__,dhd_mmc_suspend);
 			DHD_ERROR(("%s: HT Avail request error: %d\n", __FUNCTION__, err));
 			return BCME_ERROR;
 		}
@@ -710,7 +725,6 @@ dhdsdio_sdclk(dhd_bus_t *bus, bool on)
 				return BCME_ERROR;
 			}
 		}
-		if (!gDK8)
 		    bus->clkstate = CLK_NONE;
 	}
 
@@ -721,6 +735,7 @@ dhdsdio_sdclk(dhd_bus_t *bus, bool on)
 static int
 dhdsdio_clkctl(dhd_bus_t *bus, uint target, bool pendok)
 {
+	int ret = BCME_OK;
 #ifdef DHD_DEBUG
 	uint oldstate = bus->clkstate;
 #endif /* DHD_DEBUG */
@@ -733,7 +748,7 @@ dhdsdio_clkctl(dhd_bus_t *bus, uint target, bool pendok)
 			dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
 			bus->activity = TRUE;
 		}
-		return BCME_OK;
+		return ret;
 	}
 
 	switch (target) {
@@ -742,39 +757,40 @@ dhdsdio_clkctl(dhd_bus_t *bus, uint target, bool pendok)
 		if (bus->clkstate == CLK_NONE)
 			dhdsdio_sdclk(bus, TRUE);
 		/* Now request HT Avail on the backplane */
-		dhdsdio_htclk(bus, TRUE, pendok);
+		ret = dhdsdio_htclk(bus, TRUE, pendok);
+		if (ret == BCME_OK) {
 		dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
 		bus->activity = TRUE;
+		}
 		break;
 
 	case CLK_SDONLY:
 		/* Remove HT request, or bring up SD clock */
 		if (bus->clkstate == CLK_NONE)
-			dhdsdio_sdclk(bus, TRUE);
+			ret = dhdsdio_sdclk(bus, TRUE);
 		else if (bus->clkstate == CLK_AVAIL)
-			dhdsdio_htclk(bus, FALSE, FALSE);
+			ret = dhdsdio_htclk(bus, FALSE, FALSE);
 		else
 			DHD_ERROR(("dhdsdio_clkctl: request for %d -> %d\n",
 			           bus->clkstate, target));
+		if (ret == BCME_OK)
 		dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
 		break;
 
 	case CLK_NONE:
-		if (!gDK8) {
 		    /* Make sure to remove HT request */
 		    if (bus->clkstate == CLK_AVAIL)
-			    dhdsdio_htclk(bus, FALSE, FALSE);
+			ret = dhdsdio_htclk(bus, FALSE, FALSE);
 		    /* Now remove the SD clock */
-		    dhdsdio_sdclk(bus, FALSE);
+		ret = dhdsdio_sdclk(bus, FALSE);
 		    dhd_os_wd_timer(bus->dhd, 0);
-		}
 		break;
 	}
 #ifdef DHD_DEBUG
 	DHD_INFO(("dhdsdio_clkctl: %d -> %d\n", oldstate, bus->clkstate));
 #endif /* DHD_DEBUG */
 
-	return BCME_OK;
+	return ret;
 }
 
 int
@@ -784,8 +800,6 @@ dhdsdio_bussleep(dhd_bus_t *bus, bool sleep)
 	sdpcmd_regs_t *regs = bus->regs;
 	uint retries = 0;
 
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
-
 	DHD_INFO(("dhdsdio_bussleep: request %s (currently %s)\n",
 	          (sleep ? "SLEEP" : "WAKE"),
 	          (bus->sleeping ? "SLEEP" : "WAKE")));
@@ -874,8 +888,6 @@ dhd_enable_oob_intr(struct dhd_bus *bus, bool enable)
 	sdpcmd_regs_t *regs = bus->regs;
 	uint retries = 0;
 
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
-
 	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
 	if (enable == TRUE) {
 
@@ -1049,20 +1061,11 @@ done:
 	/* restore pkt buffer pointer before calling tx complete routine */
 	PKTPULL(osh, pkt, SDPCM_HDRLEN + pad);
 	dhd_os_sdunlock(bus->dhd);
-#ifdef PROP_TXSTATUS
-	dhd_wlfc_txcomplete(bus->dhd, pkt, ret == 0);
-#else
-	if (chan != SDPCM_TEST_CHANNEL) {
 		dhd_txcomplete(bus->dhd, pkt, ret != 0);
-	}
-#endif
 	dhd_os_sdlock(bus->dhd);
 
-	if (free_pkt) {
-#ifndef PROP_TXSTATUS
+	if (free_pkt)
 		PKTFREE(osh, pkt, TRUE);
-#endif
-	}
 
 	return ret;
 }
@@ -1112,16 +1115,9 @@ dhd_bus_txdata(struct dhd_bus *bus, void *pkt)
 		dhd_os_sdlock_txq(bus->dhd);
 		if (dhd_prec_enq(bus->dhd, &bus->txq, pkt, prec) == FALSE) {
 			PKTPULL(osh, pkt, SDPCM_HDRLEN);
-#ifdef PROP_TXSTATUS
-			dhd_wlfc_txcomplete(bus->dhd, pkt, FALSE);
-#else
 			dhd_txcomplete(bus->dhd, pkt, FALSE);
-#endif
-#ifdef PROP_TXSTATUS
-			/* let the caller decide whether to free the packet */
-#else
 			PKTFREE(osh, pkt, TRUE);
-#endif
+			DHD_ERROR(("%s: out of bus->txq !!!\n", __FUNCTION__));
 			ret = BCME_NORESOURCE;
 		} else {
 			ret = BCME_OK;
@@ -1320,8 +1316,6 @@ dhd_bus_txctl(struct dhd_bus *bus, uchar *msg, uint msglen)
 	}
 
 	if (ret == -1) {
-		bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
-
 #ifdef DHD_DEBUG
 		if (DHD_BYTES_ON() && DHD_CTL_ON()) {
 			prhex("Tx Frame", frame, len);
@@ -1331,8 +1325,10 @@ dhd_bus_txctl(struct dhd_bus *bus, uchar *msg, uint msglen)
 #endif
 
 		do {
+			bus->ctrl_frame_stat = FALSE;
 			ret = dhd_bcmsdh_send_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2, F2SYNC,
 			                          frame, len, NULL, NULL, NULL);
+
 			ASSERT(ret != BCME_PENDING);
 
 			if (ret < 0) {
@@ -1443,7 +1439,7 @@ enum {
 #ifdef DHD_DEBUG
 	IOV_CHECKDIED,
 #endif
-	IOV_SET_DOWNLOAD_STATE,
+	IOV_DOWNLOAD,
 	IOV_FORCEEVEN,
 	IOV_SDIOD_DRIVE,
 	IOV_READAHEAD,
@@ -1476,7 +1472,7 @@ const bcm_iovar_t dhdsdio_iovars[] = {
 	{"sd1idle",	IOV_SD1IDLE,	0,	IOVT_BOOL,	0 },
 	{"membytes",	IOV_MEMBYTES,	0,	IOVT_BUFFER,	2 * sizeof(int) },
 	{"memsize",	IOV_MEMSIZE,	0,	IOVT_UINT32,	0 },
-	{"dwnldstate",	IOV_SET_DOWNLOAD_STATE,	0,	IOVT_BOOL,	0 },
+	{"download",	IOV_DOWNLOAD,	0,	IOVT_BOOL,	0 },
 	{"vars",	IOV_VARS,	0,	IOVT_BUFFER,	0 },
 	{"sdiod_drive",	IOV_SDIOD_DRIVE, 0,	IOVT_UINT32,	0 },
 	{"readahead",	IOV_READAHEAD,	0,	IOVT_BOOL,	0 },
@@ -1878,12 +1874,6 @@ dhdsdio_checkdied(dhd_bus_t *bus, uint8 *data, uint size)
 		DHD_ERROR(("%s: %s\n", __FUNCTION__, strbuf.origbuf));
 	}
 
-#ifdef DHD_DEBUG
-	if (sdpcm_shared.flags & SDPCM_SHARED_TRAP) {
-		/* Mem dump to a file on device */
-		dhdsdio_mem_dump(bus);
-	}
-#endif /* DHD_DEBUG */
 
 done:
 	if (mbuffer)
@@ -1894,56 +1884,6 @@ done:
 	return bcmerror;
 }
 
-static int
-dhdsdio_mem_dump(dhd_bus_t *bus)
-{
-	int ret = 0;
-	int size; /* Full mem size */
-	int start = 0; /* Start address */
-	int read_size = 0; /* Read size of each iteration */
-	uint8 *buf = NULL, *databuf = NULL;
-
-	/* Get full mem size */
-	size = bus->ramsize;
-	buf = MALLOC(bus->dhd->osh, size);
-	if (!buf) {
-		printf("%s: Out of memory (%d bytes)\n", __FUNCTION__, size);
-		return -1;
-	}
-
-	/* Read mem content */
-	printf("Dump dongle memory");
-	databuf = buf;
-	while (size)
-	{
-		read_size = MIN(MEMBLOCK, size);
-		if ((ret = dhdsdio_membytes(bus, FALSE, start, databuf, read_size)))
-		{
-			printf("%s: Error membytes %d\n", __FUNCTION__, ret);
-			if (buf) {
-				MFREE(bus->dhd->osh, buf, size);
-			}
-			return -1;
-		}
-		printf(".");
-
-		/* Decrement size and increment start address */
-		size -= read_size;
-		start += read_size;
-		databuf += read_size;
-	}
-	printf("Done\n");
-
-	/* free buf before return !!! */
-	if (write_to_file(bus->dhd, buf, bus->ramsize))
-	{
-		printf("%s: Error writing to files\n", __FUNCTION__);
-		return -1;
-	}
-
-	/* buf free handled in write_to_file, not here */
-	return 0;
-}
 
 #define CONSOLE_LINE_MAX	192
 
@@ -2221,7 +2161,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bcm_iovar_t *vi, uint32 actionid, const ch
 		si_sdiod_drive_strength_init(bus->sih, bus->dhd->osh, dhd_sdiod_drive_strength);
 		break;
 
-	case IOV_SVAL(IOV_SET_DOWNLOAD_STATE):
+	case IOV_SVAL(IOV_DOWNLOAD):
 		bcmerror = dhdsdio_download_state(bus, bool_val);
 		break;
 
@@ -2343,11 +2283,11 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bcm_iovar_t *vi, uint32 actionid, const ch
 		*(char *)arg = 0;
 
 		bcmstrcat(arg, "\nFunc 0\n");
-		bcmsdh_cis_read(bus->sdh, 0x10, (uint8 *)arg + strlen(arg), 49 * 32);
+		bcmsdh_cis_read(bus->sdh, 0x10, (uint8 *)arg + strlen(arg), SBSDIO_CIS_SIZE_LIMIT);
 		bcmstrcat(arg, "\nFunc 1\n");
-		bcmsdh_cis_read(bus->sdh, 0x11, (uint8 *)arg + strlen(arg), 49 * 32);
+		bcmsdh_cis_read(bus->sdh, 0x11, (uint8 *)arg + strlen(arg), SBSDIO_CIS_SIZE_LIMIT);
 		bcmstrcat(arg, "\nFunc 2\n");
-		bcmsdh_cis_read(bus->sdh, 0x12, (uint8 *)arg + strlen(arg), 49 * 32);
+		bcmsdh_cis_read(bus->sdh, 0x12, (uint8 *)arg + strlen(arg), SBSDIO_CIS_SIZE_LIMIT);
 		break;
 	}
 
@@ -2742,24 +2682,22 @@ exit:
 void
 dhd_bus_stop(struct dhd_bus *bus, bool enforce_mutex)
 {
-	osl_t *osh;
+	osl_t *osh = bus->dhd->osh;
 	uint32 local_hostintmask;
 	uint8 saveclk;
 	uint retries;
 	int err;
-	if (!bus->dhd)
-		return;
 
-	osh = bus->dhd->osh;
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-	bcmsdh_waitlockfree(NULL);
-
 	if (enforce_mutex)
 		dhd_os_sdlock(bus->dhd);
 
 	BUS_WAKE(bus);
 
+	/* Change our idea of bus state */
+	bus->dhd->busstate = DHD_BUS_DOWN;
+
 	/* Enable clock for device interrupts */
 	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
 
@@ -2768,9 +2706,6 @@ dhd_bus_stop(struct dhd_bus *bus, bool enforce_mutex)
 	local_hostintmask = bus->hostintmask;
 	bus->hostintmask = 0;
 
-	/* Change our idea of bus state */
-	bus->dhd->busstate = DHD_BUS_DOWN;
-
 	/* Force clocks on backplane to be sure F2 interrupt propagates */
 	saveclk = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
 	if (!err) {
@@ -4097,10 +4032,8 @@ dhdsdio_hostmail(dhd_bus_t *bus)
 		bus->flowcontrol = fcbits;
 	}
 
-
 	/* Shouldn't be any others */
 	if (hmb_data & ~(HMB_DATA_DEVREADY |
-	                 HMB_DATA_FWHALT |
 	                 HMB_DATA_NAKHANDLED |
 	                 HMB_DATA_FC |
 	                 HMB_DATA_FWREADY |
@@ -4112,6 +4045,12 @@ dhdsdio_hostmail(dhd_bus_t *bus)
 	return intstatus;
 }
 
+#if defined(CONFIG_LGE_BCM432X_PATCH)		//by sjpark 11-02-01
+extern struct net_device *g_net_dev;
+extern bool 	ap_fw_loaded;
+extern int net_os_send_hang_message(struct net_device *dev);
+#endif
+
 bool
 dhdsdio_dpc(dhd_bus_t *bus)
 {
@@ -4124,8 +4063,11 @@ dhdsdio_dpc(dhd_bus_t *bus)
 	uint framecnt = 0;		  /* Temporary counter of tx/rx frames */
 	bool rxdone = TRUE;		  /* Flag for no more read data */
 	bool resched = FALSE;	  /* Flag indicating resched wanted */
-
+#if defined(CONFIG_LGE_BCM432X_PATCH)		//by sjpark 11-02-01
+	int reset_flag = FALSE;
+#endif
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
+
 	/* Start with leftover status bits */
 	intstatus = bus->intstatus;
 
@@ -4249,6 +4191,12 @@ dhdsdio_dpc(dhd_bus_t *bus)
 
 	/* On frame indication, read available frames */
 	if (PKT_AVAILABLE()) {
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//20110121
+		if(ap_suspend_status == 1 )
+		{
+			wake_lock_timeout(&ap_suspend_wake_lock, 60*HZ);
+		}
+#endif
 		framecnt = dhdsdio_readframes(bus, rxlimit, &rxdone);
 		if (rxdone || bus->rxskip)
 			intstatus &= ~I_HMB_FRAME_IND;
@@ -4259,11 +4207,6 @@ dhdsdio_dpc(dhd_bus_t *bus)
 	bus->intstatus = intstatus;
 
 clkwait:
-
-#if defined(OOB_INTR_ONLY)
-	bcmsdh_oob_intr_set(1);
-#endif /* (OOB_INTR_ONLY) */
-
 	/* Re-enable interrupts to detect new device events (mailbox, rx frame)
 	 * or clock availability.  (Allows tx loop to check ipend if desired.)
 	 * (Unless register access seems hosed, as we may not be able to ACK...)
@@ -4272,6 +4215,9 @@ clkwait:
 		DHD_INTR(("%s: enable SDIO interrupts, rxdone %d framecnt %d\n",
 		          __FUNCTION__, rxdone, framecnt));
 		bus->intdis = FALSE;
+#if defined(OOB_INTR_ONLY)
+		bcmsdh_oob_intr_set(1);
+#endif /* (OOB_INTR_ONLY) */
 		bcmsdh_intr_enable(sdh);
 	}
 
@@ -4307,8 +4253,11 @@ clkwait:
 			}
 
 		}
-		printf("Return_dpc value is : %d\n", ret);
+		if (ret == 0) {
 		bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
+		}
+
+		printf("Return_dpc value is : %d\n", ret);
 		bus->ctrl_frame_stat = FALSE;
 		dhd_wait_event_wakeup(bus->dhd);
 	}
@@ -4319,22 +4268,26 @@ clkwait:
 		framecnt = dhdsdio_sendfromq(bus, framecnt);
 		txlimit -= framecnt;
 	}
-	/* Resched the DPC if ctrl cmd is pending on bus credit */
-	if (bus->ctrl_frame_stat)
-	{	
-		msleep(50);
-		resched = TRUE;
-	}
 	
 	/* Resched if events or tx frames are pending, else await next interrupt */
 	/* On failed register access, all bets are off: no resched or interrupts */
 	if ((bus->dhd->busstate == DHD_BUS_DOWN) || bcmsdh_regfail(sdh)) {
 		DHD_ERROR(("%s: failed backplane access over SDIO, halting operation %d \n",
 		           __FUNCTION__, bcmsdh_regfail(sdh)));
+// 20110201 mingi.sung@lge.com Disable SDIO interrupt when BUS is down [START]
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+		bcmsdh_intr_disable(bus->sdh);
+#endif
+// 20110201 mingi.sung@lge.com Disable SDIO interrupt when BUS is down [END]
 		bus->dhd->busstate = DHD_BUS_DOWN;
 		bus->intstatus = 0;
+#if defined(CONFIG_LGE_BCM432X_PATCH)		//by sjpark 11-02-01
+		reset_flag = TRUE;
+#endif
 	} else if (bus->clkstate == CLK_PENDING) {
-		/* Awaiting I_CHIPACTIVE; don't resched */
+		DHD_INFO(("%s: rescheduled due to CLK_PENDING awaiting \
+			I_CHIPACTIVE interrupt", __FUNCTION__));
+			resched = TRUE;
 	} else if (bus->intstatus || bus->ipend ||
 	           (!bus->fcstate && pktq_mlen(&bus->txq, ~bus->flowcontrol) && DATAOK(bus)) ||
 			PKT_AVAILABLE()) {  /* Read multiple frames */
@@ -4344,12 +4297,27 @@ clkwait:
 	bus->dpc_sched = resched;
 
 	/* If we're done for now, turn off clock request. */
-	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && (bus->clkstate != CLK_PENDING)) {
+	if ((bus->clkstate != CLK_PENDING) && bus->idletime == DHD_IDLE_IMMEDIATE) {
 		bus->activity = FALSE;
 		dhdsdio_clkctl(bus, CLK_NONE, FALSE);
 	}
 
 	dhd_os_sdunlock(bus->dhd);
+
+#if defined(CONFIG_LGE_BCM432X_PATCH)		//by sjpark 11-02-01
+	if(reset_flag == TRUE)
+	{
+		if(ap_fw_loaded == FALSE){
+			if(g_net_dev != NULL)
+			{
+				printk("[%s] : net_os_send_hang_message send. Should not occur.\n",__FUNCTION__);
+				net_os_send_hang_message(g_net_dev);
+			}
+		}
+		return 0;
+	}
+#endif
+
 	return resched;
 }
 
@@ -4373,6 +4341,12 @@ dhdsdio_isr(void *arg)
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
+// 20110212 mingi.sung@lge.com Prevent BUS IS DOWN error [START]
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+	dhd_mmc_suspend = FALSE;
+#endif
+// 20110212 mingi.sung@lge.com Prevent BUS IS DOWN error [END]
+
 	if (!bus) {
 		DHD_ERROR(("%s : bus is null pointer , exit \n", __FUNCTION__));
 		return;
@@ -4383,9 +4357,6 @@ dhdsdio_isr(void *arg)
 		DHD_ERROR(("%s : bus is down. we have nothing to do\n", __FUNCTION__));
 		return;
 	}
-
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
-
 	/* Count the interrupt call */
 	bus->intrcount++;
 	bus->ipend = TRUE;
@@ -4408,9 +4379,7 @@ dhdsdio_isr(void *arg)
 
 #if defined(SDIO_ISR_THREAD)
 	DHD_TRACE(("Calling dhdsdio_dpc() from %s\n", __FUNCTION__));
-	DHD_OS_WAKE_LOCK(bus->dhd);
 	while (dhdsdio_dpc(bus));
-	DHD_OS_WAKE_UNLOCK(bus->dhd);
 #else
 	bus->dpc_sched = TRUE;
 	dhd_sched_dpc(bus->dhd);
@@ -4676,7 +4645,6 @@ dhd_bus_watchdog(dhd_pub_t *dhdp)
 	if (bus->sleeping)
 		return FALSE;
 
-	dhd_os_sdlock(bus->dhd);
 
 	/* Poll period: check device if appropriate. */
 	if (bus->poll && (++bus->polltick >= bus->pollrate)) {
@@ -4688,9 +4656,7 @@ dhd_bus_watchdog(dhd_pub_t *dhdp)
 		/* Check device if no interrupts */
 		if (!bus->intr || (bus->intrcount == bus->lastintrs)) {
 
-			// louislee : patch soft ap turn on fail problem
-			//if (!bus->dpc_sched) { // louislee
-			if (!bus->dpc_sched || gDK8) {
+			if (!bus->dpc_sched) {
 				uint8 devpend;
 				devpend = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_0,
 				                          SDIOD_CCCR_INTPEND, NULL);
@@ -4749,7 +4715,6 @@ dhd_bus_watchdog(dhd_pub_t *dhdp)
 		}
 	}
 
-	dhd_os_sdunlock(bus->dhd);
 
 	return bus->ipend;
 }
@@ -4798,9 +4763,12 @@ dhd_bus_console_in(dhd_pub_t *dhdp, uchar *msg, uint msglen)
 	if ((rv = dhdsdio_membytes(bus, TRUE, addr, (uint8 *)&val, sizeof(val))) < 0)
 		goto done;
 
-	/* Bump dongle by sending a test packet; sdpcm RX checks for virtual console input */
-	if ((pkt = PKTGET(bus->dhd->osh, 4 + SDPCM_RESERVE, TRUE)) != NULL)
-		dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, TRUE);
+	/* Bump dongle by sending an empty event pkt.
+	 * sdpcm_sendup (RX) checks for virtual console input.
+	 */
+	if (((pkt = PKTGET(bus->dhd->osh, 4 + SDPCM_RESERVE, TRUE)) != NULL) &&
+		bus->clkstate == CLK_AVAIL)
+		dhdsdio_txpkt(bus, pkt, SDPCM_EVENT_CHANNEL, TRUE);
 
 done:
 	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
@@ -4864,7 +4832,6 @@ dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
 {
 	int ret;
 	dhd_bus_t *bus;
-	dhd_cmn_t *cmn;
 
 	/* Init global variables at run-time, not as part of the declaration.
 	 * This is required to support init/de-init of the driver. Initialization
@@ -4878,13 +4845,15 @@ dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
 	sd1idle = TRUE;
 	dhd_readahead = TRUE;
 	retrydata = FALSE;
-	dhd_doflow = TRUE;
+	dhd_doflow = FALSE;
 	dhd_dongle_memsize = 0;
 	dhd_txminmax = DHD_TXMINMAX;
 
 	forcealign = TRUE;
 
 
+	dhd_common_init();
+
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 	DHD_INFO(("%s: venid 0x%04x devid 0x%04x\n", __FUNCTION__, venid, devid));
 
@@ -4960,12 +4929,6 @@ dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
 	bus->tx_seq = SDPCM_SEQUENCE_WRAP - 1;
 	bus->usebufpool = FALSE; /* Use bufpool if allocated, else use locally malloced rxbuf */
 
-	/* attach the common module */
-	if (!(cmn = dhd_common_init(osh))) {
-		DHD_ERROR(("%s: dhd_common_init failed\n", __FUNCTION__));
-		goto fail;
-	}
-
 	/* attempt to attach to the dongle */
 	if (!(dhdsdio_probe_attach(bus, osh, sdh, regsva, devid))) {
 		DHD_ERROR(("%s: dhdsdio_probe_attach failed\n", __FUNCTION__));
@@ -4978,9 +4941,6 @@ dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
 		goto fail;
 	}
 
-	bus->dhd->cmn = cmn;
-	cmn->dhd = bus->dhd;
-
 	/* Allocate buffers */
 	if (!(dhdsdio_probe_malloc(bus, osh, sdh))) {
 		DHD_ERROR(("%s: dhdsdio_probe_malloc failed\n", __FUNCTION__));
@@ -5009,6 +4969,10 @@ dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
 	if ((ret = dhd_bus_start(bus->dhd)) != 0) {
 		DHD_ERROR(("%s: failed\n", __FUNCTION__));
 		goto fail;
+		if (ret == BCME_NOTUP)  {
+			DHD_ERROR(("%s: dongle is not responding\n", __FUNCTION__));
+			goto fail;
+		}
 	}
 	/* Ok, have the per-port tell the stack we're open for business */
 	if (dhd_net_attach(bus->dhd, 0) != 0) {
@@ -5162,11 +5126,6 @@ dhdsdio_probe_attach(struct dhd_bus *bus, osl_t *osh, void *sdh, void *regsva,
 	/* Locate an appropriately-aligned portion of hdrbuf */
 	bus->rxhdr = (uint8 *)ROUNDUP((uintptr)&bus->hdrbuf[0], DHD_SDALIGN);
 
-	if (gDK8) {
-		dhd_intr = FALSE;
-		dhd_poll = TRUE;
-	}
-
 	/* Set the poll and/or interrupt flags */
 	bus->intr = (bool)dhd_intr;
 	if ((bus->poll = (bool)dhd_poll))
@@ -5324,13 +5283,12 @@ dhdsdio_download_firmware(struct dhd_bus *bus, osl_t *osh, void *sdh)
 	bool ret;
 
 	/* Download the firmware */
-	DHD_OS_WAKE_LOCK(bus->dhd);
 	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
 
 	ret = _dhdsdio_download_firmware(bus) == 0;
 
 	dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
-	DHD_OS_WAKE_UNLOCK(bus->dhd);
+
 	return ret;
 }
 
@@ -5347,12 +5305,11 @@ dhdsdio_release(dhd_bus_t *bus, osl_t *osh)
 		bcmsdh_intr_disable(bus->sdh);
 		bcmsdh_intr_dereg(bus->sdh);
 
+		if (bus->dhd) {
+
 		dhdsdio_release_dongle(bus, osh);
 
-		if (bus->dhd) {
-			dhd_common_deinit(bus->dhd);
 			dhd_detach(bus->dhd);
-			dhd_free(bus->dhd);
 			bus->dhd = NULL;
 		}
 
@@ -5390,34 +5347,23 @@ dhdsdio_release_malloc(dhd_bus_t *bus, osl_t *osh)
 #endif
 		bus->databuf = NULL;
 	}
-
-	if (bus->vars && bus->varsz) {
-		MFREE(osh, bus->vars, bus->varsz);
-		bus->vars = NULL;
-	}
-
 }
 
 
 static void
 dhdsdio_release_dongle(dhd_bus_t *bus, osl_t *osh)
 {
-	DHD_TRACE(("%s: Enter bus->dhd 0x%08x bus->dhd->dongle_reset %d \n",
-	 __FUNCTION__, (unsigned)bus->dhd, bus->dhd->dongle_reset));
+	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
 	if (bus->dhd && bus->dhd->dongle_reset)
 		return;
 
 	if (bus->sih) {
-		if (bus->dhd) {
 		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
-		}
 #if !defined(BCMLXSDMMC)
 		si_watchdog(bus->sih, 4);
 #endif /* !defined(BCMLXSDMMC) */
-		if (bus->dhd) {
 		dhdsdio_clkctl(bus, CLK_NONE, FALSE);
-		}
 		si_detach(bus->sih);
 		if (bus->vars && bus->varsz)
 			MFREE(osh, bus->vars, bus->varsz);
@@ -5475,7 +5421,6 @@ dhdsdio_download_code_array(struct dhd_bus *bus)
 {
 	int bcmerror = -1;
 	int offset = 0;
-	unsigned char *ularray = NULL;
 
 	DHD_INFO(("%s: download embedded firmware...\n", __FUNCTION__));
 
@@ -5504,6 +5449,8 @@ dhdsdio_download_code_array(struct dhd_bus *bus)
 #ifdef DHD_DEBUG
 	/* Upload and compare the downloaded code */
 	{
+		unsigned char *ularray;
+
 		ularray = MALLOC(bus->dhd->osh, bus->ramsize);
 		/* Upload image to verify downloaded contents. */
 		offset = 0;
@@ -5536,12 +5483,11 @@ dhdsdio_download_code_array(struct dhd_bus *bus)
 		} else
 			DHD_ERROR(("%s: Download, Upload and compare succeeded.\n", __FUNCTION__));
 
+		MFREE(bus->dhd->osh, ularray, bus->ramsize);
 	}
 #endif /* DHD_DEBUG */
 
 err:
-	if (ularray)
-		MFREE(bus->dhd->osh, ularray, bus->ramsize);
 	return bcmerror;
 }
 #endif /* BCMEMBEDIMAGE */
@@ -5859,19 +5805,15 @@ dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
 
 	if (flag == TRUE) {
 		if (!bus->dhd->dongle_reset) {
+			dhd_os_sdlock(dhdp);
+			/* Turning off watchdog */
+			dhd_os_wd_timer(dhdp, 0);
 #if !defined(IGNORE_ETH0_DOWN)
 			/* Force flow control as protection when stop come before ifconfig_down */
 			dhd_txflowcontrol(bus->dhd, 0, ON);
 #endif /* !defined(IGNORE_ETH0_DOWN) */
-			/* save country settinng if was pre-setup with priv ioctl */
-			dhd_os_proto_block(dhdp);
-			/* This is killing softap resets...
-			dhd_wl_ioctl_cmd(bus->dhd, WLC_GET_COUNTRY,
-				bus->dhd->country_code, sizeof(bus->dhd->country_code), FALSE, 0);*/
-			dhd_os_proto_unblock(dhdp);
 			/* Expect app to have torn down any connection before calling */
 			/* Stop the bus, disable F2 */
-			dhd_os_sdlock(dhdp);
 			dhd_bus_stop(bus, FALSE);
 
 			/* Clean tx/rx buffer pointers, detach from the dongle */
@@ -5906,8 +5848,8 @@ dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
 					dhdsdio_download_firmware(bus, bus->dhd->osh, bus->sdh)) {
 
 					/* Re-init bus, enable F2 transfer */
-					dhd_bus_init((dhd_pub_t *) bus->dhd, FALSE);
-
+					bcmerror = dhd_bus_init((dhd_pub_t *) bus->dhd, FALSE);
+					if (bcmerror == BCME_OK) {
 #if defined(OOB_INTR_ONLY)
 					dhd_enable_oob_intr(bus, TRUE);
 #endif /* defined(OOB_INTR_ONLY) */
@@ -5919,8 +5861,14 @@ dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
 					/* Restore flow control  */
 					dhd_txflowcontrol(bus->dhd, 0, OFF);
 #endif 
+						/* Turning on watchdog back */
+						dhd_os_wd_timer(dhdp, dhd_watchdog_ms);
 
 					DHD_TRACE(("%s: WLAN ON DONE\n", __FUNCTION__));
+					} else {
+						dhd_bus_stop(bus, FALSE);
+						dhdsdio_release_dongle(bus, bus->dhd->osh);
+					}
 				} else
 					bcmerror = BCME_SDIO_ERROR;
 			} else
@@ -5935,36 +5883,3 @@ dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
 	}
 	return bcmerror;
 }
-
-int
-dhd_bus_membytes(dhd_pub_t *dhdp, bool set, uint32 address, uint8 *data, uint size)
-{
-	dhd_bus_t *bus;
-
-	bus = dhdp->bus;
-	return dhdsdio_membytes(bus, set, address, data, size);
-}
-
-#if defined(DONGLEOVERLAYS)
-int
-dhd_bus_overlay_dl(dhd_pub_t *dhdp, int ifindex, uint8 *overlay, uint osize, int32 idx,
-                   uint32 region)
-{
-	dhd_bus_t *bus;
-	int ret = BCME_OK;
-
-	bus = dhdp->bus;
-
-	/* Need to lock here to protect txseq and SDIO tx calls */
-	dhd_os_sdlock(bus->dhd);
-
-	BUS_WAKE(bus);
-	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
-	if ((ret = dhdsdio_membytes(bus, TRUE, region, overlay, osize)))
-		DHD_ERROR(("%s: dhdsdio_membytes failed w/status %d\n", __FUNCTION__, ret));
-	/* IOCTL/iovar should follow so leave clock on */
-	dhd_os_sdunlock(bus->dhd);
-
-	return ret;
-}
-#endif /* DONGLEOVERLAYS */
diff --git a/drivers/net/wireless/bcm43291/src/include/bcmcdc.h b/drivers/net/wireless/bcm43291/src/include/bcmcdc.h
index a708fb8..c2a860b 100644
--- a/drivers/net/wireless/bcm43291/src/include/bcmcdc.h
+++ b/drivers/net/wireless/bcm43291/src/include/bcmcdc.h
@@ -24,7 +24,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmcdc.h,v 13.14.16.3.16.4.20.3.20.1 2010/04/25 22:22:01 Exp $
+ * $Id: bcmcdc.h,v 13.14.16.3.16.4 2009/04/12 16:58:45 Exp $
  */
 #include <proto/ethernet.h>
 
@@ -48,11 +48,6 @@ typedef struct cdc_ioctl {
 /* CDC flag definitions */
 #define CDCF_IOC_ERROR		0x01	/* 0=success, 1=ioctl cmd failed */
 #define CDCF_IOC_SET		0x02	/* 0=get, 1=set cmd */
-#define CDCF_IOC_OVL_IDX_MASK	0x3c	/* overlay region index mask */
-#define CDCF_IOC_OVL_RSV	0x40	/* 1=reserve this overlay region */
-#define CDCF_IOC_OVL		0x80	/* 1=this ioctl corresponds to an overlay */
-#define CDCF_IOC_ACTION_MASK	0xfe	/* SET/GET, OVL_IDX, OVL_RSV, OVL mask */
-#define CDCF_IOC_ACTION_SHIFT	1	/* SET/GET, OVL_IDX, OVL_RSV, OVL shift */
 #define CDCF_IOC_IF_MASK	0xF000	/* I/F index */
 #define CDCF_IOC_IF_SHIFT	12
 #define CDCF_IOC_ID_MASK	0xFFFF0000	/* used to uniquely id an ioctl req/resp pairing */
@@ -74,8 +69,7 @@ typedef struct cdc_ioctl {
 
 #define	BDC_HEADER_LEN		4
 
-#define BDC_PROTO_VER_1		1	/* Protocol version */
-#define BDC_PROTO_VER		2	/* Protocol version */
+#define BDC_PROTO_VER		1	/* Protocol version */
 
 #define BDC_FLAG_VER_MASK	0xf0	/* Protocol version mask */
 #define BDC_FLAG_VER_SHIFT	4	/* Protocol version shift */
@@ -102,5 +96,5 @@ struct bdc_header {
 	uint8	flags;			/* Flags */
 	uint8	priority;	/* 802.1d Priority 0:2 bits, 4:7 flow control info for usb */
 	uint8	flags2;
-	uint8	dataOffset;
+	uint8	rssi;
 };
diff --git a/drivers/net/wireless/bcm43291/src/include/bcmdefs.h b/drivers/net/wireless/bcm43291/src/include/bcmdefs.h
index 502ee6e..67d1158 100644
--- a/drivers/net/wireless/bcm43291/src/include/bcmdefs.h
+++ b/drivers/net/wireless/bcm43291/src/include/bcmdefs.h
@@ -20,7 +20,7 @@
  *      Notwithstanding the above, under no circumstances may you combine this
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
- * $Id: bcmdefs.h,v 13.38.4.10.2.7.6.7.4.8.2.2 2010/10/01 18:12:43 Exp $
+ * $Id: bcmdefs.h,v 13.38.4.10.2.7.6.11 2010/02/01 05:51:55 Exp $
  */
 
 
@@ -52,22 +52,6 @@
 #define STATIC	static
 
 
-
-#define OVERLAY_INLINE
-#define OSTATIC			static
-#define BCMOVERLAYDATA(_ovly, _sym)	_sym
-#define BCMOVERLAYFN(_ovly, _fn)	_fn
-#define BCMOVERLAYERRFN(_fn)	_fn
-#define BCMROMOVERLAYDATA(_ovly, _data)	_data
-#define BCMROMOVERLAYFN(_ovly, _fn)		_fn
-#define BCMATTACHOVERLAYDATA(_ovly, _sym)	_sym
-#define BCMATTACHOVERLAYFN(_ovly, _fn)		_fn
-#define BCMINITOVERLAYDATA(_ovly, _sym)		_sym
-#define BCMINITOVERLAYFN(_ovly, _fn)		_fn
-#define BCMUNINITOVERLAYFN(_ovly, _fn)		_fn
-
-
-
 #define	SI_BUS			0	
 #define	PCI_BUS			1	
 #define	PCMCIA_BUS		2	
@@ -118,13 +102,7 @@
 #define	DMADDRWIDTH_64  64 
 
 
-
-
-#if defined(BCMCHIPID) && (BCMCHIPID == BCM4319_CHIP_ID)
-#define BCMEXTRAHDROOM 172
-#else
 #define BCMEXTRAHDROOM 164
-#endif 
 
 
 #define BCMDONGLEHDRSZ 12
diff --git a/drivers/net/wireless/bcm43291/src/include/bcmdevs.h b/drivers/net/wireless/bcm43291/src/include/bcmdevs.h
index 7d5cce5..14853f1 100644
--- a/drivers/net/wireless/bcm43291/src/include/bcmdevs.h
+++ b/drivers/net/wireless/bcm43291/src/include/bcmdevs.h
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmdevs.h,v 13.172.4.5.4.10.2.13.4.10.2.3 2010/10/11 15:01:03 Exp $
+ * $Id: bcmdevs.h,v 13.172.4.5.4.10.2.36 2010/05/25 08:33:44 Exp $
  */
 
 
@@ -58,6 +58,7 @@
 #define BCM4329_D11NDUAL_ID	0x432e		
 #define BCM4329_D11N2G_ID	0x432f		
 #define BCM4329_D11N5G_ID	0x4330		
+#define BCM4336_D11N_ID		0x4343		
 #define	BCM4315_D11DUAL_ID	0x4334		
 #define	BCM4315_D11G_ID		0x4335		
 #define	BCM4315_D11A_ID		0x4336		
@@ -90,6 +91,7 @@
 #define	BCM4325_CHIP_ID		0x4325		
 #define	BCM4328_CHIP_ID		0x4328		
 #define	BCM4329_CHIP_ID		0x4329		
+#define BCM4336_CHIP_ID		0x4336		
 #define	BCM4402_CHIP_ID		0x4402		
 #define	BCM4704_CHIP_ID		0x4704		
 #define	BCM4710_CHIP_ID		0x4710		
@@ -119,10 +121,4 @@
 #define HWSIM_PKG_ID		15		
 
 
-
-#define RDL_RAM_BASE_4319 0x60000000
-#define RDL_RAM_BASE_4329 0x60000000
-#define RAM_SIZE_4319 0x48000
-#define RAM_SIZE_4329  0x48000
-
 #endif 
diff --git a/drivers/net/wireless/bcm43291/src/include/bcmsdbus.h b/drivers/net/wireless/bcm43291/src/include/bcmsdbus.h
index e120af7..b7b67bc 100644
--- a/drivers/net/wireless/bcm43291/src/include/bcmsdbus.h
+++ b/drivers/net/wireless/bcm43291/src/include/bcmsdbus.h
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdbus.h,v 13.11.14.2.6.4.20.1.22.2 2010/11/02 03:17:04 Exp $
+ * $Id: bcmsdbus.h,v 13.11.14.2.6.6 2009/10/27 17:20:28 Exp $
  */
 
 #ifndef	_sdio_api_h_
@@ -106,9 +106,6 @@ extern int sdioh_abort(sdioh_info_t *si, uint fnc);
 extern int sdioh_start(sdioh_info_t *si, int stage);
 extern int sdioh_stop(sdioh_info_t *si);
 
-/* Wait system lock free */
-extern int sdioh_waitlockfree(sdioh_info_t *si);
-
 /* Reset and re-initialize the device */
 extern int sdioh_sdio_reset(sdioh_info_t *si);
 
diff --git a/drivers/net/wireless/bcm43291/src/include/bcmsdh.h b/drivers/net/wireless/bcm43291/src/include/bcmsdh.h
index 0be220e..e69a259 100644
--- a/drivers/net/wireless/bcm43291/src/include/bcmsdh.h
+++ b/drivers/net/wireless/bcm43291/src/include/bcmsdh.h
@@ -23,7 +23,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdh.h,v 13.35.14.7.6.6.20.2.22.1 2010/08/26 21:39:25 Exp $
+ * $Id: bcmsdh.h,v 13.35.14.7.6.8 2009/10/14 04:22:25 Exp $
  */
 
 #ifndef	_bcmsdh_h_
@@ -157,9 +157,6 @@ extern int bcmsdh_start(void *sdh, int stage);
 /* Stop SDIO Host Controller communication */
 extern int bcmsdh_stop(void *sdh);
 
-/* Wait system lock free */
-extern int bcmsdh_waitlockfree(void *sdh);
-
 /* Returns the "Device ID" of target device on the SDIO bus. */
 extern int bcmsdh_query_device(void *sdh);
 
diff --git a/drivers/net/wireless/bcm43291/src/include/bcmsdh_sdmmc.h b/drivers/net/wireless/bcm43291/src/include/bcmsdh_sdmmc.h
index 483a887..4e6d1b5 100644
--- a/drivers/net/wireless/bcm43291/src/include/bcmsdh_sdmmc.h
+++ b/drivers/net/wireless/bcm43291/src/include/bcmsdh_sdmmc.h
@@ -21,19 +21,18 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdh_sdmmc.h,v 13.1.2.1.8.5.20.1.22.1 2010/11/02 03:17:59 Exp $
+ * $Id: bcmsdh_sdmmc.h,v 13.1.2.1.8.7 2009/10/27 18:22:52 Exp $
  */
 
 #ifndef __BCMSDH_SDMMC_H__
 #define __BCMSDH_SDMMC_H__
 
-// louislee : debug
-#define sd_err(x)   printk x
-#define sd_trace(x)   //printk x
-#define sd_info(x)   //printk x
-#define sd_debug(x)   //printk x
-#define sd_data(x)   //printk x
-#define sd_ctrl(x)   //printk x
+#define sd_err(x)
+#define sd_trace(x)
+#define sd_info(x)
+#define sd_debug(x)
+#define sd_data(x)
+#define sd_ctrl(x)
 
 #define sd_sync_dma(sd, read, nbytes)
 #define sd_init_dma(sd)
diff --git a/drivers/net/wireless/bcm43291/src/include/bcmsdpcm.h b/drivers/net/wireless/bcm43291/src/include/bcmsdpcm.h
index 75260d7..77aca45 100644
--- a/drivers/net/wireless/bcm43291/src/include/bcmsdpcm.h
+++ b/drivers/net/wireless/bcm43291/src/include/bcmsdpcm.h
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdpcm.h,v 1.1.2.3.20.1.2.1 2010/06/25 03:39:43 Exp $
+ * $Id: bcmsdpcm.h,v 1.1.2.4 2010/07/02 01:15:46 Exp $
  */
 
 #ifndef	_bcmsdpcm_h_
@@ -67,11 +67,10 @@
 #define HMB_MASK	0x0000000f	/* To Host Mailbox Mask */
 
 /* tohostmailboxdata */
-#define HMB_DATA_NAKHANDLED	0x01	/* we're ready to retransmit NAK'd frame to host */
-#define HMB_DATA_DEVREADY	0x02	/* we're ready to to talk to host after enable */
-#define HMB_DATA_FC		0x04	/* per prio flowcontrol update flag to host */
-#define HMB_DATA_FWREADY	0x08	/* firmware is ready for protocol activity */
-#define HMB_DATA_FWHALT		0x10	/* firmware has halted operation */
+#define HMB_DATA_NAKHANDLED	1	/* we're ready to retransmit NAK'd frame to host */
+#define HMB_DATA_DEVREADY	2	/* we're ready to to talk to host after enable */
+#define HMB_DATA_FC		4	/* per prio flowcontrol update flag to host */
+#define HMB_DATA_FWREADY	8	/* firmware is ready for protocol activity */
 
 #define HMB_DATA_FCDATA_MASK	0xff000000	/* per prio flowcontrol data */
 #define HMB_DATA_FCDATA_SHIFT	24		/* per prio flowcontrol data */
@@ -261,7 +260,4 @@ typedef struct {
 
 extern sdpcm_shared_t sdpcm_shared;
 
-/* Function can be used to notify host of FW halt */
-extern void sdpcmd_fwhalt(void);
-
 #endif	/* _bcmsdpcm_h_ */
diff --git a/drivers/net/wireless/bcm43291/src/include/bcmsdstd.h b/drivers/net/wireless/bcm43291/src/include/bcmsdstd.h
index 494e7a9..974b3d4 100644
--- a/drivers/net/wireless/bcm43291/src/include/bcmsdstd.h
+++ b/drivers/net/wireless/bcm43291/src/include/bcmsdstd.h
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdstd.h,v 13.16.18.1.16.2.68.1.20.1 2010/08/26 21:39:27 Exp $
+ * $Id: bcmsdstd.h,v 13.16.18.1.16.3 2009/12/10 01:09:23 Exp $
  */
 
 /* global msglevel for debug messages - bitvals come from sdiovar.h */
@@ -218,7 +218,6 @@ extern void sdstd_free_irq(uint irq, sdioh_info_t *sd);
 /* OS-specific interrupt wrappers (atomic interrupt enable/disable) */
 extern void sdstd_lock(sdioh_info_t *sd);
 extern void sdstd_unlock(sdioh_info_t *sd);
-extern void sdstd_waitlockfree(sdioh_info_t *sd);
 
 /* OS-specific wait-for-interrupt-or-status */
 extern uint16 sdstd_waitbits(sdioh_info_t *sd, uint16 norm, uint16 err, bool yield);
diff --git a/drivers/net/wireless/bcm43291/src/include/bcmutils.h b/drivers/net/wireless/bcm43291/src/include/bcmutils.h
index fe16d10..f85ed35 100644
--- a/drivers/net/wireless/bcm43291/src/include/bcmutils.h
+++ b/drivers/net/wireless/bcm43291/src/include/bcmutils.h
@@ -20,7 +20,7 @@
  *      Notwithstanding the above, under no circumstances may you combine this
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
- * $Id: bcmutils.h,v 13.184.4.6.2.1.18.15.2.19.2.3 2010/06/30 03:10:09 Exp $
+ * $Id: bcmutils.h,v 13.184.4.6.2.1.18.25 2010/04/26 06:05:24 Exp $
  */
 
 
@@ -343,9 +343,7 @@ extern int bcm_iovar_lencheck(const bcm_iovar_t *table, void *arg, int len, bool
 #define BCME_RXFAIL			-39	
 #define BCME_NODEVICE			-40	
 #define BCME_UNFINISHED			-41	
-#define BCME_NONRESIDENT		-42	
-#define BCME_DISABLED			-43	
-#define BCME_LAST			BCME_DISABLED
+#define BCME_LAST			BCME_UNFINISHED
 
 
 #define BCMERRSTRINGTABLE {		\
@@ -391,8 +389,6 @@ extern int bcm_iovar_lencheck(const bcm_iovar_t *table, void *arg, int len, bool
 	"RX Failure",			\
 	"Device Not Present",		\
 	"Command not finished",		\
-	"Nonresident overlay access", \
-	"Disabled in this build" \
 }
 
 #ifndef ABS
@@ -560,10 +556,10 @@ xor_128bit_block(const uint8 *src1, const uint8 *src2, uint8 *dst)
 	    (((uintptr)src1 | (uintptr)src2 | (uintptr)dst) & 3) == 0) {
 		
 		
-		((uint32 *)dst)[0] = ((const uint32 *)src1)[0] ^ ((const uint32 *)src2)[0];
-		((uint32 *)dst)[1] = ((const uint32 *)src1)[1] ^ ((const uint32 *)src2)[1];
-		((uint32 *)dst)[2] = ((const uint32 *)src1)[2] ^ ((const uint32 *)src2)[2];
-		((uint32 *)dst)[3] = ((const uint32 *)src1)[3] ^ ((const uint32 *)src2)[3];
+		((uint32 *)dst)[0] = ((uint32 *)src1)[0] ^ ((uint32 *)src2)[0];
+		((uint32 *)dst)[1] = ((uint32 *)src1)[1] ^ ((uint32 *)src2)[1];
+		((uint32 *)dst)[2] = ((uint32 *)src1)[2] ^ ((uint32 *)src2)[2];
+		((uint32 *)dst)[3] = ((uint32 *)src1)[3] ^ ((uint32 *)src2)[3];
 	} else {
 		
 		int k;
@@ -582,11 +578,10 @@ extern uint32 hndcrc32(uint8 *p, uint nbytes, uint32 crc);
 	defined(WLMSG_ASSOC)
 extern int bcm_format_flags(const bcm_bit_desc_t *bd, uint32 flags, char* buf, int len);
 extern int bcm_format_hex(char *str, const void *bytes, int len);
+extern void prhex(const char *msg, uchar *buf, uint len);
 #endif 
-extern const char *bcm_crypto_algo_name(uint algo);
 extern char *bcm_brev_str(uint32 brev, char *buf);
 extern void printbig(char *buf);
-extern void prhex(const char *msg, uchar *buf, uint len);
 
 
 extern bcm_tlv_t *bcm_next_tlv(bcm_tlv_t *elt, int *buflen);
@@ -627,7 +622,10 @@ extern uint bcmdumpfields(bcmutl_rdreg_rtn func_ptr, void *arg0, uint arg1, stru
 extern uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf, uint len);
 extern uint bcm_bitcount(uint8 *bitmap, uint bytelength);
 
+#if defined(WLTINYDUMP) || defined(WLMSG_INFORM) || defined(WLMSG_ASSOC) || \
+	defined(WLMSG_PRPKT) || defined(WLMSG_WSEC)
 extern int bcm_format_ssid(char* buf, const uchar ssid[], uint ssid_len);
+#endif 
 
 
 #define SSID_FMT_BUF_LEN	((4 * DOT11_MAX_SSID_LEN) + 1)
diff --git a/drivers/net/wireless/bcm43291/src/include/bcmwifi.h b/drivers/net/wireless/bcm43291/src/include/bcmwifi.h
index 073057d..42b38fc 100644
--- a/drivers/net/wireless/bcm43291/src/include/bcmwifi.h
+++ b/drivers/net/wireless/bcm43291/src/include/bcmwifi.h
@@ -22,7 +22,7 @@
  *      Notwithstanding the above, under no circumstances may you combine this
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
- * $Id: bcmwifi.h,v 1.15.132.4.16.2 2010/06/07 21:32:42 Exp $
+ * $Id: bcmwifi.h,v 1.15.30.4 2010/03/10 20:10:52 Exp $
  */
 
 
@@ -84,14 +84,13 @@ typedef uint16 chanspec_t;
 					((channel) | (ctlsb) | WL_CHANSPEC_BW_40 | \
 					((channel) <= CH_MAX_2G_CHANNEL ? WL_CHANSPEC_BAND_2G : \
 					WL_CHANSPEC_BAND_5G))
-#define CHSPEC_CHANNEL(chspec)	((uint8)((chspec) & WL_CHANSPEC_CHAN_MASK))
-#define CHSPEC_BAND(chspec)	((chspec) & WL_CHANSPEC_BAND_MASK)
-
-#define CHSPEC_CTL_SB(chspec) (chspec & WL_CHANSPEC_CTL_SB_MASK)
-#define CHSPEC_BW(chspec)     (chspec & WL_CHANSPEC_BW_MASK)
+#define CHSPEC_CHANNEL(chspec)	((uint8)(chspec & WL_CHANSPEC_CHAN_MASK))
+#define CHSPEC_BAND(chspec)	(chspec & WL_CHANSPEC_BAND_MASK)
 
 #ifdef WL20MHZ_ONLY
 
+#define CHSPEC_CTL_SB(chspec)	WL_CHANSPEC_CTL_SB_NONE
+#define CHSPEC_BW(chspec)	WL_CHANSPEC_BW_20
 #define CHSPEC_IS10(chspec)	0
 #define CHSPEC_IS20(chspec)	1
 #ifndef CHSPEC_IS40
@@ -100,6 +99,8 @@ typedef uint16 chanspec_t;
 
 #else 
 
+#define CHSPEC_CTL_SB(chspec)	(chspec & WL_CHANSPEC_CTL_SB_MASK)
+#define CHSPEC_BW(chspec)	(chspec & WL_CHANSPEC_BW_MASK)
 #define CHSPEC_IS10(chspec)	((chspec & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_10)
 #define CHSPEC_IS20(chspec)	((chspec & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_20)
 #ifndef CHSPEC_IS40
@@ -108,21 +109,8 @@ typedef uint16 chanspec_t;
 
 #endif 
 
-
-#if defined(BAND5G)
-#if defined(BAND2G)
 #define CHSPEC_IS5G(chspec)	((chspec & WL_CHANSPEC_BAND_MASK) == WL_CHANSPEC_BAND_5G)
 #define CHSPEC_IS2G(chspec)	((chspec & WL_CHANSPEC_BAND_MASK) == WL_CHANSPEC_BAND_2G)
-#else
-#define CHSPEC_IS5G(chspec)	1
-#define CHSPEC_IS2G(chspec)	0
-#endif 
-#else
-#define CHSPEC_IS5G(chspec)	0
-#define CHSPEC_IS2G(chspec)	1
-#endif 
-
-
 #define CHSPEC_SB_NONE(chspec)	((chspec & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_NONE)
 #define CHSPEC_SB_UPPER(chspec)	((chspec & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_UPPER)
 #define CHSPEC_SB_LOWER(chspec)	((chspec & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_LOWER)
@@ -157,9 +145,6 @@ extern char * wf_chspec_ntoa(chanspec_t chspec, char *buf);
 extern chanspec_t wf_chspec_aton(char *a);
 
 
-extern chanspec_t wf_chspec_ctlchspec(chanspec_t chspec);
-
-
 extern int wf_mhz2channel(uint freq, uint start_factor);
 
 
diff --git a/drivers/net/wireless/bcm43291/src/include/dhdioctl.h b/drivers/net/wireless/bcm43291/src/include/dhdioctl.h
index 504e2fe..8a61487 100644
--- a/drivers/net/wireless/bcm43291/src/include/dhdioctl.h
+++ b/drivers/net/wireless/bcm43291/src/include/dhdioctl.h
@@ -25,7 +25,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhdioctl.h,v 13.7.8.1.4.1.16.2.92.2 2010/11/09 03:19:31 Exp $
+ * $Id: dhdioctl.h,v 13.7.8.1.4.1.16.5 2010/05/21 21:49:38 Exp $
  */
 
 #ifndef _dhdioctl_h_
@@ -50,12 +50,6 @@ typedef struct dhd_ioctl {
 	uint driver;	/* to identify target driver */
 } dhd_ioctl_t;
 
-/* Underlying BUS definition */
-enum {
-	BUS_TYPE_USB = 0, /* for USB dongles */
-	BUS_TYPE_SDIO /* for SDIO dongles */
-};
-
 /* per-driver magic numbers */
 #define DHD_IOCTL_MAGIC		0x00444944
 
diff --git a/drivers/net/wireless/bcm43291/src/include/epivers.h b/drivers/net/wireless/bcm43291/src/include/epivers.h
index 12371cc..5183e0e 100644
--- a/drivers/net/wireless/bcm43291/src/include/epivers.h
+++ b/drivers/net/wireless/bcm43291/src/include/epivers.h
@@ -29,20 +29,20 @@
 
 #define	EPI_MAJOR_VERSION	4
 
-#define	EPI_MINOR_VERSION	220
+#define	EPI_MINOR_VERSION	218
 
-#define	EPI_RC_NUMBER		17
+#define	EPI_RC_NUMBER		248
 
-#define	EPI_INCREMENTAL_NUMBER	0
+#define	EPI_INCREMENTAL_NUMBER	21
 
 #define	EPI_BUILD_NUMBER	0
 
-#define	EPI_VERSION		4, 220, 17, 0
+#define	EPI_VERSION		4, 218, 248, 21
 
-#define	EPI_VERSION_NUM		0x04dc1100
+#define	EPI_VERSION_NUM		0x04daf815
 
 
-#define	EPI_VERSION_STR		"4.220.17.0"
-#define	EPI_ROUTER_VERSION_STR	"4.221.17.0"
+#define	EPI_VERSION_STR		"4.218.248.21"
+#define	EPI_ROUTER_VERSION_STR	"4.219.248.21"
 
 #endif 
diff --git a/drivers/net/wireless/bcm43291/src/include/epivers.sh b/drivers/net/wireless/bcm43291/src/include/epivers.sh
index bbac27d..dd33823 100644
--- a/drivers/net/wireless/bcm43291/src/include/epivers.sh
+++ b/drivers/net/wireless/bcm43291/src/include/epivers.sh
@@ -32,7 +32,7 @@ else
 	#    <NAME>_REL_<MAJ>_<MINOR>_RC<RCNUM>_<INCREMENTAL>
 	#    
  
-	CVSTAG="$Name: ROMTERM3_REL_4_220_17 $"
+	CVSTAG="$Name: ROMTERM_REL_4_218_248_21 $"
 
 	# Remove leading cvs "Name: " and trailing " $"
 	CVSTAG=${CVSTAG/#*: /}
diff --git a/drivers/net/wireless/bcm43291/src/include/hndpmu.h b/drivers/net/wireless/bcm43291/src/include/hndpmu.h
index 4c5a9c1..e829b3d 100644
--- a/drivers/net/wireless/bcm43291/src/include/hndpmu.h
+++ b/drivers/net/wireless/bcm43291/src/include/hndpmu.h
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: hndpmu.h,v 13.14.4.3.4.3.8.4.8.1 2009/06/26 05:32:21 Exp $
+ * $Id: hndpmu.h,v 13.14.4.3.4.3.8.7 2010/04/09 13:20:51 Exp $
  */
 
 #ifndef _hndpmu_h_
diff --git a/drivers/net/wireless/bcm43291/src/include/hndrte_armtrap.h b/drivers/net/wireless/bcm43291/src/include/hndrte_armtrap.h
index eb27c9c..ca3281b 100644
--- a/drivers/net/wireless/bcm43291/src/include/hndrte_armtrap.h
+++ b/drivers/net/wireless/bcm43291/src/include/hndrte_armtrap.h
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: hndrte_armtrap.h,v 13.3.404.1.24.1 2010/07/15 19:58:23 Exp $
+ * $Id: hndrte_armtrap.h,v 13.3.196.2 2010/07/15 19:06:11 Exp $
  */
 
 #ifndef	_hndrte_armtrap_h
diff --git a/drivers/net/wireless/bcm43291/src/include/hndrte_cons.h b/drivers/net/wireless/bcm43291/src/include/hndrte_cons.h
index 3f72474..a424174 100644
--- a/drivers/net/wireless/bcm43291/src/include/hndrte_cons.h
+++ b/drivers/net/wireless/bcm43291/src/include/hndrte_cons.h
@@ -21,21 +21,12 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: hndrte_cons.h,v 13.1.2.2.106.1 2010/07/15 19:58:23 Exp $
+ * $Id: hndrte_cons.h,v 13.1.2.4 2010/07/15 19:06:11 Exp $
  */
 
 #include <typedefs.h>
 
-#ifdef RWL_DONGLE
-/* For Dongle uart tranport max cmd len is 256 bytes + header length (16 bytes)
- *  In case of ASD commands we are not sure about how much is the command size
- *  To be on the safe side, input buf len CBUF_LEN is increased to max (512) bytes.
- */
-#define RWL_MAX_DATA_LEN	(512 + 8)	/* allow some extra bytes for '/n' termination */
-#define CBUF_LEN	(RWL_MAX_DATA_LEN + 64)  /* allow 64 bytes for header ("rwl...") */
-#else
 #define CBUF_LEN	(128)
-#endif
 
 #define LOG_BUF_LEN	1024
 
diff --git a/drivers/net/wireless/bcm43291/src/include/linux_osl.h b/drivers/net/wireless/bcm43291/src/include/linux_osl.h
index 0f63bff..f44bc83 100644
--- a/drivers/net/wireless/bcm43291/src/include/linux_osl.h
+++ b/drivers/net/wireless/bcm43291/src/include/linux_osl.h
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: linux_osl.h,v 13.131.30.1.48.5.2.1 2010/09/08 22:04:06 Exp $
+ * $Id: linux_osl.h,v 13.131.30.8 2010/04/26 05:42:18 Exp $
  */
 
 
diff --git a/drivers/net/wireless/bcm43291/src/include/linuxver.h b/drivers/net/wireless/bcm43291/src/include/linuxver.h
index d76c81a..d2fa6ae 100644
--- a/drivers/net/wireless/bcm43291/src/include/linuxver.h
+++ b/drivers/net/wireless/bcm43291/src/include/linuxver.h
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: linuxver.h,v 13.38.8.1.8.2.30.3.2.1 2010/11/02 03:58:36 Exp $
+ * $Id: linuxver.h,v 13.38.8.1.8.6 2010/04/29 05:00:46 Exp $
  */
 
 
@@ -429,6 +429,54 @@ pci_restore_state(struct pci_dev *dev, u32 *buffer)
 #define CHECKSUM_HW	CHECKSUM_PARTIAL
 #endif
 
+/* hyeok-debug -S */
+typedef struct {
+        void    *parent;
+        struct  task_struct *p_task;
+        long    thr_pid;
+        int     prio;
+        struct  semaphore sema;
+        bool    terminated;
+        struct  completion completed;
+} tsk_ctl_t;
+
+
+#ifdef DHD_DEBUG
+#define DBG_THR(x) printk x
+#else
+#define DBG_THR(x)
+#endif
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
+#define SMP_RD_BARRIER_DEPENDS(x) smp_read_barrier_depends(x)
+#else
+#define SMP_RD_BARRIER_DEPENDS(x) smp_rmb(x)
+#endif
+
+#define PROC_START(thread_func, owner, tsk_ctl, flags) \
+{ \
+        sema_init(&((tsk_ctl)->sema), 0); \
+        init_completion(&((tsk_ctl)->completed)); \
+        (tsk_ctl)->parent = owner; \
+        (tsk_ctl)->terminated = FALSE; \
+        (tsk_ctl)->thr_pid = kernel_thread(thread_func, tsk_ctl, flags); \
+        if ((tsk_ctl)->thr_pid > 0 ) \
+                wait_for_completion(&((tsk_ctl)->completed)); \
+        DBG_THR(("%s thr:%lx started\n", __FUNCTION__, (tsk_ctl)->thr_pid)); \
+}
+
+#define PROC_STOP(tsk_ctl) \
+{ \
+        (tsk_ctl)->terminated = TRUE; \
+        smp_wmb(); \
+        up(&((tsk_ctl)->sema)); \
+        wait_for_completion(&((tsk_ctl)->completed)); \
+        DBG_THR(("%s thr:%lx terminated OK\n", __FUNCTION__, (tsk_ctl)->thr_pid)); \
+        (tsk_ctl)->thr_pid = -1; \
+}
+/* hyeok-debug -E */
+
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31))
 #define KILL_PROC(nr, sig) \
 { \
diff --git a/drivers/net/wireless/bcm43291/src/include/packed_section_start.h b/drivers/net/wireless/bcm43291/src/include/packed_section_start.h
index 7f60ef1..cb93aa6 100644
--- a/drivers/net/wireless/bcm43291/src/include/packed_section_start.h
+++ b/drivers/net/wireless/bcm43291/src/include/packed_section_start.h
@@ -34,7 +34,7 @@
  *      Notwithstanding the above, under no circumstances may you combine this
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
- * $Id: packed_section_start.h,v 1.1.6.3.150.1 2010/09/08 22:04:06 Exp $
+ * $Id: packed_section_start.h,v 1.1.6.3 2008/12/10 00:27:54 Exp $
  */
 
 
@@ -52,7 +52,7 @@
 
 #if defined(__GNUC__)
 	#define	BWL_PRE_PACKED_STRUCT
-	#define	BWL_POST_PACKED_STRUCT	__attribute__ ((packed))
+	#define	BWL_POST_PACKED_STRUCT	__attribute__((packed))
 #elif defined(__CC_ARM)
 	#define	BWL_PRE_PACKED_STRUCT	__packed
 	#define	BWL_POST_PACKED_STRUCT
diff --git a/drivers/net/wireless/bcm43291/src/include/proto/802.11.h b/drivers/net/wireless/bcm43291/src/include/proto/802.11.h
index 64fcee4..4336b97 100644
--- a/drivers/net/wireless/bcm43291/src/include/proto/802.11.h
+++ b/drivers/net/wireless/bcm43291/src/include/proto/802.11.h
@@ -21,7 +21,7 @@
  *
  * Fundamental types and constants relating to 802.11
  *
- * $Id: 802.11.h,v 9.219.4.1.4.5.6.9.4.3.2.4 2010/09/03 21:28:04 Exp $
+ * $Id: 802.11.h,v 9.219.4.1.4.5.6.11 2010/02/09 13:23:26 Exp $
  */
 
 
@@ -225,7 +225,6 @@ BWL_PRE_PACKED_STRUCT struct dot11_bcn_prb {
 	uint16			capability;
 } BWL_POST_PACKED_STRUCT;
 #define	DOT11_BCN_PRB_LEN	12		
-#define	DOT11_BCN_PRB_FIXED_LEN	12		
 
 BWL_PRE_PACKED_STRUCT struct dot11_auth {
 	uint16			alg;		
@@ -362,15 +361,25 @@ BWL_PRE_PACKED_STRUCT struct dot11_action_switch_channel {
 	dot11_brcm_extch_ie_t extch_ie;		
 } BWL_POST_PACKED_STRUCT;
 
-
-BWL_PRE_PACKED_STRUCT struct dot11_ext_csa {
-	uint8 id;	
-	uint8 len;	
+BWL_PRE_PACKED_STRUCT struct dot11_csa_body {
 	uint8 mode;	
 	uint8 reg;	
 	uint8 channel;	
 	uint8 count;	
 } BWL_POST_PACKED_STRUCT;
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_ext_csa {
+	uint8 id;	
+	uint8 len;	
+	struct dot11_csa_body b; 
+} BWL_POST_PACKED_STRUCT;
+
+BWL_PRE_PACKED_STRUCT struct dot11y_action_ext_csa {
+	uint8	category;
+	uint8	action;
+	struct dot11_csa_body b;	
+} BWL_POST_PACKED_STRUCT;
 typedef struct dot11_ext_csa dot11_ext_csa_ie_t;
 #define DOT11_EXT_CSA_IE_LEN	4	
 
@@ -414,21 +423,11 @@ typedef struct dot11_extcap_ie dot11_extcap_ie_t;
 #define DOT11_MEASURE_TYPE_BASIC 	0	
 #define DOT11_MEASURE_TYPE_CCA 		1	
 #define DOT11_MEASURE_TYPE_RPI		2	
-#define DOT11_MEASURE_TYPE_CHLOAD		3	
-#define DOT11_MEASURE_TYPE_NOISE		4	
-#define DOT11_MEASURE_TYPE_BEACON		5	
-#define DOT11_MEASURE_TYPE_FRAME	6	
-#define DOT11_MEASURE_TYPE_STATS		7	
-#define DOT11_MEASURE_TYPE_LCI		8	
-#define DOT11_MEASURE_TYPE_TXSTREAM		9	
-#define DOT11_MEASURE_TYPE_PAUSE		255	
 
 
-#define DOT11_MEASURE_MODE_PARALLEL 	(1<<0)	
 #define DOT11_MEASURE_MODE_ENABLE 	(1<<1)	
 #define DOT11_MEASURE_MODE_REQUEST	(1<<2)	
 #define DOT11_MEASURE_MODE_REPORT 	(1<<3)	
-#define DOT11_MEASURE_MODE_DUR 	(1<<4)	
 
 #define DOT11_MEASURE_MODE_LATE 	(1<<0)	
 #define DOT11_MEASURE_MODE_INCAPABLE	(1<<1)	
@@ -697,9 +696,8 @@ BWL_PRE_PACKED_STRUCT struct dot11_management_notification {
 
 #define DOT11_OPEN_SYSTEM	0	
 #define DOT11_SHARED_KEY	1	
-#define DOT11_FAST_BSS		2	
 
-#define DOT11_OPEN_SHARED	3	
+#define DOT11_OPEN_SHARED	2	
 #define DOT11_CHALLENGE_LEN	128	
 
 
@@ -924,9 +922,6 @@ BWL_PRE_PACKED_STRUCT struct dot11_management_notification {
 
 #define	DOT11_SC_DECLINED		37	
 #define	DOT11_SC_INVALID_PARAMS		38	
-#define	DOT11_SC_INVALID_AKMP		43	
-#define	DOT11_SC_INVALID_MDID		54	
-#define	DOT11_SC_INVALID_FTIE		55	
 
 
 #define DOT11_MNG_DS_PARAM_LEN			1	
@@ -977,17 +972,11 @@ BWL_PRE_PACKED_STRUCT struct dot11_management_notification {
 #define DOT11_MNG_NONERP_ID			47	
 #define DOT11_MNG_RSN_ID			48	
 #define DOT11_MNG_EXT_RATES_ID			50	
-#define DOT11_MNG_AP_CHREP_ID		51	
-#define DOT11_MNG_NBR_REP_ID		52	
-#define DOT11_MNG_MDIE_ID		54	
-#define DOT11_MNG_FTIE_ID		55	
-#define DOT11_MNG_FT_TI_ID		56	
 #define	DOT11_MNG_REGCLASS_ID			59	
 #define DOT11_MNG_EXT_CSA_ID			60	
 #define	DOT11_MNG_HT_ADD			61	
 #define	DOT11_MNG_EXT_CHANNEL_OFFSET		62	
-
-#define DOT11_MNG_RRM_CAP_ID		70	
+#define DOT11_MNG_WAPI_ID				68	
 #define	DOT11_MNG_HT_BSS_COEXINFO_ID		72	
 #define	DOT11_MNG_HT_BSS_CHANNEL_REPORT_ID	73	
 #define	DOT11_MNG_HT_OBSS_ID			74	
@@ -995,8 +984,6 @@ BWL_PRE_PACKED_STRUCT struct dot11_management_notification {
 #define DOT11_MNG_WPA_ID			221	
 #define DOT11_MNG_PROPR_ID			221	
 
-#define DOT11_MNG_VS_ID				221	
-
 
 #define DOT11_RATE_BASIC			0x80	
 #define DOT11_RATE_MASK				0x7F	
@@ -1021,7 +1008,6 @@ BWL_PRE_PACKED_STRUCT struct dot11_management_notification {
 #define DOT11_CAP_AGILITY			0x0080	
 #define DOT11_CAP_SPECTRUM			0x0100	
 #define DOT11_CAP_SHORTSLOT			0x0400	
-#define DOT11_CAP_RRM				0x1000	
 #define DOT11_CAP_CCK_OFDM			0x2000	
 
 
@@ -1029,21 +1015,14 @@ BWL_PRE_PACKED_STRUCT struct dot11_management_notification {
 
 
 #define DOT11_ACTION_HDR_LEN		2	
-#define DOT11_ACTION_CAT_OFF		0	
-#define DOT11_ACTION_ACT_OFF		1	
 #define DOT11_ACTION_CAT_ERR_MASK	0x80	
 #define DOT11_ACTION_CAT_MASK		0x7F	
 #define DOT11_ACTION_CAT_SPECT_MNG	0	
-#define DOT11_ACTION_CAT_QOS		1	
-#define DOT11_ACTION_CAT_DLS		2	
 #define DOT11_ACTION_CAT_BLOCKACK	3	
 #define DOT11_ACTION_CAT_PUBLIC		4	
-#define DOT11_ACTION_CAT_RRM		5	
-#define DOT11_ACTION_CAT_FBT	6	
 #define DOT11_ACTION_CAT_HT		7	
-#define DOT11_ACTION_CAT_BSSMGMT	10	
-#define DOT11_ACTION_NOTIFICATION	17
 #define DOT11_ACTION_CAT_VS		127	
+#define DOT11_ACTION_NOTIFICATION	0x11	
 
 #define DOT11_ACTION_ID_M_REQ		0	
 #define DOT11_ACTION_ID_M_REP		1	
@@ -1057,7 +1036,7 @@ BWL_PRE_PACKED_STRUCT struct dot11_management_notification {
 #define DOT11_ACTION_ID_HT_MIMO_PS	1	
 
 
-#define DOT11_ACTION_ID_BSS_COEX_MNG	0	
+#define DOT11_PUB_ACTION_BSS_COEX_MNG	0	
 #define DOT11_PUB_ACTION_CHANNEL_SWITCH	4	
 
 
@@ -1115,138 +1094,6 @@ typedef struct dot11_delba dot11_delba_t;
 #define DOT11_DELBA_LEN			6	
 
 
-
-
-
-#define DOT11_RRM_CAP_LEN		5	
-BWL_PRE_PACKED_STRUCT struct dot11_rrm_cap_ie {
-	uint8 cap[DOT11_RRM_CAP_LEN];
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rrm_cap_ie dot11_rrm_cap_ie_t;
-
-
-#define DOT11_RRM_CAP_LINK			0
-#define DOT11_RRM_CAP_NEIGHBOR_REPORT	1
-#define DOT11_RRM_CAP_PARALLEL		2
-#define DOT11_RRM_CAP_REPEATED		3
-#define DOT11_RRM_CAP_BCN_PASSIVE	4
-#define DOT11_RRM_CAP_BCN_ACTIVE	5
-#define DOT11_RRM_CAP_BCN_TABLE		6
-#define DOT11_RRM_CAP_BCN_REP_COND	7
-#define DOT11_RRM_CAP_AP_CHANREP	16
-
-
-#define DOT11_RM_ACTION_RM_REQ		0	
-#define DOT11_RM_ACTION_RM_REP		1	
-#define DOT11_RM_ACTION_LM_REQ		2	
-#define DOT11_RM_ACTION_LM_REP		3	
-#define DOT11_RM_ACTION_NR_REQ		4	
-#define DOT11_RM_ACTION_NR_REP		5	
-
-
-BWL_PRE_PACKED_STRUCT struct dot11_rm_action {
-	uint8 category;				
-	uint8 action;				
-	uint8 token;				
-	uint8 data[1];
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rm_action dot11_rm_action_t;
-#define DOT11_RM_ACTION_LEN 3
-
-BWL_PRE_PACKED_STRUCT struct dot11_rmreq {
-	uint8 category;				
-	uint8 action;				
-	uint8 token;				
-	uint16 reps;				
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rmreq dot11_rmreq_t;
-#define DOT11_RMREQ_LEN	5
-
-BWL_PRE_PACKED_STRUCT struct dot11_rm_ie {
-	uint8 id;
-	uint8 len;
-	uint8 token;
-	uint8 mode;
-	uint8 type;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rm_ie dot11_rm_ie_t;
-#define DOT11_RM_IE_LEN	5
-
-
-#define DOT11_RMREQ_MODE_PARALLEL	1
-#define DOT11_RMREQ_MODE_ENABLE		2
-#define DOT11_RMREQ_MODE_REQUEST	4
-#define DOT11_RMREQ_MODE_REPORT		8
-#define DOT11_RMREQ_MODE_DURMAND	0x10	
-
-
-#define DOT11_RMREP_MODE_LATE		1
-#define DOT11_RMREP_MODE_INCAPABLE	2
-#define DOT11_RMREP_MODE_REFUSED	4
-
-BWL_PRE_PACKED_STRUCT struct dot11_rmreq_bcn {
-	uint8 id;
-	uint8 len;
-	uint8 token;
-	uint8 mode;
-	uint8 type;
-	uint8 reg;
-	uint8 channel;
-	uint16 interval;
-	uint16 duration;
-	uint8 bcn_mode;
-	struct ether_addr	bssid;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rmreq_bcn dot11_rmreq_bcn_t;
-#define DOT11_RMREQ_BCN_LEN	18
-
-BWL_PRE_PACKED_STRUCT struct dot11_rmrep_bcn {
-	uint8 reg;
-	uint8 channel;
-	uint32 starttime[2];
-	uint16 duration;
-	uint8 frame_info;
-	uint8 rcpi;
-	uint8 rsni;
-	struct ether_addr	bssid;
-	uint8 antenna_id;
-	uint32 parent_tsf;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rmrep_bcn dot11_rmrep_bcn_t;
-#define DOT11_RMREP_BCN_LEN	26
-
-
-#define DOT11_RMREQ_BCN_PASSIVE	0
-#define DOT11_RMREQ_BCN_ACTIVE	1
-#define DOT11_RMREQ_BCN_TABLE	2
-
-
-#define DOT11_RMREQ_BCN_SSID_ID	0
-#define DOT11_RMREQ_BCN_REPINFO_ID	1
-#define DOT11_RMREQ_BCN_REPDET_ID	2
-#define DOT11_RMREQ_BCN_REQUEST_ID	10
-#define DOT11_RMREQ_BCN_APCHREP_ID	51
-
-
-#define DOT11_RMREQ_BCN_REPDET_FIXED	0	
-#define DOT11_RMREQ_BCN_REPDET_REQUEST	1	
-#define DOT11_RMREQ_BCN_REPDET_ALL	2	
-
-
-#define DOT11_RMREP_BCN_FRM_BODY	1
-
-
-BWL_PRE_PACKED_STRUCT struct dot11_rmrep_nbr {
-	struct ether_addr	bssid;
-	uint32	bssid_info;
-	uint8 reg;
-	uint8 channel;
-	uint8 phytype;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rmrep_nbr dot11_rmrep_nbr_t;
-#define DOT11_RMREP_NBR_LEN	13
-
-
 #define DOT11_BSSTYPE_INFRASTRUCTURE		0	
 #define DOT11_BSSTYPE_INDEPENDENT		1	
 #define DOT11_BSSTYPE_ANY			2	
@@ -1254,32 +1101,8 @@ typedef struct dot11_rmrep_nbr dot11_rmrep_nbr_t;
 #define DOT11_SCANTYPE_PASSIVE			1	
 
 
-BWL_PRE_PACKED_STRUCT struct dot11_lmreq {
-	uint8 category;				
-	uint8 action;				
-	uint8 token;				
-	uint8 txpwr;				
-	uint8 maxtxpwr;				
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_lmreq dot11_lmreq_t;
-#define DOT11_LMREQ_LEN	5
-
-BWL_PRE_PACKED_STRUCT struct dot11_lmrep {
-	uint8 category;				
-	uint8 action;				
-	uint8 token;				
-	dot11_tpc_rep_t tpc;			
-	uint8 rxant;				
-	uint8 txant;				
-	uint8 rcpi;				
-	uint8 rsni;				
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_lmrep dot11_lmrep_t;
-#define DOT11_LMREP_LEN	11
-
-
 #define PREN_PREAMBLE		24	
-#define PREN_MM_EXT		12	
+#define PREN_MM_EXT		8	
 #define PREN_PREAMBLE_EXT	4	
 
 
@@ -1381,7 +1204,6 @@ typedef	struct brcm_ie brcm_ie_t;
 #define	BRF1_AMSDU		0x1	
 #define BRF1_WMEPS		0x4	
 #define BRF1_PSOFIX		0x8	
-#define BRF1_SOFTAP             0x40    
 
 #ifdef WLAFTERBURNER
 #define AB_WDS_TIMEOUT_MAX	15	
@@ -1390,20 +1212,6 @@ typedef	struct brcm_ie brcm_ie_t;
 
 #define AB_GUARDCOUNT	10		
 
-
-BWL_PRE_PACKED_STRUCT struct vndr_ie {
-	uchar id;
-	uchar len;
-	uchar oui [3];
-	uchar data [1]; 	
-} BWL_POST_PACKED_STRUCT;
-typedef struct vndr_ie vndr_ie_t;
-
-#define VNDR_IE_HDR_LEN		2	
-#define VNDR_IE_MIN_LEN		3	
-#define VNDR_IE_MAX_LEN		256	
-
-
 #define MCSSET_LEN	16	
 #define MAX_MCS_NUM	(128)	
 
@@ -1567,31 +1375,32 @@ typedef struct dot11_obss_ie dot11_obss_ie_t;
 #define DOT11_OBSS_SCAN_IE_LEN	sizeof(obss_params_t)	
 
 
-#define WPA_OUI			"\x00\x50\xF2"	
-#define WPA_OUI_LEN		3		
-#define WPA_OUI_TYPE		1
-#define WPA_VERSION		1		
-#define WPA2_OUI		"\x00\x0F\xAC"	
-#define WPA2_OUI_LEN		3		
-#define WPA2_VERSION		1		
-#define WPA2_VERSION_LEN	2		
+BWL_PRE_PACKED_STRUCT struct vndr_ie {
+	uchar id;
+	uchar len;
+	uchar oui [3];
+	uchar data [1]; 	
+} BWL_POST_PACKED_STRUCT;
+typedef struct vndr_ie vndr_ie_t;
 
+#define VNDR_IE_HDR_LEN		2	
+#define VNDR_IE_MIN_LEN		3	
+#define VNDR_IE_MAX_LEN		256	
 
-#define WPS_OUI			"\x00\x50\xF2"	
-#define WPS_OUI_LEN		3		
-#define WPS_OUI_TYPE		4
 
+#define WPA_VERSION		1	
+#define WPA_OUI			"\x00\x50\xF2"	
+
+#define WPA2_VERSION		1	
+#define WPA2_VERSION_LEN	2	
+#define WPA2_OUI		"\x00\x0F\xAC"	
 
-#define WFA_OUI			"\x50\x6F\x9A"	
-#define WFA_OUI_LEN		3		
-#define WFA_OUI_TYPE_P2P	9
+#define WPA_OUI_LEN	3	
 
 
 #define RSN_AKM_NONE		0	
 #define RSN_AKM_UNSPECIFIED	1	
 #define RSN_AKM_PSK		2	
-#define RSN_AKM_FBT_1X		3	
-#define RSN_AKM_FBT_PSK		4	
 
 
 #define DOT11_MAX_DEFAULT_KEYS	4	
@@ -1615,42 +1424,8 @@ typedef struct dot11_obss_ie dot11_obss_ie_t;
 #define AES_KEY_SIZE		16	
 #define AES_MIC_SIZE		8	
 
-
-
-
-
-BWL_PRE_PACKED_STRUCT struct dot11_mdid_ie {
-	uint8 id;
-	uint8 len;
-	uint16 mdid;		
-	uint8 cap;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_mdid_ie dot11_mdid_ie_t;
-
-#define FBT_MDID_CAP_OVERDS	0x01	
-#define FBT_MDID_CAP_RRP	0x02	
-
-
-BWL_PRE_PACKED_STRUCT struct dot11_ft_ie {
-	uint8 id;
-	uint8 len;
-	uint16 mic_control;		
-	uint8 mic[16];
-	uint8 anonce[32];
-	uint8 snonce[32];
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_ft_ie dot11_ft_ie_t;
-
-
-BWL_PRE_PACKED_STRUCT struct dot11_gtk_ie {
-	uint8 id;
-	uint8 len;
-	uint16 key_info;
-	uint8 key_len;
-	uint8 rsc[8];
-	uint8 data[1];
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_gtk_ie dot11_gtk_ie_t;
+#define SMS4_KEY_LEN		16
+#define SMS4_WPI_CBC_MAC_LEN	16
 
 
 #include <packed_section_end.h>
diff --git a/drivers/net/wireless/bcm43291/src/include/proto/bcmevent.h b/drivers/net/wireless/bcm43291/src/include/proto/bcmevent.h
index 0e81833..c6fb54e 100644
--- a/drivers/net/wireless/bcm43291/src/include/proto/bcmevent.h
+++ b/drivers/net/wireless/bcm43291/src/include/proto/bcmevent.h
@@ -21,9 +21,10 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
+ *
  * Dependencies: proto/bcmeth.h
  *
- * $Id: bcmevent.h,v 9.34.4.1.20.12.2.18.2.3 2010/05/04 22:34:09 Exp $
+ * $Id: bcmevent.h,v 9.34.4.1.20.16.64.1 2010/11/08 21:57:03 Exp $
  *
  */
 
@@ -40,31 +41,13 @@
 
 #include <packed_section_start.h>
 
-#define BCM_EVENT_MSG_VERSION		2	
+#define BCM_EVENT_MSG_VERSION		1	
 #define BCM_MSG_IFNAME_MAX		16	
 
 
 #define WLC_EVENT_MSG_LINK		0x01	
 #define WLC_EVENT_MSG_FLUSHTXQ		0x02	
 #define WLC_EVENT_MSG_GROUP		0x04	
-#define WLC_EVENT_MSG_UNKBSS		0x08	
-#define WLC_EVENT_MSG_UNKIF		0x10	
-
-
-
-
-typedef BWL_PRE_PACKED_STRUCT struct
-{
-	uint16	version;
-	uint16	flags;			
-	uint32	event_type;		
-	uint32	status;			
-	uint32	reason;			
-	uint32	auth_type;		
-	uint32	datalen;		
-	struct ether_addr	addr;	
-	char	ifname[BCM_MSG_IFNAME_MAX]; 
-} BWL_POST_PACKED_STRUCT wl_event_msg_v1_t;
 
 
 typedef BWL_PRE_PACKED_STRUCT struct
@@ -78,8 +61,6 @@ typedef BWL_PRE_PACKED_STRUCT struct
 	uint32	datalen;		
 	struct ether_addr	addr;	
 	char	ifname[BCM_MSG_IFNAME_MAX]; 
-	uint8	ifidx;			
-	uint8	bsscfgidx;		
 } BWL_POST_PACKED_STRUCT wl_event_msg_t;
 
 
@@ -145,23 +126,15 @@ typedef BWL_PRE_PACKED_STRUCT struct bcm_event {
 #define WLC_E_MULTICAST_DECODE_ERROR 51 
 #define WLC_E_TRACE		52
 #define WLC_E_IF		54	
-#ifdef WLP2P
-#define WLC_E_P2P_DISC_LISTEN_COMPLETE 	55	
-#endif
 #define WLC_E_RSSI		56	
 #define WLC_E_PFN_SCAN_COMPLETE	57	
-#define WLC_E_ACTION_FRAME      59 	
-#define WLC_E_ACTION_FRAME_COMPLETE 60	
+#define WLC_E_ACTION_FRAME      58      
+#define WLC_E_ACTION_FRAME_COMPLETE 59  
+
 #define WLC_E_ESCAN_RESULT 69 
-#define WLC_E_ACTION_FRAME_OFF_CHAN_COMPLETE 	70	
-#ifdef WLP2P
-#define WLC_E_P2P_PROBREQ_MSG	72	
-#endif
-#define WLC_E_FIFO_CREDIT_MAP	74 	
-#define WLC_E_ACTION_FRAME_RX	75	
-#define WLC_E_WAKE_EVENT	76	
-#define WLC_E_OVERLAY_REQ	77	
-#define WLC_E_LAST		78	
+#define WLC_E_WAKE_EVENT	70	
+#define WLC_E_RELOAD        71  
+#define WLC_E_LAST			72	
 	
 
 
@@ -182,7 +155,6 @@ typedef BWL_PRE_PACKED_STRUCT struct bcm_event {
 #define WLC_E_STATUS_NOCHANS		13	
 #define WLC_E_STATUS_CCXFASTRM		14	
 #define WLC_E_STATUS_CS_ABORT		15	
-#define WLC_E_STATUS_ERROR		16	
 
 
 #define WLC_E_REASON_INITIAL_ASSOC	0	
@@ -190,10 +162,6 @@ typedef BWL_PRE_PACKED_STRUCT struct bcm_event {
 #define WLC_E_REASON_DEAUTH		2	
 #define WLC_E_REASON_DISASSOC		3	
 #define WLC_E_REASON_BCNS_LOST		4	
-#define WLC_E_REASON_MINTXRATE		9	
-#define WLC_E_REASON_TXFAIL		10	
-
-
 #define WLC_E_REASON_FAST_ROAM_FAILED	5	
 #define WLC_E_REASON_DIRECTED_ROAM	6	
 #define WLC_E_REASON_TSPEC_REJECTED	7	
@@ -235,41 +203,10 @@ typedef BWL_PRE_PACKED_STRUCT struct bcm_event {
 #define WLC_E_SUP_WPA_PSK_TMO       15  
 
 
-
-typedef BWL_PRE_PACKED_STRUCT struct wl_event_rx_frame_data {
-	uint16	version;
-	uint16	channel;	
-	int32	rssi;
-	uint32	mactime;
-	uint32	rate;
-} BWL_POST_PACKED_STRUCT wl_event_rx_frame_data_t;
-
-#define BCM_RX_FRAME_DATA_VERSION 1
-
-
-typedef struct wl_event_data_if {
-	uint8 ifidx;		
-	uint8 opcode;		
-	uint8 reserved;
-	uint8 bssidx;		
-	uint8 role;		
-} wl_event_data_if_t;
-
-
 #define WLC_E_IF_ADD		1	
 #define WLC_E_IF_DEL		2	
-#define WLC_E_IF_CHANGE		3	
-
-
-#define WLC_E_IF_ROLE_STA		0	
-#define WLC_E_IF_ROLE_AP		1	
-#define WLC_E_IF_ROLE_WDS		2	
-#define WLC_E_IF_ROLE_P2P_GO		3	
-#define WLC_E_IF_ROLE_P2P_CLIENT	4	
-
 
-#define WLC_E_OVL_DOWNLOAD	0	
-#define WLC_E_OVL_UPDATE_IND	1	
+#define WLC_E_RELOAD_STATUS1		1  
 
 
 #include <packed_section_end.h>
diff --git a/drivers/net/wireless/bcm43291/src/include/proto/eapol.h b/drivers/net/wireless/bcm43291/src/include/proto/eapol.h
index b45a439..95e76ff 100644
--- a/drivers/net/wireless/bcm43291/src/include/proto/eapol.h
+++ b/drivers/net/wireless/bcm43291/src/include/proto/eapol.h
@@ -7,7 +7,7 @@
  *
  * Copyright (C) 2002 Broadcom Corporation
  *
- * $Id: eapol.h,v 9.18.260.1.2.1.6.6.22.1.20.2 2010/11/02 01:58:46 Exp $
+ * $Id: eapol.h,v 9.18.260.1.2.1.6.6 2009/04/08 05:00:08 Exp $
  */
 
 #ifndef _eapol_h_
@@ -20,16 +20,16 @@
 /* This marks the start of a packed structure section. */
 #include <packed_section_start.h>
 
-#include <bcmcrypto/aeskeywrap.h>
+#define AKW_BLOCK_LEN	8	/* The only def we need here */
 
 /* EAPOL for 802.3/Ethernet */
-typedef BWL_PRE_PACKED_STRUCT struct {
+typedef struct {
 	struct ether_header eth;	/* 802.3/Ethernet header */
 	unsigned char version;		/* EAPOL protocol version */
 	unsigned char type;		/* EAPOL type */
 	unsigned short length;		/* Length of body */
 	unsigned char body[1];		/* Body (optional) */
-} BWL_POST_PACKED_STRUCT eapol_header_t;
+} eapol_header_t;
 
 #define EAPOL_HEADER_LEN 18
 
@@ -107,7 +107,6 @@ typedef BWL_PRE_PACKED_STRUCT struct {
 /* WPA/802.11i/WPA2 KEY KEY_INFO bits */
 #define WPA_KEY_DESC_V1		0x01
 #define WPA_KEY_DESC_V2		0x02
-#define WPA_KEY_DESC_V3		0x03
 #define WPA_KEY_PAIRWISE	0x08
 #define WPA_KEY_INSTALL		0x40
 #define WPA_KEY_ACK		0x80
diff --git a/drivers/net/wireless/bcm43291/src/include/proto/ethernet.h b/drivers/net/wireless/bcm43291/src/include/proto/ethernet.h
index 8cfadfe..9ad2ea0 100644
--- a/drivers/net/wireless/bcm43291/src/include/proto/ethernet.h
+++ b/drivers/net/wireless/bcm43291/src/include/proto/ethernet.h
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: ethernet.h,v 9.45.56.1.58.5.16.1 2010/11/09 01:24:38 Exp $
+ * $Id: ethernet.h,v 9.45.56.5 2010/02/22 22:04:36 Exp $
  */
 
 
@@ -67,7 +67,10 @@
 #define ETHER_TYPE_8021Q	0x8100		
 #define	ETHER_TYPE_BRCM		0x886c		
 #define	ETHER_TYPE_802_1X	0x888e		
+#define ETHER_TYPE_WAI		0x88b4		
+#ifdef BCMWPA2
 #define	ETHER_TYPE_802_1X_PREAUTH 0x88c7	
+#endif
 
 
 #define	ETHER_BRCM_SUBTYPE_LEN	4	
diff --git a/drivers/net/wireless/bcm43291/src/include/sbchipc.h b/drivers/net/wireless/bcm43291/src/include/sbchipc.h
index 1c7cf44..8c8be26 100644
--- a/drivers/net/wireless/bcm43291/src/include/sbchipc.h
+++ b/drivers/net/wireless/bcm43291/src/include/sbchipc.h
@@ -5,7 +5,7 @@
  * jtag, 0/1/2 uarts, clock frequency control, a watchdog interrupt timer,
  * gpio interface, extbus, and support for serial and parallel flashes.
  *
- * $Id: sbchipc.h,v 13.103.2.5.4.5.2.8.34.1 2009/09/01 11:27:52 Exp $
+ * $Id: sbchipc.h,v 13.103.2.5.4.5.2.9 2009/07/03 14:23:21 Exp $
  *
  * Copyright (C) 1999-2010, Broadcom Corporation
  * 
diff --git a/drivers/net/wireless/bcm43291/src/include/sbhnddma.h b/drivers/net/wireless/bcm43291/src/include/sbhnddma.h
index 1dd49d6..7681395 100644
--- a/drivers/net/wireless/bcm43291/src/include/sbhnddma.h
+++ b/drivers/net/wireless/bcm43291/src/include/sbhnddma.h
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: sbhnddma.h,v 13.11.250.5.118.2 2010/04/07 20:54:46 Exp $
+ * $Id: sbhnddma.h,v 13.11.250.5.16.1 2009/07/21 14:04:51 Exp $
  */
 
 
@@ -216,7 +216,7 @@ typedef volatile struct {
 #define	D64_XS0_XS_STOPPED	0x30000000	
 #define	D64_XS0_XS_SUSP		0x40000000	
 
-#define	D64_XS1_AD_MASK		0x00001fff	
+#define	D64_XS1_AD_MASK		0x0001ffff	
 #define	D64_XS1_XE_MASK		0xf0000000     	
 #define	D64_XS1_XE_SHIFT		28
 #define	D64_XS1_XE_NOERR	0x00000000	
diff --git a/drivers/net/wireless/bcm43291/src/include/sbpcmcia.h b/drivers/net/wireless/bcm43291/src/include/sbpcmcia.h
index f17d80d..d6d8033 100644
--- a/drivers/net/wireless/bcm43291/src/include/sbpcmcia.h
+++ b/drivers/net/wireless/bcm43291/src/include/sbpcmcia.h
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: sbpcmcia.h,v 13.31.4.1.2.3.8.6.10.1 2009/06/22 05:17:37 Exp $
+ * $Id: sbpcmcia.h,v 13.31.4.1.2.3.8.7 2009/06/22 05:14:24 Exp $
  */
 
 
diff --git a/drivers/net/wireless/bcm43291/src/include/sdio.h b/drivers/net/wireless/bcm43291/src/include/sdio.h
index 2eeba7c..280cb84 100644
--- a/drivers/net/wireless/bcm43291/src/include/sdio.h
+++ b/drivers/net/wireless/bcm43291/src/include/sdio.h
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: sdio.h,v 13.24.4.1.4.1.118.1 2009/08/12 01:08:11 Exp $
+ * $Id: sdio.h,v 13.24.4.1.4.1.16.1 2009/08/12 01:08:02 Exp $
  */
 
 #ifndef	_SDIO_H
diff --git a/drivers/net/wireless/bcm43291/src/include/sdioh.h b/drivers/net/wireless/bcm43291/src/include/sdioh.h
index a3dcfa1..8123452 100644
--- a/drivers/net/wireless/bcm43291/src/include/sdioh.h
+++ b/drivers/net/wireless/bcm43291/src/include/sdioh.h
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: sdioh.h,v 13.13.18.1.16.1.72.1 2009/12/08 22:37:07 Exp $
+ * $Id: sdioh.h,v 13.13.18.1.16.3 2009/12/08 22:34:21 Exp $
  */
 
 #ifndef	_SDIOH_H
diff --git a/drivers/net/wireless/bcm43291/src/include/sdiovar.h b/drivers/net/wireless/bcm43291/src/include/sdiovar.h
index ff72d45..0179d4c 100644
--- a/drivers/net/wireless/bcm43291/src/include/sdiovar.h
+++ b/drivers/net/wireless/bcm43291/src/include/sdiovar.h
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: sdiovar.h,v 13.5.14.2.16.1.58.1 2009/12/08 22:37:07 Exp $
+ * $Id: sdiovar.h,v 13.5.14.2.16.2 2009/12/08 22:34:21 Exp $
  */
 
 #ifndef _sdiovar_h_
diff --git a/drivers/net/wireless/bcm43291/src/include/siutils.h b/drivers/net/wireless/bcm43291/src/include/siutils.h
index 6aea36c..cb9f140 100644
--- a/drivers/net/wireless/bcm43291/src/include/siutils.h
+++ b/drivers/net/wireless/bcm43291/src/include/siutils.h
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: siutils.h,v 13.197.4.2.4.3.8.7.20.5.2.1 2010/06/23 17:02:05 Exp $
+ * $Id: siutils.h,v 13.197.4.2.4.3.8.16 2010/06/23 21:36:05 Exp $
  */
 
 
@@ -225,7 +225,6 @@ extern void si_pci_up(si_t *sih);
 extern void si_pcie_war_ovr_disable(si_t *sih);
 extern void si_pcie_extendL1timer(si_t *sih, bool extend);
 extern int si_pci_fixcfg(si_t *sih);
-void si_pmu_res_4319_swctrl_war(si_t *sih, osl_t *osh, bool enable);
 
 
 
diff --git a/drivers/net/wireless/bcm43291/src/include/trxhdr.h b/drivers/net/wireless/bcm43291/src/include/trxhdr.h
index 01345fb..8f5eed9 100644
--- a/drivers/net/wireless/bcm43291/src/include/trxhdr.h
+++ b/drivers/net/wireless/bcm43291/src/include/trxhdr.h
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: trxhdr.h,v 13.11.310.1.104.1.2.1 2010/09/01 07:50:53 Exp $
+ * $Id: trxhdr.h,v 13.11.310.1 2008/08/17 12:58:58 Exp $
  */
 
 #include <typedefs.h>
@@ -31,12 +31,8 @@
 #define TRX_MAX_LEN	0x3A0000	/* Max length */
 #define TRX_NO_HEADER	1		/* Do not write TRX header */
 #define TRX_GZ_FILES	0x2     /* Contains up to TRX_MAX_OFFSET individual gzip files */
-#define TRX_OVERLAYS	0x4     /* Contains an overlay header after the trx header */
-#define TRX_EMBED_UCODE	0x8	/* Trx contains embedded ucode image */
-#define TRX_ROMSIM_IMAGE	0x10	/* Trx contains ROM simulation image */
-#define TRX_UNCOMP_IMAGE	0x20	/* Trx contains uncompressed rtecdc.bin image */
 #define TRX_MAX_OFFSET	3		/* Max number of individual files */
-
+#define TRX_UNCOMP_IMAGE	0x20	/* Trx contains uncompressed rtecdc.bin image */
 
 struct trx_header {
 	uint32 magic;		/* "HDR0" */
diff --git a/drivers/net/wireless/bcm43291/src/include/wlioctl.h b/drivers/net/wireless/bcm43291/src/include/wlioctl.h
index aabd05a..cdabed0 100644
--- a/drivers/net/wireless/bcm43291/src/include/wlioctl.h
+++ b/drivers/net/wireless/bcm43291/src/include/wlioctl.h
@@ -24,7 +24,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: wlioctl.h,v 1.601.4.15.2.14.2.29.2.36.2.16 2010/11/09 01:34:59 Exp $
+ * $Id: wlioctl.h,v 1.601.4.15.2.14.2.62.4.2 2011/01/19 01:20:44 Exp $
  */
 
 
@@ -38,17 +38,9 @@
 #include <proto/802.11.h>
 #include <bcmwifi.h>
 
-#ifdef __NetBSD__
 
-#define SIOCDEVPRIVATE	_IOWR('i', 139, struct ifreq)
-#endif
 
-#ifdef EFI
-#define BCMWL_IOCTL_GUID \
-	{0xB4910A35, 0x88C5, 0x4328, 0x90, 0x08, 0x9F, 0xB2, 0x00, 0x00, 0x0, 0x0}
-#endif 
-
-#define ACTION_FRAME_SIZE 1800
+#define ACTION_FRAME_SIZE 1040
 
 typedef struct wl_action_frame {
 	struct ether_addr 	da;
@@ -59,15 +51,6 @@ typedef struct wl_action_frame {
 
 #define WL_WIFI_ACTION_FRAME_SIZE sizeof(struct wl_action_frame)
 
-typedef struct wl_af_params {
-	uint32 			channel;
-	int32 			dwell_time;
-	struct ether_addr 	BSSID;
-	wl_action_frame_t	action_frame;
-} wl_af_params_t;
-
-#define WL_WIFI_AF_PARAMS_SIZE sizeof(struct wl_af_params)
-
 
 #define BWL_DEFAULT_PACKING
 #include <packed_section_start.h>
@@ -88,43 +71,11 @@ typedef struct ssid_info
 	uint8		ssid[32];		
 } ssid_info_t;
 
-#define DL_MAX_CHUNK_LEN 1456
-
-#define DLOAD_HANDLER_VER			1	
-#define DLOAD_FLAG_VER_MASK		0xf000	
-#define DLOAD_FLAG_VER_SHIFT	12	
-
-#define DL_CRC_NOT_INUSE 			0x0001
-
-
-enum {
-	DL_TYPE_UCODE = 1
-};
-
-
-enum {
-	UCODE_FW,
-	INIT_VALS,
-	BS_INIT_VALS
-};
-
-struct wl_dload_data {
-	uint16 flag;
-	uint16 dload_type;
-	uint32 len;
-	uint32 crc;
-	uint8  data[1];
-};
-typedef struct wl_dload_data wl_dload_data_t;
-
-struct wl_ucode_info {
-	uint32 ucode_type;
-	uint32 num_chunks;
-	uint32 chunk_len;
-	uint32 chunk_num;
-	uint8  data_chunk[1];
-};
-typedef struct wl_ucode_info wl_ucode_info_t;
+typedef struct cnt_rx
+{
+	uint32 cnt_rxundec;
+	uint32 cnt_rxframe;
+} cnt_rx_t;
 
 
 
@@ -134,32 +85,6 @@ typedef struct wl_ucode_info wl_ucode_info_t;
 #define RWL_WIFI_SERVER_CHANNEL_OFFSET	51
 
 
-#if !defined(ESTA_POSTMOGRIFY_REMOVAL)
-
-
-#define	LEGACY_WL_BSS_INFO_VERSION	107	
-
-typedef struct wl_bss_info_107 {
-	uint32		version;		
-	uint32		length;			
-	struct ether_addr BSSID;
-	uint16		beacon_period;		
-	uint16		capability;		
-	uint8		SSID_len;
-	uint8		SSID[32];
-	struct {
-		uint	count;			
-		uint8	rates[16];		
-	} rateset;				
-	uint8		channel;		
-	uint16		atim_window;		
-	uint8		dtim_period;		
-	int16		RSSI;			
-	int8		phy_noise;		
-	uint32		ie_length;		
-	
-} wl_bss_info_107_t;
-#endif 
 
 
 
@@ -203,40 +128,6 @@ typedef struct wlc_ssid {
 	uchar		SSID[32];
 } wlc_ssid_t;
 
-#if !defined(ESTA_POSTMOGRIFY_REMOVAL)
-typedef struct chan_scandata {
-	uint8		txpower;
-	uint8		pad;
-	chanspec_t	channel;	
-	uint32		channel_mintime;
-	uint32		channel_maxtime;
-} chan_scandata_t;
-
-typedef enum wl_scan_type {
-	EXTDSCAN_FOREGROUND_SCAN,
-	EXTDSCAN_BACKGROUND_SCAN,
-	EXTDSCAN_FORCEDBACKGROUND_SCAN
-} wl_scan_type_t;
-
-#define WLC_EXTDSCAN_MAX_SSID		5
-
-#define WL_BSS_FLAGS_FROM_BEACON	0x01	
-#define WL_BSS_FLAGS_RSSI_ONCHANNEL     0x04 
-
-typedef struct wl_extdscan_params {
-	int8 		nprobes;		
-	int8    	split_scan;		
-	int8		band;			
-	int8		pad;
-	wlc_ssid_t 	ssid[WLC_EXTDSCAN_MAX_SSID]; 
-	uint32		tx_rate;		
-	wl_scan_type_t	scan_type;		
-	int32 		channel_num;
-	chan_scandata_t channel_list[1];	
-} wl_extdscan_params_t;
-
-#define WL_EXTDSCAN_PARAMS_FIXED_SIZE 	(sizeof(wl_extdscan_params_t) - sizeof(chan_scandata_t))
-#endif 
 
 #define WL_BSSTYPE_INFRA 1
 #define WL_BSSTYPE_INDEP 0
@@ -244,14 +135,13 @@ typedef struct wl_extdscan_params {
 
 
 #define WL_SCANFLAGS_PASSIVE	0x01	
-#define WL_SCANFLAGS_RESERVED	0x02	
 #define WL_SCANFLAGS_PROHIBITED	0x04	
 
 typedef struct wl_scan_params {
 	wlc_ssid_t ssid;		
 	struct ether_addr bssid;	
 	int8 bss_type;			
-	uint8 scan_type;		
+	int8 scan_type;		
 	int32 nprobes;			
 	int32 active_time;		
 	int32 passive_time;		
@@ -291,8 +181,7 @@ typedef struct wl_scan_results {
 	wl_bss_info_t bss_info[1];
 } wl_scan_results_t;
 
-
-#define WL_SCAN_RESULTS_FIXED_SIZE (sizeof(wl_scan_results_t) - sizeof(wl_bss_info_t))
+#define WL_SCAN_RESULTS_FIXED_SIZE 12
 
 
 #define WL_SCAN_RESULTS_SUCCESS	0
@@ -347,201 +236,34 @@ typedef struct wl_uint32_list {
 } wl_uint32_list_t;
 
 
-typedef struct wl_chanspec_list {
-	uint32 num;		
-	chanspec_t chanspec[1];	
-} wl_chanspec_list_t;
-
 typedef struct wl_assoc_params {
 	struct ether_addr bssid;	
 	uint16 bssid_cnt;		
-#ifdef BCMDRIVER
-	wl_chanspec_list_t chanspec_list; 
-#else
-	uint32 chanspec_num;		
+	int32 chanspec_num;		
 	chanspec_t chanspec_list[1];	
-#endif
 } wl_assoc_params_t;
-#ifdef BCMDRIVER
-#define WL_ASSOC_PARAMS_FIXED_SIZE 	OFFSETOF(wl_assoc_params_t, chanspec_list.chanspec)
-#else
-#define WL_ASSOC_PARAMS_FIXED_SIZE 	OFFSETOF(wl_assoc_params_t, chanspec_list)
-#endif
+#define WL_ASSOC_PARAMS_FIXED_SIZE 	(sizeof(wl_assoc_params_t) - sizeof(chanspec_t))
 
 
 typedef wl_assoc_params_t wl_reassoc_params_t;
 #define WL_REASSOC_PARAMS_FIXED_SIZE	WL_ASSOC_PARAMS_FIXED_SIZE
 
 
-typedef wl_assoc_params_t wl_join_assoc_params_t;
-#define WL_JOIN_ASSOC_PARAMS_FIXED_SIZE	WL_ASSOC_PARAMS_FIXED_SIZE
-
-
 typedef struct wl_join_params {
 	wlc_ssid_t ssid;
 	wl_assoc_params_t params;	
 } wl_join_params_t;
-#define WL_JOIN_PARAMS_FIXED_SIZE 	(OFFSETOF(wl_join_params_t, params) + \
-					 WL_ASSOC_PARAMS_FIXED_SIZE)
+#define WL_JOIN_PARAMS_FIXED_SIZE 	(sizeof(wl_join_params_t) - sizeof(chanspec_t))
 
-
-typedef struct wl_join_scan_params {
-	uint8 scan_type;		
-	int32 nprobes;			
-	int32 active_time;		
-	int32 passive_time;		
-	int32 home_time;		
-} wl_join_scan_params_t;
-
-
-typedef struct wl_extjoin_params {
-	wlc_ssid_t ssid;		
-	wl_join_scan_params_t scan;
-	wl_join_assoc_params_t assoc;	
-} wl_extjoin_params_t;
-#define WL_EXTJOIN_PARAMS_FIXED_SIZE 	(OFFSETOF(wl_extjoin_params_t, assoc) + \
-					 WL_JOIN_ASSOC_PARAMS_FIXED_SIZE)
 #define WLC_CNTRY_BUF_SZ	4	
 
-#if !defined(ESTA_POSTMOGRIFY_REMOVAL)
-
-#define NRATE_MCS_INUSE	0x00000080	
-#define NRATE_RATE_MASK 0x0000007f	
-#define NRATE_STF_MASK	0x0000ff00	
-#define NRATE_STF_SHIFT	8		
-#define NRATE_OVERRIDE	0x80000000	
-#define NRATE_SGI_MASK  0x00800000      
-#define NRATE_SGI_SHIFT 23              
-
-#define NRATE_STF_SISO	0		
-#define NRATE_STF_CDD	1		
-#define NRATE_STF_STBC	2		
-#define NRATE_STF_SDM	3		
-
-#define ANTENNA_NUM_1	1		
-#define ANTENNA_NUM_2	2
-#define ANTENNA_NUM_3	3
-#define ANTENNA_NUM_4	4
-
-#define ANT_SELCFG_AUTO		0x80	
-#define ANT_SELCFG_MASK		0x33	
-#define ANT_SELCFG_MAX		4	
-#define ANT_SELCFG_TX_UNICAST	0	
-#define ANT_SELCFG_RX_UNICAST	1	
-#define ANT_SELCFG_TX_DEF	2	
-#define ANT_SELCFG_RX_DEF	3	
-
-typedef struct {
-	uint8 ant_config[ANT_SELCFG_MAX];	
-	uint8 num_antcfg;	
-} wlc_antselcfg_t;
-
-#define HIGHEST_SINGLE_STREAM_MCS	7 
-
 typedef struct wl_country {
 	char country_abbrev[WLC_CNTRY_BUF_SZ];	
 	int32 rev;				
 	char ccode[WLC_CNTRY_BUF_SZ];		
 } wl_country_t;
 
-typedef struct wl_channels_in_country {
-	uint32 buflen;
-	uint32 band;
-	char country_abbrev[WLC_CNTRY_BUF_SZ];
-	uint32 count;
-	uint32 channel[1];
-} wl_channels_in_country_t;
-
-typedef struct wl_country_list {
-	uint32 buflen;
-	uint32 band_set;
-	uint32 band;
-	uint32 count;
-	char country_abbrev[1];
-} wl_country_list_t;
-
-#define WL_NUM_RPI_BINS		8
-#define WL_RM_TYPE_BASIC	1
-#define WL_RM_TYPE_CCA		2
-#define WL_RM_TYPE_RPI		3
-
-#define WL_RM_FLAG_PARALLEL	(1<<0)
-
-#define WL_RM_FLAG_LATE		(1<<1)
-#define WL_RM_FLAG_INCAPABLE	(1<<2)
-#define WL_RM_FLAG_REFUSED	(1<<3)
-
-typedef struct wl_rm_req_elt {
-	int8	type;
-	int8	flags;
-	chanspec_t	chanspec;
-	uint32	token;		
-	uint32	tsf_h;		
-	uint32	tsf_l;		
-	uint32	dur;		
-} wl_rm_req_elt_t;
-
-typedef struct wl_rm_req {
-	uint32	token;		
-	uint32	count;		
-	void	*cb;		
-	void	*cb_arg;	
-	wl_rm_req_elt_t	req[1];	
-} wl_rm_req_t;
-#define WL_RM_REQ_FIXED_LEN	OFFSETOF(wl_rm_req_t, req)
-
-typedef struct wl_rm_rep_elt {
-	int8	type;
-	int8	flags;
-	chanspec_t	chanspec;
-	uint32	token;		
-	uint32	tsf_h;		
-	uint32	tsf_l;		
-	uint32	dur;		
-	uint32	len;		
-	uint8	data[1];	
-} wl_rm_rep_elt_t;
-#define WL_RM_REP_ELT_FIXED_LEN	24	
-
-#define WL_RPI_REP_BIN_NUM 8
-typedef struct wl_rm_rpi_rep {
-	uint8	rpi[WL_RPI_REP_BIN_NUM];
-	int8	rpi_max[WL_RPI_REP_BIN_NUM];
-} wl_rm_rpi_rep_t;
-
-typedef struct wl_rm_rep {
-	uint32	token;		
-	uint32	len;		
-	wl_rm_rep_elt_t	rep[1];	
-} wl_rm_rep_t;
-#define WL_RM_REP_FIXED_LEN	8
-
-#if defined(BCMROMBUILD) || defined(BCMROMOFFLOAD)
-
-#define LEAP_USER_MAX		32
-#define LEAP_DOMAIN_MAX		32
-#define LEAP_PASSWORD_MAX	32
 
-typedef struct wl_leap_info {
-	wlc_ssid_t ssid;
-	uint8 user_len;
-	uchar user[LEAP_USER_MAX];
-	uint8 password_len;
-	uchar password[LEAP_PASSWORD_MAX];
-	uint8 domain_len;
-	uchar domain[LEAP_DOMAIN_MAX];
-} wl_leap_info_t;
-
-typedef struct wl_leap_list {
-	uint32 buflen;
-	uint32 version;
-	uint32 count;
-	wl_leap_info_t leap_info[1];
-} wl_leap_list_t;
-#endif	
-#endif 
-
-#if defined(BCMSUP_PSK) || defined(BCMDONGLEHOST)
 typedef enum sup_auth_status {
 	
 	WLC_SUP_DISCONNECTED = 0,
@@ -565,7 +287,6 @@ typedef enum sup_auth_status {
 	WLC_SUP_KEYXCHANGE_WAIT_G1,		
 	WLC_SUP_KEYXCHANGE_PREP_G2		
 } sup_auth_status_t;
-#endif 
 
 
 #define	CRYPTO_ALGO_OFF			0
@@ -576,6 +297,7 @@ typedef enum sup_auth_status {
 #define CRYPTO_ALGO_AES_OCB_MSDU	5
 #define CRYPTO_ALGO_AES_OCB_MPDU	6
 #define CRYPTO_ALGO_NALG		7
+#define CRYPTO_ALGO_SMS4		11
 
 #define WSEC_GEN_MIC_ERROR	0x0001
 #define WSEC_GEN_REPLAY		0x0002
@@ -626,6 +348,7 @@ typedef struct {
 #define AES_ENABLED		0x0004
 #define WSEC_SWFLAG		0x0008
 #define SES_OW_ENABLED		0x0040	
+#define SMS4_ENABLED		0x0100
 
 
 #define WPA_AUTH_DISABLED	0x0000	
@@ -637,6 +360,7 @@ typedef struct {
 #define WPA2_AUTH_PSK		0x0080	
 #define BRCM_AUTH_PSK           0x0100  
 #define BRCM_AUTH_DPT		0x0200	
+#define WPA_AUTH_WAPI		0x0400	
 
 #define WPA_AUTH_PFN_ANY	0xffffffff	
 
@@ -663,85 +387,6 @@ typedef struct _pmkid_cand_list {
 	pmkid_cand_t	pmkid_cand[1];
 } pmkid_cand_list_t;
 
-#if !defined(ESTA_POSTMOGRIFY_REMOVAL)
-typedef struct wl_led_info {
-	uint32		index;		
-	uint32		behavior;
-	uint8		activehi;
-} wl_led_info_t;
-
-typedef struct wl_assoc_info {
-	uint32		req_len;
-	uint32		resp_len;
-	uint32		flags;
-	struct dot11_assoc_req req;
-	struct ether_addr reassoc_bssid; 
-	struct dot11_assoc_resp resp;
-} wl_assoc_info_t;
-
-
-#define WLC_ASSOC_REQ_IS_REASSOC 0x01 
-
-
-typedef struct {
-	uint	byteoff;		
-	uint	nbytes;		
-	uint16 buf[1];
-} srom_rw_t;
-
-
-typedef struct {
-	uint32 source;		
-	uint32 byteoff;		
-	uint32 nbytes;		
-	
-} cis_rw_t;
-
-#define WLC_CIS_DEFAULT	0	
-#define WLC_CIS_SROM	1	
-#define WLC_CIS_OTP	2	
-
-
-typedef struct {
-	uint32	byteoff;	
-	uint32	val;		
-	uint32	size;		
-	uint	band;		
-} rw_reg_t;
-
-
-
-
-#define WL_ATTEN_APP_INPUT_PCL_OFF	0	
-#define WL_ATTEN_PCL_ON			1	
-
-#define WL_ATTEN_PCL_OFF		2	
-
-typedef struct {
-	uint16	auto_ctrl;	
-	uint16	bb;		
-	uint16	radio;		
-	uint16	txctl1;		
-} atten_t;
-
-
-struct wme_tx_params_s {
-	uint8  short_retry;
-	uint8  short_fallback;
-	uint8  long_retry;
-	uint8  long_fallback;
-	uint16 max_rate;  
-};
-typedef struct wme_tx_params_s wme_tx_params_t;
-#define WL_WME_TX_PARAMS_IO_BYTES (sizeof(wme_tx_params_t) * AC_COUNT)
-
-
-
-#define WL_PWRIDX_PCL_OFF	-2	
-#define WL_PWRIDX_PCL_ON	-1	
-#define WL_PWRIDX_LOWER_LIMIT	-2	
-#define WL_PWRIDX_UPPER_LIMIT	63	
-#endif 
 
 
 
@@ -751,56 +396,6 @@ typedef struct {
 } scb_val_t;
 
 
-typedef struct {
-	uint32 code;
-	scb_val_t ioctl_args;
-} authops_t;
-
-#if !defined(ESTA_POSTMOGRIFY_REMOVAL)
-#define BCM_MAC_STATUS_INDICATION	(0x40010200L)
-
-typedef struct {
-	uint16			ver;		
-	uint16			len;		
-	uint16			cap;		
-	uint32			flags;		
-	uint32			idle;		
-	struct ether_addr	ea;		
-	wl_rateset_t		rateset;	
-	uint32			in;		
-	uint32			listen_interval_inms; 
-	uint32			tx_pkts;	
-	uint32			tx_failures;	
-	uint32			rx_ucast_pkts;	
-	uint32			rx_mcast_pkts;	
-	uint32			tx_rate;	
-	uint32			rx_rate;	
-} sta_info_t;
-
-#define WL_OLD_STAINFO_SIZE	OFFSETOF(sta_info_t, tx_pkts)
-
-#define WL_STA_VER		2
-
-
-#define WL_STA_BRCM		0x1		
-#define WL_STA_WME		0x2		
-#define WL_STA_ABCAP		0x4
-#define WL_STA_AUTHE		0x8		
-#define WL_STA_ASSOC		0x10		
-#define WL_STA_AUTHO		0x20		
-#define WL_STA_WDS		0x40		
-#define WL_STA_WDS_LINKUP	0x80		
-#define WL_STA_PS		0x100		
-#define WL_STA_APSD_BE		0x200		
-#define WL_STA_APSD_BK		0x400		
-#define WL_STA_APSD_VI		0x800		
-#define WL_STA_APSD_VO		0x1000		
-#define WL_STA_N_CAP		0x2000		
-#define WL_STA_SCBSTATS		0x4000		
-
-#define WL_WDS_LINKUP		WL_STA_WDS_LINKUP	
-#endif 
-
 
 typedef struct channel_info {
 	int hw_channel;
@@ -823,117 +418,16 @@ typedef struct get_pktcnt {
 	uint rx_ocast_good_pkt; 
 } get_pktcnt_t;
 
-#define LQ_IDX_MIN              0
-#define LQ_IDX_MAX              1
-#define LQ_IDX_AVG              2
-#define LQ_IDX_SUM              2
-#define LQ_IDX_LAST             3
-#define LQ_STOP_MONITOR         0
-#define LQ_START_MONITOR        1
-
-
-typedef struct {
-	int rssi[LQ_IDX_LAST];  
-	int snr[LQ_IDX_LAST];   
-	int isvalid;            
-} wl_lq_t; 
-
-
-#define NANT	4
-typedef struct {
-	uint8 ant[NANT];  
-} wl_ah_t; 
-
-typedef enum wl_wakeup_reason_type {
-	LCD_ON = 1,
-	LCD_OFF,
-	DRC1_WAKE,
-	DRC2_WAKE,
-	REASON_LAST
-} wl_wr_type_t;
-
-typedef struct {
-
-	uint32	id;
-
-
-	uint8	reason;
-} wl_wr_t;
-
-#define WL_IOCTL_ACTION_GET				0x0
-#define WL_IOCTL_ACTION_SET				0x1
-#define WL_IOCTL_ACTION_OVL_IDX_MASK	0x1e
-#define WL_IOCTL_ACTION_OVL_RSV			0x20
-#define WL_IOCTL_ACTION_OVL				0x40
-#define WL_IOCTL_ACTION_MASK			0x7e
-#define WL_IOCTL_ACTION_OVL_SHIFT		1
-
 
 typedef struct wl_ioctl {
 	uint cmd;	
 	void *buf;	
 	uint len;	
-#ifdef DONGLEOVERLAYS
-	uint8 action;	
-#else
 	uint8 set;		
-#endif 
 	uint used;	
 	uint needed;	
 } wl_ioctl_t;
 
-typedef struct wl_ioctl_dload {
-	uint cmd;	
-	void *buf;	
-	uint len;	
-	uint8 set;		
-	uint used;	
-	uint needed;	
-} wl_ioctl_dload_t;
-
-#if !defined(ESTA_POSTMOGRIFY_REMOVAL)
-
-typedef struct wlc_rev_info {
-	uint		vendorid;	
-	uint		deviceid;	
-	uint		radiorev;	
-	uint		chiprev;	
-	uint		corerev;	
-	uint		boardid;	
-	uint		boardvendor;	
-	uint		boardrev;	
-	uint		driverrev;	
-	uint		ucoderev;	
-	uint		bus;		
-	uint		chipnum;	
-	uint		phytype;	
-	uint		phyrev;		
-	uint		anarev;		
-} wlc_rev_info_t;
-
-#define WL_REV_INFO_LEGACY_LENGTH	48
-
-#define WL_BRAND_MAX 10
-typedef struct wl_instance_info {
-	uint instance;
-	char brand[WL_BRAND_MAX];
-} wl_instance_info_t;
-
-
-typedef struct wl_txfifo_sz {
-	uint8	fifo;
-	uint8	size;
-} wl_txfifo_sz_t;
-
-
-
-#define WLC_IOV_NAME_LEN 30
-typedef struct wlc_iov_trx_s {
-	uint8 module;
-	uint8 type;
-	char name[WLC_IOV_NAME_LEN];
-} wlc_iov_trx_t;
-#endif 
 
 
 #define WLC_IOCTL_MAGIC		0x14e46c77
@@ -958,7 +452,7 @@ typedef struct wlc_iov_trx_s {
 #define WLC_SET_MSGLEVEL			8
 #define WLC_GET_PROMISC				9
 #define WLC_SET_PROMISC				10
-#define WLC_OVERLAY_IOCTL			11
+ 
 #define WLC_GET_RATE				12
  
 #define WLC_GET_INSTANCE			14
@@ -1256,68 +750,6 @@ typedef struct wlc_iov_trx_s {
 #define WLC_GET_NUM_BSS				306	
 #define WLC_LAST				307	
 
-#if !defined(ESTA_POSTMOGRIFY_REMOVAL)
-#ifndef EPICTRL_COOKIE
-#define EPICTRL_COOKIE		0xABADCEDE
-#endif
-
-
-#define CMN_IOCTL_OFF 0x180
-
-
-
-
-#define WL_OID_BASE		0xFFE41420
-
-
-#define OID_WL_GETINSTANCE	(WL_OID_BASE + WLC_GET_INSTANCE)
-#define OID_WL_GET_FORCELINK	(WL_OID_BASE + WLC_GET_FORCELINK)
-#define OID_WL_SET_FORCELINK	(WL_OID_BASE + WLC_SET_FORCELINK)
-#define	OID_WL_ENCRYPT_STRENGTH	(WL_OID_BASE + WLC_ENCRYPT_STRENGTH)
-#define OID_WL_DECRYPT_STATUS	(WL_OID_BASE + WLC_DECRYPT_STATUS)
-#define OID_LEGACY_LINK_BEHAVIOR (WL_OID_BASE + WLC_LEGACY_LINK_BEHAVIOR)
-#define OID_WL_NDCONFIG_ITEM (WL_OID_BASE + WLC_NDCONFIG_ITEM)
-
-
-#define OID_STA_CHANSPEC	(WL_OID_BASE + WLC_GET_CHANSPEC)
-#define OID_STA_NBANDS		(WL_OID_BASE + WLC_GET_NBANDS)
-#define OID_STA_GET_PHY		(WL_OID_BASE + WLC_GET_OID_PHY)
-#define OID_STA_SET_PHY		(WL_OID_BASE + WLC_SET_OID_PHY)
-#define OID_STA_ASSOC_TIME	(WL_OID_BASE + WLC_SET_ASSOC_TIME)
-#define OID_STA_DESIRED_SSID (WL_OID_BASE + WLC_GET_DESIRED_SSID)
-#define OID_STA_SET_PHY_STATE (WL_OID_BASE + WLC_SET_PHY_STATE)
-#define OID_STA_SCAN_PENDING	(WL_OID_BASE + WLC_GET_SCAN_PENDING)
-#define OID_STA_SCANREQ_PENDING (WL_OID_BASE + WLC_GET_SCANREQ_PENDING)
-#define OID_STA_GET_ROAM_REASON (WL_OID_BASE + WLC_GET_PREV_ROAM_REASON)
-#define OID_STA_SET_ROAM_REASON (WL_OID_BASE + WLC_SET_PREV_ROAM_REASON)
-#define OID_STA_GET_PHY_STATE (WL_OID_BASE + WLC_GET_PHY_STATE)
-#define OID_STA_INT_DISASSOC	(WL_OID_BASE + WLC_GET_INT_DISASSOC)
-#define OID_STA_SET_NUM_PEERS	(WL_OID_BASE + WLC_SET_NUM_PEERS)
-#define OID_STA_GET_NUM_BSS		(WL_OID_BASE + WLC_GET_NUM_BSS)
-#define WL_DECRYPT_STATUS_SUCCESS	1
-#define WL_DECRYPT_STATUS_FAILURE	2
-#define WL_DECRYPT_STATUS_UNKNOWN	3
-
-
-#define WLC_UPGRADE_SUCCESS			0
-#define WLC_UPGRADE_PENDING			1
-
-#ifdef CONFIG_USBRNDIS_RETAIL
-
-typedef struct {
-	char *name;
-	void *param;
-} ndconfig_item_t;
-#endif
-
-#ifdef EXT_STA
-typedef struct _wl_assoc_result {
-	ulong associated;
-	ulong NDIS_auth;
-	ulong NDIS_infra;
-} wl_assoc_result_t;
-#endif
-#endif 
 
 
 #define WL_RADIO_SW_DISABLE		(1<<0)
@@ -1434,7 +866,7 @@ typedef struct _wl_assoc_result {
 #define PM_MAX	1
 #define PM_FAST 2
 
-#define LISTEN_INTERVAL			5 // 10 -> 5
+#define LISTEN_INTERVAL			20
 
 #define	INTERFERE_NONE	0	
 #define	NON_WLAN	1	
@@ -1459,177 +891,6 @@ typedef struct wl_aci_args {
 
 #define WL_ACI_ARGS_LEGACY_LENGTH	16	
 
-#if !defined(ESTA_POSTMOGRIFY_REMOVAL)
-typedef struct {
-	int npulses; 	
-	int ncontig; 	
-	int min_pw; 	
-	int max_pw; 	
-	uint16 thresh0;	
-	uint16 thresh1;	
-	uint16 blank;	
-	uint16 fmdemodcfg;	
-	int npulses_lp;  
-	int min_pw_lp; 
-	int max_pw_lp; 
-	int min_fm_lp; 
-	int max_deltat_lp;  
-	int min_deltat; 
-	int max_deltat; 
-	uint16 autocorr;	
-	uint16 st_level_time;	
-	uint16 t2_min; 
-	uint32 version; 
-} wl_radar_args_t;
-
-#define WL_RADAR_ARGS_VERSION 1
-
-
-#define WL_RADAR_DETECTOR_OFF		0	
-#define WL_RADAR_DETECTOR_ON		1	
-#define WL_RADAR_SIMULATED		2	
-
-#define WL_RSSI_ANT_VERSION	1	
-#define WL_RSSI_ANT_MAX		4	
-
-
-typedef struct {
-	uint32	version;		
-	uint32	count;			
-	int8 rssi_ant[WL_RSSI_ANT_MAX];	
-} wl_rssi_ant_t;
-
-
-
-
-
-
-
-#define WL_DFS_CACSTATE_IDLE		0	
-#define	WL_DFS_CACSTATE_PREISM_CAC	1	
-#define WL_DFS_CACSTATE_ISM		2	
-#define WL_DFS_CACSTATE_CSA		3	
-#define WL_DFS_CACSTATE_POSTISM_CAC	4	
-#define WL_DFS_CACSTATE_PREISM_OOC	5	
-#define WL_DFS_CACSTATE_POSTISM_OOC	6	
-#define WL_DFS_CACSTATES		7	
-
-
-typedef struct {
-	uint state;		
-	uint duration;		
-	
-	chanspec_t chanspec_cleared;
-	
-	uint16 pad;
-} wl_dfs_status_t;
-
-#define NUM_PWRCTRL_RATES 12
-typedef struct {
-	uint8 txpwr_band_max[NUM_PWRCTRL_RATES];	
-	uint8 txpwr_limit[NUM_PWRCTRL_RATES];		
-	uint8 txpwr_local_max;				
-	uint8 txpwr_local_constraint;			
-	uint8 txpwr_chan_reg_max;			
-	uint8 txpwr_target[2][NUM_PWRCTRL_RATES];	
-	uint8 txpwr_est_Pout[2];			
-	uint8 txpwr_opo[NUM_PWRCTRL_RATES];		
-	uint8 txpwr_bphy_cck_max[NUM_PWRCTRL_RATES];	
-	uint8 txpwr_bphy_ofdm_max;			
-	uint8 txpwr_aphy_max[NUM_PWRCTRL_RATES];	
-	int8  txpwr_antgain[2];				
-	uint8 txpwr_est_Pout_gofdm;			
-} tx_power_legacy_t;
-
-#define WL_TX_POWER_RATES	45
-#define WL_TX_POWER_CCK_FIRST	0
-#define WL_TX_POWER_CCK_NUM	4
-#define WL_TX_POWER_OFDM_FIRST	4
-#define WL_TX_POWER_OFDM_NUM	8
-#define WL_TX_POWER_MCS_SISO_NUM 8
-#define WL_TX_POWER_MCS20_FIRST	12
-#define WL_TX_POWER_MCS20_NUM	16
-#define WL_TX_POWER_MCS40_FIRST	28
-#define WL_TX_POWER_MCS40_NUM	17
-#define WL_TX_POWER_MCS20SISO_NUM	8
-#define WL_TX_POWER_MCS40_LAST  44
-
-
-#define WL_TX_POWER_F_ENABLED	1
-#define WL_TX_POWER_F_HW	2
-#define WL_TX_POWER_F_MIMO	4
-#define WL_TX_POWER_F_SISO	8
-#define WL_TX_POWER_F_40M_CAP   16
-
-typedef struct {
-	uint32 flags;
-	chanspec_t chanspec;			
-	chanspec_t local_chanspec;		
-	uint8 local_max;			
-	uint8 local_constraint;			
-	int8  antgain[2];			
-	uint8 rf_cores;				
-	uint8 est_Pout[4];			
-	uint8 est_Pout_cck;			
-	uint8 user_limit[WL_TX_POWER_RATES];	
-	uint8 reg_limit[WL_TX_POWER_RATES];	
-	uint8 board_limit[WL_TX_POWER_RATES];	
-	uint8 target[WL_TX_POWER_RATES];	
-} tx_power_t;
-
-typedef struct tx_inst_power {
-	uint8 txpwr_est_Pout[2];			
-	uint8 txpwr_est_Pout_gofdm;			
-} tx_inst_power_t;
-
-
-#define WLC_MEASURE_TPC			1
-#define WLC_MEASURE_CHANNEL_BASIC	2
-#define WLC_MEASURE_CHANNEL_CCA		3
-#define WLC_MEASURE_CHANNEL_RPI		4
-
-
-#define SPECT_MNGMT_OFF			0		
-#define SPECT_MNGMT_LOOSE_11H		1		
-#define SPECT_MNGMT_STRICT_11H		2		
-#define SPECT_MNGMT_STRICT_11D		3		
-
-#define SPECT_MNGMT_LOOSE_11H_D		4		
-
-#define WL_CHAN_VALID_HW	(1 << 0)	
-#define WL_CHAN_VALID_SW	(1 << 1)	
-#define WL_CHAN_BAND_5G		(1 << 2)	
-#define WL_CHAN_RADAR		(1 << 3)	
-#define WL_CHAN_INACTIVE	(1 << 4)	
-#define WL_CHAN_PASSIVE		(1 << 5)	
-#define WL_CHAN_RESTRICTED	(1 << 6)	
-
-
-#define	WL_BTC_DISABLE		0	
-#define WL_BTC_ENABLE		(1 << 0)	
-#define WL_BTC_PREMPT		(1 << 1)	
-#define WL_BTC_PARTIAL		(1 << 2)   
-#define WL_BTC_DEFAULT		(1 << 3)	
-#define WL_BTC_HYBRID		(WL_BTC_ENABLE | WL_BTC_PARTIAL)
-#define WL_INF_BTC_DISABLE      0
-#define WL_INF_BTC_ENABLE       1
-#define WL_INF_BTC_AUTO         3
-
-
-#define	WL_BTC_DEFWIRE		0	
-#define WL_BTC_2WIRE		2	
-#define WL_BTC_3WIRE		3	
-#define WL_BTC_4WIRE		4	
-
-
-#define WL_BTC_FLAG_BT_DEF               (1 << 0)
-#define WL_BTC_FLAG_PREMPT               (1 << 1)
-#define WL_BTC_FLAG_ACTIVE_PROT          (1 << 2)
-#define WL_BTC_FLAG_SIM_RSP              (1 << 3)
-#define WL_BTC_FLAG_PS_PROTECT           (1 << 4)
-#define WL_BTC_FLAG_SIM_TX_LP	         (1 << 5)
-#define WL_BTC_FLAG_ECI                  (1 << 6)
-#endif 
 
 
 #define WL_ERROR_VAL		0x00000001
@@ -1671,8 +932,6 @@ typedef struct tx_inst_power {
 #define WL_COEX_VAL		0x00000008
 #define WL_RTDC_VAL		0x00000010
 #define WL_BTA_VAL		0x00000040
-#define WL_P2P_VAL		0x00000200
-#define WL_MCHAN_VAL		0x00000800
 
 
 #define	WL_LED_NUMGPIO		16	
@@ -1710,13 +969,40 @@ typedef struct tx_inst_power {
 #define WL_EVENTING_MASK_LEN	16
 
 
+#define VNDR_IE_CMD_LEN		4	
+
+
+#define VNDR_IE_BEACON_FLAG	0x1
+#define VNDR_IE_PRBRSP_FLAG	0x2
+#define VNDR_IE_ASSOCRSP_FLAG	0x4
+#define VNDR_IE_AUTHRSP_FLAG	0x8
+#define VNDR_IE_PRBREQ_FLAG	0x10
+#define VNDR_IE_ASSOCREQ_FLAG	0x20
+#define VNDR_IE_CUSTOM_FLAG		0x100 
+
+#define VNDR_IE_INFO_HDR_LEN	(sizeof(uint32))
+
+typedef struct {
+	uint32 pktflag;			
+	vndr_ie_t vndr_ie_data;		
+} vndr_ie_info_t;
+
+typedef struct {
+	int iecount;			
+	vndr_ie_info_t vndr_ie_list[1];	
+} vndr_ie_buf_t;
+
+typedef struct {
+	char cmd[VNDR_IE_CMD_LEN];	
+	vndr_ie_buf_t vndr_ie_buffer;	
+} vndr_ie_setbuf_t;
+
 
 
 
 #define WL_JOIN_PREF_RSSI	1	
 #define WL_JOIN_PREF_WPA	2	
 #define WL_JOIN_PREF_BAND	3	
-#define WL_JOIN_PREF_RSSI_DELTA	4	
 
 
 #define WLJP_BAND_ASSOC_PREF	255	
@@ -1731,7 +1017,6 @@ struct tsinfo_arg {
 
 #define	NFIFO			6	
 
-#define	WL_MIN_CNT_ENABLED	0x8000 
 #define	WL_CNT_T_VERSION	5	
 #define	WL_CNT_EXT_T_VERSION	1
 
@@ -1932,6 +1217,7 @@ typedef struct {
 	uint32	rxmcs5_40M;  
 	uint32	rxmcs6_40M;  
 	uint32	rxmcs7_40M;  
+	uint32	rxmcs32_40M;  
 
 	uint32	txfrmsnt_20Mlo;  
 	uint32	txfrmsnt_20Mup;  
@@ -1940,6 +1226,14 @@ typedef struct {
 	uint32 rx_20ul;
 } wl_cnt_ext_t;
 
+#define	WL_RXDIV_STATS_T_VERSION	1	
+typedef struct {
+	uint16	version;	
+	uint16	length;		
+
+	uint32 rxant[4];	
+} wl_rxdiv_stats_t;
+
 #define	WL_DELTA_STATS_T_VERSION	1	
 
 typedef struct {
@@ -2002,227 +1296,12 @@ typedef struct {
 
 } wl_wme_cnt_t;
 
-#if !defined(ESTA_POSTMOGRIFY_REMOVAL)
-#ifdef WLBA
-
-#define	WLC_BA_CNT_VERSION	1	
-
-
-typedef struct wlc_ba_cnt {
-	uint16	version;	
-	uint16	length;		
-
-	
-	uint32 txpdu;		
-	uint32 txsdu;		
-	uint32 txfc;		
-	uint32 txfci;		
-	uint32 txretrans;	
-	uint32 txbatimer;	
-	uint32 txdrop;		
-	uint32 txaddbareq;	
-	uint32 txaddbaresp;	
-	uint32 txdelba;		
-	uint32 txba;		
-	uint32 txbar;		
-	uint32 txpad[4];	
-
-	
-	uint32 rxpdu;		
-	uint32 rxqed;		
-	uint32 rxdup;		
-	uint32 rxnobuf;		
-	uint32 rxaddbareq;	
-	uint32 rxaddbaresp;	
-	uint32 rxdelba;		
-	uint32 rxba;		
-	uint32 rxbar;		
-	uint32 rxinvba;		
-	uint32 rxbaholes;	
-	uint32 rxunexp;		
-	uint32 rxpad[4];	
-} wlc_ba_cnt_t;
-#endif 
-
-
-struct ampdu_tid_control {
-	uint8 tid;			
-	uint8 enable;			
-};
-
-struct wl_msglevel2 {
-	uint32 low;
-	uint32 high;
-};
-
-
-struct ampdu_ea_tid {
-	struct ether_addr ea;		
-	uint8 tid;			
-};
-
-struct ampdu_retry_tid {
-	uint8 tid;	
-	uint8 retry;	
-};
-
-
-struct ampdu_ba_sizes {
-	uint8 ba_tx_wsize;	
-	uint8 ba_rx_wsize;	
-};
-
-
-
-#define	DPT_DISCOVERY_MANUAL	0x01	
-#define	DPT_DISCOVERY_AUTO	0x02	
-#define	DPT_DISCOVERY_SCAN	0x04	
-
-
-#define DPT_PATHSEL_AUTO	0	
-#define DPT_PATHSEL_DIRECT	1	
-#define DPT_PATHSEL_APPATH	2	
-
-
-#define DPT_DENY_LIST_ADD 	1	
-#define DPT_DENY_LIST_REMOVE 	2	
-
-
-#define DPT_MANUAL_EP_CREATE	1	
-#define DPT_MANUAL_EP_MODIFY	2	
-#define DPT_MANUAL_EP_DELETE	3	
-
-
-typedef struct dpt_iovar {
-	struct ether_addr ea;		
-	uint8 mode;			
-	uint32 pad;			
-} dpt_iovar_t;
-
-
-#define	DPT_STATUS_ACTIVE	0x01	
-#define	DPT_STATUS_AES		0x02	
-#define	DPT_STATUS_FAILED	0x04	
-
-#define	DPT_FNAME_LEN		48	
-
-typedef struct dpt_status {
-	uint8 status;			
-	uint8 fnlen;			
-	uchar name[DPT_FNAME_LEN];	
-	uint32 rssi;			
-	sta_info_t sta;			
-} dpt_status_t;
-
-
-typedef struct dpt_list {
-	uint32 num;			
-	dpt_status_t status[1];		
-} dpt_list_t;
-
-
-typedef struct dpt_fname {
-	uint8 len;			
-	uchar name[DPT_FNAME_LEN];	
-} dpt_fname_t;
-
-#define	BDD_FNAME_LEN		32	
-typedef struct bdd_fname {
-	uint8 len;			
-	uchar name[BDD_FNAME_LEN];	
-} bdd_fname_t;
-
-
-
-struct tslist {
-	int count;			
-	struct tsinfo_arg tsinfo[1];	
-};
-
-
-typedef struct tspec_arg {
-	uint16 version;				
-	uint16 length;				
-	uint flag;					
-	
-	struct tsinfo_arg tsinfo;	
-	uint16 nom_msdu_size;		
-	uint16 max_msdu_size;		
-	uint min_srv_interval;		
-	uint max_srv_interval;		
-	uint inactivity_interval;	
-	uint suspension_interval;	
-	uint srv_start_time;		
-	uint min_data_rate;			
-	uint mean_data_rate;		
-	uint peak_data_rate;		
-	uint max_burst_size;		
-	uint delay_bound;			
-	uint min_phy_rate;			
-	uint16 surplus_bw;			
-	uint16 medium_time;			
-	uint8	dialog_token;		
-} tspec_arg_t;
-
-
-typedef	struct tspec_per_sta_arg {
-	struct ether_addr ea;
-	struct tspec_arg ts;
-} tspec_per_sta_arg_t;
-
-
-typedef	struct wme_max_bandwidth {
-	uint32	ac[AC_COUNT];	
-} wme_max_bandwidth_t;
-
-#define WL_WME_MBW_PARAMS_IO_BYTES (sizeof(wme_max_bandwidth_t))
-
-
-#define	TSPEC_ARG_VERSION		2	
-#define TSPEC_ARG_LENGTH		55	
-#define TSPEC_DEFAULT_DIALOG_TOKEN	42	
-#define TSPEC_DEFAULT_SBW_FACTOR	0x3000	
-
-
-
-#define TSPEC_PENDING		0	
-#define TSPEC_ACCEPTED		1	
-#define TSPEC_REJECTED		2	
-#define TSPEC_UNKNOWN		3	
-#define TSPEC_STATUS_MASK	7	
-
-
-
-#ifdef WLAFTERBURNER
-#define WL_SWFL_ABBFL		0x0001 
-#define WL_SWFL_ABENCORE	0x0002 
-#endif 
-#define WL_SWFL_NOHWRADIO	0x0004
-
-#define WL_LIFETIME_MAX 0xFFFF 
-
-
-typedef struct wl_lifetime {
-	uint32 ac;	        
-	uint32 lifetime;    
-} wl_lifetime_t;
-
-
-
-typedef struct wl_chan_switch {
-	uint8 mode;		
-	uint8 count;		
-	chanspec_t chspec;	
-	uint8 reg;		
-} wl_chan_switch_t;
-#endif 
 
 
 #define WLC_ROAM_TRIGGER_DEFAULT	0 
 #define WLC_ROAM_TRIGGER_BANDWIDTH	1 
 #define WLC_ROAM_TRIGGER_DISTANCE	2 
-#define WLC_ROAM_TRIGGER_AUTO		3 
-#define WLC_ROAM_TRIGGER_MAX_VALUE	3 
+#define WLC_ROAM_TRIGGER_MAX_VALUE	2 
 
 
 enum {
@@ -2265,7 +1344,7 @@ typedef struct wl_pfn {
 	int32			bss_type;		
 	int32			infra;			
 	int32			auth;			
-	int32			wpa_auth;		
+	uint32			wpa_auth;		
 	int32			wsec;			
 #ifdef WLPFN_AUTO_CONNECT
 	union {
@@ -2457,40 +1536,6 @@ typedef struct wl_pkteng_stats {
 	uint16 rxpktcnt[NUM_80211_RATES+1];
 } wl_pkteng_stats_t;
 
-#if !defined(BCMDONGLEHOST) || defined(BCMINTERNAL) || defined(WLTEST)
-typedef struct wl_sslpnphy_papd_debug_data {
-	uint8 psat_pwr;
-	uint8 psat_indx;
-	uint8 final_idx;
-	uint8 start_idx;
-	int32 min_phase;
-	int32 voltage;
-	int8 temperature;
-} wl_sslpnphy_papd_debug_data_t;
-typedef struct wl_sslpnphy_debug_data {
-	int16 papdcompRe [64];
-	int16 papdcompIm [64];
-} wl_sslpnphy_debug_data_t;
-typedef struct wl_sslpnphy_spbdump_data {
-	uint16 tbl_length;
-	int16 spbreal[256];
-	int16 spbimg[256];
-} wl_sslpnphy_spbdump_data_t;
-typedef struct wl_sslpnphy_percal_debug_data {
-	uint cur_idx;
-	uint tx_drift;
-	uint8 prev_cal_idx;
-	uint percal_ctr;
-	int nxt_cal_idx;
-	uint force_1idxcal;
-	uint onedxacl_req;
-	int32 last_cal_volt;
-	int8 last_cal_temp;
-	uint vbat_ripple;
-	uint exit_route;
-	int32 volt_winner;
-} wl_sslpnphy_percal_debug_data_t;
-#endif 
 #define WL_WOWL_MAGIC	(1 << 0)	
 #define WL_WOWL_NET	(1 << 1)	
 #define WL_WOWL_DIS	(1 << 2)	
@@ -2506,7 +1551,6 @@ typedef struct {
 	uint offset;		
 	uint patternoffset;	
 	uint patternsize;	
-	uint reasonsize;	
 	
 	
 } wl_wowl_pattern_t;
@@ -2529,11 +1573,6 @@ typedef struct wl_txrate_class {
 } wl_txrate_class_t;
 
 
-#if defined(DSLCPE_DELAY)
-#define WL_DELAYMODE_DEFER	0	
-#define WL_DELAYMODE_FORCE	1	
-#define WL_DELAYMODE_AUTO	2	
-#endif
 
 
 #define WLC_OBSS_SCAN_PASSIVE_DWELL_DEFAULT		100	
@@ -2576,6 +1615,12 @@ typedef struct wl_obss_scan_arg {
 #define	WL_COEX_40MHZ_INTOLERANT	0x02
 #define	WL_COEX_WIDTH20			0x04
 
+typedef struct wl_action_obss_coex_req {
+	uint8 info;
+	uint8 num;
+	uint8 ch_list[1];
+} wl_action_obss_coex_req_t;
+
 
 #define MAX_RSSI_LEVELS 8
 
@@ -2589,47 +1634,6 @@ typedef struct wl_rssi_event {
 	int8 rssi_levels[MAX_RSSI_LEVELS];
 } wl_rssi_event_t;
 
-#ifdef DHD_NDIS_OID
-
-typedef struct wl_bsscfg {
-	uint32	wsec;
-	uint32	WPA_auth;
-	int32	wsec_index;
-	uint32	associated;
-	uint32	BSS;
-	uint32	phytest_on;
-	struct ether_addr	prev_BSSID;
-	struct ether_addr	BSSID;
-} wl_bsscfg_t;
-
-typedef struct wl_bss_config {
-	uint32	atim_window;
-	uint32	beacon_period;
-	uint32	chanspec;
-} wl_bss_config_t;
-#endif 
-
-#ifdef DONGLEOVERLAYS
-typedef struct {
-	uint32 flags_idx;	
-	uint32 offset;		
-	uint32 len;			
-	
-} wl_ioctl_overlay_t;
-
-#define OVERLAY_IDX_MASK		0x000000ff
-#define OVERLAY_IDX_SHIFT		0
-#define OVERLAY_FLAGS_MASK		0xffffff00
-#define OVERLAY_FLAGS_SHIFT		8
-
-#define OVERLAY_FLAG_POSTLOAD	0x100
-
-#define OVERLAY_FLAG_DEFER_DL	0x200
-
-#define OVERLAY_FLAG_PRESLEEP	0x400
-
-#define OVERLAY_DOWNLOAD_CHUNKSIZE	1024
-#endif 
 
 
 #define WLFEATURE_DISABLE_11N		0x00000001
@@ -2641,39 +1645,12 @@ typedef struct {
 #define WLFEATURE_DISABLE_11N_AMPDU_RX	0x00000040
 #define WLFEATURE_DISABLE_11N_GF	0x00000080
 
-#include <packed_section_end.h>
-
-
-#include <packed_section_start.h>
-
-#define VNDR_IE_CMD_LEN		4	
-
-
-#define VNDR_IE_BEACON_FLAG	0x1
-#define VNDR_IE_PRBRSP_FLAG	0x2
-#define VNDR_IE_ASSOCRSP_FLAG	0x4
-#define VNDR_IE_AUTHRSP_FLAG	0x8
-#define VNDR_IE_PRBREQ_FLAG	0x10
-#define VNDR_IE_ASSOCREQ_FLAG	0x20
-#define VNDR_IE_CUSTOM_FLAG		0x100 
 
-#define VNDR_IE_INFO_HDR_LEN	(sizeof(uint32))
 
-typedef BWL_PRE_PACKED_STRUCT struct {
-	uint32 pktflag;			
-	vndr_ie_t vndr_ie_data;		
-} BWL_POST_PACKED_STRUCT vndr_ie_info_t;
+#include <packed_section_end.h>
 
-typedef BWL_PRE_PACKED_STRUCT struct {
-	int iecount;			
-	vndr_ie_info_t vndr_ie_list[1];	
-} BWL_POST_PACKED_STRUCT vndr_ie_buf_t;
-
-typedef BWL_PRE_PACKED_STRUCT struct {
-	char cmd[VNDR_IE_CMD_LEN];	
-	vndr_ie_buf_t vndr_ie_buffer;	
-} BWL_POST_PACKED_STRUCT vndr_ie_setbuf_t;
 
+#include <packed_section_start.h>
 
 
 typedef BWL_PRE_PACKED_STRUCT struct sta_prbreq_wps_ie_hdr {
@@ -2691,104 +1668,7 @@ typedef BWL_PRE_PACKED_STRUCT struct sta_prbreq_wps_ie_list {
 	uint8 ieDataList[1];
 } BWL_POST_PACKED_STRUCT sta_prbreq_wps_ie_list_t;
 
-#include <packed_section_end.h>
-
-
-#ifdef WLP2P
-
-typedef struct wl_p2p_disc_st {
-	uint8 state;	
-	chanspec_t chspec;	
-	uint16 dwell;	
-} wl_p2p_disc_st_t;
-
-
-#define WL_P2P_DISC_ST_SCAN	0
-#define WL_P2P_DISC_ST_LISTEN	1
-#define WL_P2P_DISC_ST_SEARCH	2
-
-
-typedef struct wl_p2p_scan {
-	uint8 type;		
-	uint8 reserved[3];
-	
-} wl_p2p_scan_t;
-
-
-typedef struct wl_p2p_if {
-	struct ether_addr addr;
-	uint8 type;	
-	chanspec_t chspec;	
-} wl_p2p_if_t;
-
-
-#define WL_P2P_IF_CLIENT	0
-#define WL_P2P_IF_GO		1
-#define WL_P2P_IF_DEV		3
-
-
-typedef struct wl_p2p_ifq {
-	uint bsscfgidx;
-	char ifname[BCM_MSG_IFNAME_MAX];
-} wl_p2p_ifq_t;
-
-
-typedef struct wl_p2p_ops {
-	uint8 ops;	
-	uint8 ctw;	
-} wl_p2p_ops_t;
-
-
-typedef struct wl_p2p_sched_desc {
-	uint32 start;
-	uint32 interval;
-	uint32 duration;
-	uint32 count;	
-} wl_p2p_sched_desc_t;
-
 
-#define WL_P2P_SCHED_RSVD	0
-#define WL_P2P_SCHED_REPEAT	255	
-
-typedef struct wl_p2p_sched {
-	uint8 type;	
-	uint8 action;	
-	uint8 option;	
-	wl_p2p_sched_desc_t desc[1];
-} wl_p2p_sched_t;
-#define WL_P2P_SCHED_FIXED_LEN		3
-
-
-#define WL_P2P_SCHED_TYPE_ABS		0	
-#define WL_P2P_SCHED_TYPE_REQ_ABS	1	
-
-
-#define WL_P2P_SCHED_ACTION_NONE	0	
-#define WL_P2P_SCHED_ACTION_DOZE	1	
-
-#define WL_P2P_SCHED_ACTION_GOOFF	2	
-
-#define WL_P2P_SCHED_ACTION_RESET	255	
-
-
-#define WL_P2P_SCHED_OPTION_NORMAL	0	
-#define WL_P2P_SCHED_OPTION_BCNPCT	1	
-
-#define WL_P2P_SCHED_OPTION_TSFOFS	2	
-#endif 
-
-#ifdef PROP_TXSTATUS
-
-
-#define WLFC_FLAGS_RSSI_SIGNALS				1
-
-
-#define WLFC_FLAGS_XONXOFF_SIGNALS			2
-
-
-#define WLFC_FLAGS_CREDIT_STATUS_SIGNALS	4
-
-#define WLFC_FLAGS_HOST_PROPTXSTATUS_ACTIVE	8
-#endif 
+#include <packed_section_end.h>
 
 #endif 
diff --git a/drivers/net/wireless/bcm43291/src/shared/aiutils.c b/drivers/net/wireless/bcm43291/src/shared/aiutils.c
index ecd6459..df48ac0 100644
--- a/drivers/net/wireless/bcm43291/src/shared/aiutils.c
+++ b/drivers/net/wireless/bcm43291/src/shared/aiutils.c
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: aiutils.c,v 1.6.4.7.4.1.62.2.24.1 2010/05/10 04:55:55 Exp $
+ * $Id: aiutils.c,v 1.6.4.7.4.6 2010/04/21 20:43:47 Exp $
  */
 
 #include <typedefs.h>
@@ -36,6 +36,11 @@
 
 #include "siutils_priv.h"
 
+STATIC uint32
+get_asd(si_t *sih, uint32 *eromptr, uint sp, uint ad, uint st,
+	uint32 *addrl, uint32 *addrh, uint32 *sizel, uint32 *sizeh);
+
+
 /* EROM parsing */
 
 static uint32
@@ -71,7 +76,7 @@ get_erom_ent(si_t *sih, uint32 *eromptr, uint32 mask, uint32 match)
 	return ent;
 }
 
-static uint32
+STATIC uint32
 get_asd(si_t *sih, uint32 *eromptr, uint sp, uint ad, uint st,
 	uint32 *addrl, uint32 *addrh, uint32 *sizel, uint32 *sizeh)
 {
@@ -491,6 +496,9 @@ ai_corereg(si_t *sih, uint coreidx, uint regoff, uint mask, uint val)
 	ASSERT(regoff < SI_CORE_SIZE);
 	ASSERT((val & ~mask) == 0);
 
+	if (coreidx >= SI_MAXCORES)
+		return 0;
+
 	if (BUSTYPE(sih->bustype) == SI_BUS) {
 		/* If internal bus, we can always get at everything */
 		fast = TRUE;
diff --git a/drivers/net/wireless/bcm43291/src/shared/bcmutils.c b/drivers/net/wireless/bcm43291/src/shared/bcmutils.c
index 89ec5e2..43c04ee 100644
--- a/drivers/net/wireless/bcm43291/src/shared/bcmutils.c
+++ b/drivers/net/wireless/bcm43291/src/shared/bcmutils.c
@@ -20,7 +20,7 @@
  *      Notwithstanding the above, under no circumstances may you combine this
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
- * $Id: bcmutils.c,v 1.210.4.5.2.4.6.9.2.21.2.6 2010/09/21 19:31:21 Exp $
+ * $Id: bcmutils.c,v 1.210.4.5.2.4.6.19 2010/04/26 06:05:25 Exp $
  */
 
 #include <typedefs.h>
@@ -33,6 +33,11 @@
 #else
 #include <stdio.h>
 #include <string.h>
+/* This case for external supplicant use */
+#if defined(BCMEXTSUP)
+#include <bcm_osl.h>
+#endif
+
 #endif /* BCMDRIVER */
 #include <bcmendian.h>
 #include <bcmdevs.h>
@@ -1500,8 +1505,6 @@ bcm_format_hex(char *str, const void *bytes, int len)
 	}
 	return (int)(p - str);
 }
-#endif 
-
 
 /* pretty hex print a contiguous buffer */
 void
@@ -1529,27 +1532,7 @@ prhex(const char *msg, uchar *buf, uint nbytes)
 	if (p != line)
 		printf("%s\n", line);
 }
-
-static const char *crypto_algo_names[] = {
-	"NONE",
-	"WEP1",
-	"TKIP",
-	"WEP128",
-	"AES_CCM",
-	"AES_OCB_MSDU",
-	"AES_OCB_MPDU",
-	"NALG"
-	"UNDEF",
-	"UNDEF",
-	"UNDEF",
-	"UNDEF"
-};
-
-const char *
-bcm_crypto_algo_name(uint algo)
-{
-	return (algo < ARRAYSIZE(crypto_algo_names)) ? crypto_algo_names[algo] : "ERR";
-}
+#endif 
 
 
 /* Produce a human-readable string for boardrev */
@@ -1823,6 +1806,8 @@ bcm_print_bytes(char *name, const uchar *data, int len)
  * 32 SSID chars, max of 4 chars for each SSID char "\xFF", plus NULL.
  */
 
+#if defined(WLTINYDUMP) || defined(WLMSG_INFORM) || defined(WLMSG_ASSOC) || \
+	defined(WLMSG_PRPKT) || defined(WLMSG_WSEC)
 int
 bcm_format_ssid(char* buf, const uchar ssid[], uint ssid_len)
 {
@@ -1848,5 +1833,6 @@ bcm_format_ssid(char* buf, const uchar ssid[], uint ssid_len)
 
 	return (int)(p - buf);
 }
+#endif 
 
 #endif /* BCMDRIVER */
diff --git a/drivers/net/wireless/bcm43291/src/shared/bcmwifi.c b/drivers/net/wireless/bcm43291/src/shared/bcmwifi.c
index f18700a..3c6ab9b 100644
--- a/drivers/net/wireless/bcm43291/src/shared/bcmwifi.c
+++ b/drivers/net/wireless/bcm43291/src/shared/bcmwifi.c
@@ -22,7 +22,7 @@
  *      Notwithstanding the above, under no circumstances may you combine this
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
- * $Id: bcmwifi.c,v 1.18.24.2.106.1.24.1 2010/05/06 05:40:33 Exp $
+ * $Id: bcmwifi.c,v 1.18.24.2.4.1 2009/09/25 00:32:01 Exp $
  */
 
 
@@ -189,9 +189,9 @@ wf_channel2mhz(uint ch, uint start_factor)
 	int freq;
 
 	if ((start_factor == WF_CHAN_FACTOR_2_4_G && (ch < 1 || ch > 14)) ||
-	    (ch > 200))
+	    (ch <= 200))
 		freq = -1;
-	else if ((start_factor == WF_CHAN_FACTOR_2_4_G) && (ch == 14))
+	if ((start_factor == WF_CHAN_FACTOR_2_4_G) && (ch == 14))
 		freq = 2484;
 	else
 		freq = ch * 5 + start_factor / 2;
diff --git a/drivers/net/wireless/bcm43291/src/shared/hndpmu.c b/drivers/net/wireless/bcm43291/src/shared/hndpmu.c
index 35f54d1..307347a 100644
--- a/drivers/net/wireless/bcm43291/src/shared/hndpmu.c
+++ b/drivers/net/wireless/bcm43291/src/shared/hndpmu.c
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: hndpmu.c,v 1.95.2.17.4.11.2.36.4.17.2.5 2010/11/11 15:42:15 Exp $
+ * $Id: hndpmu.c,v 1.95.2.17.4.11.2.63 2010/07/21 13:55:09 Exp $
  */
 
 #include <typedefs.h>
@@ -70,7 +70,7 @@ void
 si_sdiod_drive_strength_init(si_t *sih, osl_t *osh, uint32 drivestrength)
 {
 	chipcregs_t *cc;
-	uint origidx, intr_val;
+	uint origidx, intr_val = 0;
 	sdiod_drive_str_t *str_tab = NULL;
 	uint32 str_mask = 0;
 	uint32 str_shift = 0;
diff --git a/drivers/net/wireless/bcm43291/src/shared/linux_osl.c b/drivers/net/wireless/bcm43291/src/shared/linux_osl.c
index fdad7d6..16bba69 100644
--- a/drivers/net/wireless/bcm43291/src/shared/linux_osl.c
+++ b/drivers/net/wireless/bcm43291/src/shared/linux_osl.c
@@ -21,12 +21,14 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: linux_osl.c,v 1.125.12.3.8.1.54.9.2.1 2010/06/30 03:10:10 Exp $
+ * $Id: linux_osl.c,v 1.125.12.3.8.7 2010/05/04 21:10:04 Exp $
  */
 
 
 #define LINUX_OSL
-
+#if defined(CHROMIUMOS_COMPAT_WIRELESS)
+#include <linux/sched.h>
+#endif
 #include <typedefs.h>
 #include <bcmendian.h>
 #include <linuxver.h>
@@ -36,6 +38,10 @@
 #include <linux/delay.h>
 #include <pcicfg.h>
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+#include <linux/mutex.h>
+#endif
+
 #define PCI_CFG_RETRY 		10
 
 #define OS_HANDLE_MAGIC		0x1234abcd	
@@ -60,7 +66,7 @@ static bcm_static_buf_t *bcm_static_buf = 0;
 #define MAX_STATIC_PKT_NUM 8
 typedef struct bcm_static_pkt {
 	struct sk_buff *skb_4k[MAX_STATIC_PKT_NUM];
-	struct sk_buff *skb_12k[MAX_STATIC_PKT_NUM];
+	struct sk_buff *skb_8k[MAX_STATIC_PKT_NUM];
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))     
     struct mutex osl_pkt_sem; 
 #else 
@@ -132,12 +138,10 @@ static int16 linuxbcmerrormap[] =
 	-EIO,			
 	-EINVAL,		
 	-EINVAL,		
-	-ENODATA,		
-	-EOPNOTSUPP,		
 
 
 
-#if BCME_LAST != -43
+#if BCME_LAST != -41
 #error "You need to add a OS error translation in the linuxbcmerrormap \
 	for new error code defined in bcmutils.h"
 #endif 
@@ -165,6 +169,12 @@ osl_attach(void *pdev, uint bustype, bool pkttag)
 	osh = kmalloc(sizeof(osl_t), GFP_ATOMIC);
 	ASSERT(osh);
 
+/* LGE_CHANGE_S, [dongp.kim@lge.com], 2010-04-22, WBT Fix */
+// WBT Fix TD# 37025, 37026
+	if ( ! osh )
+	    return NULL;
+/* LGE_CHANGE_S, [dongp.kim@lge.com], 2010-04-22, WBT Fix */
+
 	bzero(osh, sizeof(osl_t));
 
 	
@@ -202,13 +212,10 @@ osl_attach(void *pdev, uint bustype, bool pkttag)
 		if (!(bcm_static_buf = (bcm_static_buf_t *)dhd_os_prealloc(3, STATIC_BUF_SIZE+
 			STATIC_BUF_TOTAL_LEN))) {
 			printk("can not alloc static buf!\n");
-            return NULL; /* BRCM_UPDATE */
 		}
 		else
 			printk("alloc static buf at %x!\n", (unsigned int)bcm_static_buf);
-
-
-#ifndef init_MUTEX
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 		mutex_init(&bcm_static_buf->static_sem);
 #else
 		init_MUTEX(&bcm_static_buf->static_sem);
@@ -229,7 +236,7 @@ osl_attach(void *pdev, uint bustype, bool pkttag)
 		for (i = 0; i < MAX_STATIC_PKT_NUM*2; i++)
 			bcm_static_skb->pkt_use[i] = 0;
 
-#if (LINUX_VERSION_CODE >=  KERNEL_VERSION(2, 6, 38))         
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 		mutex_init(&bcm_static_skb->osl_pkt_sem);
 #else 
 		init_MUTEX(&bcm_static_skb->osl_pkt_sem);
@@ -313,14 +320,14 @@ osl_pktget_static(osl_t *osh, uint len)
 	struct sk_buff *skb;
 
 
-	if (len > (PAGE_SIZE*3))
+	if (len > (PAGE_SIZE*2))
 	{
-		printk("Do we really need this big skb?? len=%d\n",len);
+		printk("Do we really need this big skb??\n");
 		return osl_pktget(osh, len);
 	}
 
 
-#if (LINUX_VERSION_CODE >=  KERNEL_VERSION(2, 6, 38))         
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 		mutex_lock(&bcm_static_skb->osl_pkt_sem);
 #else 
 	down(&bcm_static_skb->osl_pkt_sem);
@@ -338,7 +345,7 @@ osl_pktget_static(osl_t *osh, uint len)
 		if (i != MAX_STATIC_PKT_NUM)
 		{
 			bcm_static_skb->pkt_use[i] = 1;
-#if (LINUX_VERSION_CODE >=  KERNEL_VERSION(2, 6, 38))         
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 		mutex_unlock(&bcm_static_skb->osl_pkt_sem);
 #else 
 			up(&bcm_static_skb->osl_pkt_sem);
@@ -362,20 +369,19 @@ osl_pktget_static(osl_t *osh, uint len)
 	if (i != MAX_STATIC_PKT_NUM)
 	{
 		bcm_static_skb->pkt_use[i+MAX_STATIC_PKT_NUM] = 1;
-#if (LINUX_VERSION_CODE >=  KERNEL_VERSION(2, 6, 38))         
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 		mutex_unlock(&bcm_static_skb->osl_pkt_sem);
 #else 
 		up(&bcm_static_skb->osl_pkt_sem);
 #endif
-		skb = bcm_static_skb->skb_12k[i];
+		skb = bcm_static_skb->skb_8k[i];
 		skb->tail = skb->data + len;
 		skb->len = len;
 
 		return skb;
 	}
 
-
-#if (LINUX_VERSION_CODE >=  KERNEL_VERSION(2, 6, 38))         
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 		mutex_unlock(&bcm_static_skb->osl_pkt_sem);
 #else 
 	up(&bcm_static_skb->osl_pkt_sem);
@@ -394,13 +400,15 @@ osl_pktfree_static(osl_t *osh, void *p, bool send)
 	{
 		if (p == bcm_static_skb->skb_4k[i])
 		{
-#if (LINUX_VERSION_CODE >=  KERNEL_VERSION(2, 6, 38))         
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 		mutex_lock(&bcm_static_skb->osl_pkt_sem);
-			bcm_static_skb->pkt_use[i] = 0;
-		mutex_unlock(&bcm_static_skb->osl_pkt_sem);
 #else 
 			down(&bcm_static_skb->osl_pkt_sem);
+#endif
 			bcm_static_skb->pkt_use[i] = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+			mutex_unlock(&bcm_static_skb->osl_pkt_sem);
+#else
 			up(&bcm_static_skb->osl_pkt_sem);
 #endif
 
@@ -504,7 +512,7 @@ osl_malloc(osl_t *osh, uint size)
 		int i = 0;
 		if ((size >= PAGE_SIZE)&&(size <= STATIC_BUF_SIZE))
 		{
-#if (LINUX_VERSION_CODE >=  KERNEL_VERSION(2, 6, 38))         
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 		mutex_lock(&bcm_static_buf->static_sem);
 #else 
 			down(&bcm_static_buf->static_sem);
@@ -518,7 +526,7 @@ osl_malloc(osl_t *osh, uint size)
 
 			if (i == MAX_STATIC_BUF_NUM)
 			{
-#if (LINUX_VERSION_CODE >=  KERNEL_VERSION(2, 6, 38))         
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 		mutex_unlock(&bcm_static_buf->static_sem);
 #else 
 				up(&bcm_static_buf->static_sem);
@@ -528,7 +536,7 @@ osl_malloc(osl_t *osh, uint size)
 			}
 
 			bcm_static_buf->buf_use[i] = 1;
-#if (LINUX_VERSION_CODE >=  KERNEL_VERSION(2, 6, 38))         
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 		mutex_unlock(&bcm_static_buf->static_sem);
 #else 
 			up(&bcm_static_buf->static_sem);
@@ -568,13 +576,15 @@ osl_mfree(osl_t *osh, void *addr, uint size)
 
 			buf_idx = ((unsigned char *)addr - bcm_static_buf->buf_ptr)/STATIC_BUF_SIZE;
 
-#if (LINUX_VERSION_CODE >=  KERNEL_VERSION(2, 6, 38))         
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 		mutex_lock(&bcm_static_buf->static_sem);
-			bcm_static_buf->buf_use[buf_idx] = 0;
-			mutex_unlock(&bcm_static_buf->static_sem);
 #else 
 			down(&bcm_static_buf->static_sem);
+#endif
 			bcm_static_buf->buf_use[buf_idx] = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+			mutex_unlock(&bcm_static_buf->static_sem);
+#else
 			up(&bcm_static_buf->static_sem);
 #endif
 
diff --git a/drivers/net/wireless/bcm43291/src/shared/miniopt.c b/drivers/net/wireless/bcm43291/src/shared/miniopt.c
index 2deb78a..6a184a7 100644
--- a/drivers/net/wireless/bcm43291/src/shared/miniopt.c
+++ b/drivers/net/wireless/bcm43291/src/shared/miniopt.c
@@ -20,7 +20,7 @@
  *      Notwithstanding the above, under no circumstances may you combine this
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
- * $Id: miniopt.c,v 1.1.6.3 2009/01/14 23:52:06 Exp $
+ * $Id: miniopt.c,v 1.1.6.4 2009/09/25 00:32:01 Exp $
  */
 
 /* ---- Include Files ---------------------------------------------------- */
@@ -62,7 +62,7 @@ int
 miniopt(miniopt_t *t, char **argv)
 {
 	int keylen;
-	char *p, *eq, *valstr, *endptr;
+	char *p, *eq, *valstr, *endptr = NULL;
 	int err = 0;
 
 	t->consumed = 0;
diff --git a/drivers/net/wireless/bcm43291/src/shared/sbutils.c b/drivers/net/wireless/bcm43291/src/shared/sbutils.c
index 4dae8ea..46cd510 100644
--- a/drivers/net/wireless/bcm43291/src/shared/sbutils.c
+++ b/drivers/net/wireless/bcm43291/src/shared/sbutils.c
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: sbutils.c,v 1.662.4.10.2.7.106.2 2010/03/29 03:21:13 Exp $
+ * $Id: sbutils.c,v 1.662.4.10.2.7.4.2 2010/04/19 05:48:48 Exp $
  */
 
 #include <typedefs.h>
@@ -44,9 +44,6 @@ static uint _sb_scan(si_info_t *sii, uint32 sba, void *regs, uint bus, uint32 sb
                      uint ncores);
 static uint32 _sb_coresba(si_info_t *sii);
 static void *_sb_setcoreidx(si_info_t *sii, uint coreidx);
-STATIC uint _sb_coreidx(si_info_t *sii, uint32 sba);
-STATIC uint32 _sb_coresba(si_info_t *sii);
-STATIC uint _sb_scan(si_info_t *sii, uint32 sba, void *regs, uint bus, uint32 sbba, uint numcores);
 
 #define	SET_SBREG(sii, r, mask, val)	\
 		W_SBREG((sii), (r), ((R_SBREG((sii), (r)) & ~(mask)) | (val)))
@@ -177,8 +174,8 @@ sb_setint(si_t *sih, int siflag)
 }
 
 /* return core index of the core with address 'sba' */
-STATIC uint
-BCMATTACHOVERLAYFN(1, _sb_coreidx)(si_info_t *sii, uint32 sba)
+static uint
+_sb_coreidx(si_info_t *sii, uint32 sba)
 {
 	uint i;
 
@@ -189,8 +186,8 @@ BCMATTACHOVERLAYFN(1, _sb_coreidx)(si_info_t *sii, uint32 sba)
 }
 
 /* return core address of the current core */
-STATIC uint32
-BCMATTACHOVERLAYFN(1, _sb_coresba)(si_info_t *sii)
+static uint32
+_sb_coresba(si_info_t *sii)
 {
 	uint32 sbaddr;
 
@@ -366,6 +363,9 @@ sb_corereg(si_t *sih, uint coreidx, uint regoff, uint mask, uint val)
 	ASSERT(regoff < SI_CORE_SIZE);
 	ASSERT((val & ~mask) == 0);
 
+	if (coreidx >= SI_MAXCORES)
+		return 0;
+
 	if (BUSTYPE(sii->pub.bustype) == SI_BUS) {
 		/* If internal bus, we can always get at everything */
 		fast = TRUE;
@@ -453,9 +453,8 @@ sb_corereg(si_t *sih, uint coreidx, uint regoff, uint mask, uint val)
  * starting from bus 'sbba', inclusive.
  */
 #define SB_MAXBUSES	2
-STATIC uint
-BCMATTACHOVERLAYFN(1, _sb_scan)(si_info_t *sii, uint32 sba, void *regs, uint bus,
-	uint32 sbba, uint numcores)
+static uint
+_sb_scan(si_info_t *sii, uint32 sba, void *regs, uint bus, uint32 sbba, uint numcores)
 {
 	uint next;
 	uint ncc = 0;
@@ -546,7 +545,7 @@ BCMATTACHOVERLAYFN(1, _sb_scan)(si_info_t *sii, uint32 sba, void *regs, uint bus
 
 /* scan the sb enumerated space to identify all cores */
 void
-BCMATTACHOVERLAYFN(1, sb_scan)(si_t *sih, void *regs, uint devid)
+sb_scan(si_t *sih, void *regs, uint devid)
 {
 	si_info_t *sii;
 	uint32 origsba;
@@ -595,18 +594,17 @@ sb_setcoreidx(si_t *sih, uint coreidx)
 static void *
 _sb_setcoreidx(si_info_t *sii, uint coreidx)
 {
-	si_common_info_t *ci = sii->common_info;
-	uint32 sbaddr = ci->coresba[coreidx];
+	uint32 sbaddr = sii->common_info->coresba[coreidx];
 	void *regs;
 
 	switch (BUSTYPE(sii->pub.bustype)) {
 	case SI_BUS:
 		/* map new one */
-		if (!ci->regs[coreidx]) {
-			ci->regs[coreidx] = REG_MAP(sbaddr, SI_CORE_SIZE);
-			ASSERT(GOODREGS(ci->regs[coreidx]));
+		if (!sii->common_info->regs[coreidx]) {
+			sii->common_info->regs[coreidx] = REG_MAP(sbaddr, SI_CORE_SIZE);
+			ASSERT(GOODREGS(sii->common_info->regs[coreidx]));
 		}
-		regs = ci->regs[coreidx];
+		regs = sii->common_info->regs[coreidx];
 		break;
 
 	case PCI_BUS:
@@ -628,11 +626,11 @@ _sb_setcoreidx(si_info_t *sii, uint coreidx)
 	case SPI_BUS:
 	case SDIO_BUS:
 		/* map new one */
-		if (!ci->regs[coreidx]) {
-			ci->regs[coreidx] = (void *)(uintptr)sbaddr;
-			ASSERT(GOODREGS(ci->regs[coreidx]));
+		if (!sii->common_info->regs[coreidx]) {
+			sii->common_info->regs[coreidx] = (void *)(uintptr)sbaddr;
+			ASSERT(GOODREGS(sii->common_info->regs[coreidx]));
 		}
-		regs = ci->regs[coreidx];
+		regs = sii->common_info->regs[coreidx];
 		break;
 
 
diff --git a/drivers/net/wireless/bcm43291/src/shared/siutils.c b/drivers/net/wireless/bcm43291/src/shared/siutils.c
index 5a9fdf7..1814db0 100644
--- a/drivers/net/wireless/bcm43291/src/shared/siutils.c
+++ b/drivers/net/wireless/bcm43291/src/shared/siutils.c
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: siutils.c,v 1.662.4.4.4.16.4.19.20.7.2.4 2010/09/08 00:18:43 Exp $
+ * $Id: siutils.c,v 1.662.4.4.4.16.4.28 2010/06/23 21:37:54 Exp $
  */
 
 #include <typedefs.h>
@@ -52,7 +52,6 @@ static si_info_t *si_doattach(si_info_t *sii, uint devid, osl_t *osh, void *regs
 static bool si_buscore_prep(si_info_t *sii, uint bustype, uint devid, void *sdh);
 static bool si_buscore_setup(si_info_t *sii, chipcregs_t *cc, uint bustype, uint32 savewin,
 	uint *origidx, void *regs);
-STATIC bool si_buscore_prep(si_info_t *sii, uint bustype, uint devid, void *sdh);
 
 
 /* global variable to indicate reservation/release of gpio's */
@@ -71,7 +70,7 @@ static void *common_info_alloced = NULL;
  * varsz - pointer to int to return the size of the vars
  */
 si_t *
-BCMATTACHOVERLAYFN(1, si_attach)(uint devid, osl_t *osh, void *regs,
+si_attach(uint devid, osl_t *osh, void *regs,
                        uint bustype, void *sdh, char **vars, uint *varsz)
 {
 	si_info_t *sii;
@@ -101,7 +100,7 @@ static uint32	wd_msticks;		/* watchdog timer ticks normalized to ms */
 
 /* generic kernel variant of si_attach() */
 si_t *
-BCMATTACHOVERLAYFN(1, si_kattach)(osl_t *osh)
+si_kattach(osl_t *osh)
 {
 	static bool ksii_attached = FALSE;
 
@@ -137,8 +136,8 @@ BCMATTACHOVERLAYFN(1, si_kattach)(osl_t *osh)
 }
 
 
-STATIC bool
-BCMATTACHOVERLAYFN(1, si_buscore_prep)(si_info_t *sii, uint bustype, uint devid, void *sdh)
+static bool
+si_buscore_prep(si_info_t *sii, uint bustype, uint devid, void *sdh)
 {
 	/* need to set memseg flag for CF card first before any sb registers access */
 	if (BUSTYPE(bustype) == PCMCIA_BUS)
@@ -182,8 +181,8 @@ BCMATTACHOVERLAYFN(1, si_buscore_prep)(si_info_t *sii, uint bustype, uint devid,
 }
 
 static bool
-BCMATTACHOVERLAYFN(1, si_buscore_setup)(si_info_t *sii, chipcregs_t *cc,
-	uint bustype, uint32 savewin, uint *origidx, void *regs)
+si_buscore_setup(si_info_t *sii, chipcregs_t *cc, uint bustype, uint32 savewin,
+	uint *origidx, void *regs)
 {
 	bool pci, pcie;
 	uint i;
@@ -361,10 +360,8 @@ si_doattach(si_info_t *sii, uint devid, osl_t *osh, void *regs,
 	sih->chip = w & CID_ID_MASK;
 	sih->chiprev = (w & CID_REV_MASK) >> CID_REV_SHIFT;
 	sih->chippkg = (w & CID_PKG_MASK) >> CID_PKG_SHIFT;
-	if ((CHIPID(sih->chip) == BCM4329_CHIP_ID) && (sih->chiprev == 0) &&
-		(sih->chippkg != BCM4329_289PIN_PKG_ID)) {
+	if ((CHIPID(sih->chip) == BCM4329_CHIP_ID) && (sih->chippkg != BCM4329_289PIN_PKG_ID))
 		sih->chippkg = BCM4329_182PIN_PKG_ID;
-	}
 	sih->issim = IS_SIM(sih->chippkg);
 
 	/* scan for cores */
@@ -509,7 +506,7 @@ si_intflag(si_t *sih)
 }
 
 uint
-BCMINITOVERLAYFN(1, si_flag)(si_t *sih)
+si_flag(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_flag(sih);
@@ -692,8 +689,7 @@ si_setcoreidx(si_t *sih, uint coreidx)
 }
 
 /* Turn off interrupt as required by sb_setcore, before switch core */
-void*
-si_switch_core(si_t *sih, uint coreid, uint *origidx, uint *intr_val)
+void *si_switch_core(si_t *sih, uint coreid, uint *origidx, uint *intr_val)
 {
 	void *cc;
 	si_info_t *sii;
@@ -709,8 +705,7 @@ si_switch_core(si_t *sih, uint coreid, uint *origidx, uint *intr_val)
 }
 
 /* restore coreidx and restore interrupt */
-void
-si_restore_core(si_t *sih, uint coreid, uint intr_val)
+void si_restore_core(si_t *sih, uint coreid, uint intr_val)
 {
 	si_info_t *sii;
 
diff --git a/drivers/net/wireless/bcm43291/src/shared/siutils_priv.h b/drivers/net/wireless/bcm43291/src/shared/siutils_priv.h
index a9c9ed2..e8ad7e5 100644
--- a/drivers/net/wireless/bcm43291/src/shared/siutils_priv.h
+++ b/drivers/net/wireless/bcm43291/src/shared/siutils_priv.h
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: siutils_priv.h,v 1.3.10.5.106.1 2009/09/22 13:48:06 Exp $
+ * $Id: siutils_priv.h,v 1.3.10.5.4.2 2009/09/22 13:28:16 Exp $
  */
 
 #ifndef	_siutils_priv_h_
diff --git a/drivers/net/wireless/bcm43291/src/wl/sys/wl_iw.c b/drivers/net/wireless/bcm43291/src/wl/sys/wl_iw.c
index b001298..6ac43e0 100644
--- a/drivers/net/wireless/bcm43291/src/wl/sys/wl_iw.c
+++ b/drivers/net/wireless/bcm43291/src/wl/sys/wl_iw.c
@@ -21,9 +21,10 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: wl_iw.c,v 1.51.4.9.2.6.4.36.2.29.2.1 2010/05/04 01:52:50 Exp $
+ * $Id: wl_iw.c,v 1.51.4.9.2.6.4.142.4.70 2011/01/14 22:25:05 Exp $
  */
 
+#include <wlioctl.h>
 
 #include <typedefs.h>
 #include <linuxver.h>
@@ -36,12 +37,8 @@
 #include <linux/if_arp.h>
 #include <asm/uaccess.h>
 
-#ifndef BCMDONGLEHOST
-#include <wlc_cfg.h>
-#else
 #include <dngl_stats.h>
 #include <dhd.h>
-#endif
 #include <dhdioctl.h>
 
 typedef void wlc_info_t;
@@ -49,26 +46,41 @@ typedef void wl_info_t;
 typedef const struct si_pub  si_t;
 #include <wlioctl.h>
 
-#ifndef BCMDONGLEHOST
-#include <wlc_pub.h>
-#include <wl_dbg.h>
-#else
+//sangjun.bae 2012
+#include <linux/sched.h>
+
 #include <proto/ethernet.h>
 #include <dngl_stats.h>
 #include <dhd.h>
-#define WL_ERROR(x)	printk x // LGE
+#define WL_ERROR(x) printf x
 #define WL_TRACE(x)
 #define WL_ASSOC(x)
 #define WL_INFORM(x)
 #define WL_WSEC(x)
+#define WL_SCAN(x)
+
+
+#define JF2MS ((((jiffies / HZ) * 1000) + ((jiffies % HZ) * 1000) / HZ))
+
+#ifdef COEX_DBG       
+#define WL_TRACE_COEX(x) printf("TS:%lu ", JF2MS); \
+							printf x
+#else
+#define WL_TRACE_COEX(x)
+#endif
+
+#ifdef SCAN_DBG        
+#define WL_TRACE_SCAN(x) printf("TS:%lu ", JF2MS); \
+							printf x
+#else
+#define WL_TRACE_SCAN(x)
 #endif
-#define LGE_ROAM_PARAMETER
+
 
 #include <wl_iw.h>
 
-// louislee : added for WPS {
-#ifdef BCMWAPI_WPI
-/* these items should evetually go into wireless.h of the linux system headfile dir */
+
+
 #ifndef IW_ENCODE_ALG_SM4
 #define IW_ENCODE_ALG_SM4 0x20
 #endif
@@ -92,89 +104,63 @@ typedef const struct si_pub  si_t;
 #ifndef IW_AUTH_KEY_MGMT_WAPI_CERT
 #define IW_AUTH_KEY_MGMT_WAPI_CERT 8
 #endif
-#endif /* BCMWAPI_WPI */
 
-/* XXX because for dhd we don't include bcmwpa.h, define this here */
-/* XXX this does not look at CCX ciphers, e.g. CKIP_*...if this is relevant in this file,
- * please add the definitions here
- */
 
-#ifdef BCMWAPI_WPI
 #define IW_WSEC_ENABLED(wsec)	((wsec) & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED | SMS4_ENABLED))
-#else /* BCMWAPI_WPI */
-#define IW_WSEC_ENABLED(wsec)	((wsec) & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED))
-#endif /* BCMWAPI_WPI */
-// louislee : added for WPS }
 
 #include <linux/rtnetlink.h>
 
-#if defined(BCMDONGLEHOST)
-#ifdef  CUSTOMER_HW2
-//#define WL_IW_USE_ISCAN
-#define WL_IW_USE_ESCAN // louislee : modified for TI
-#else
-#define WL_IW_USE_ESCAN
-#endif
+#define WL_IW_USE_ISCAN  1
 #define ENABLE_ACTIVE_PASSIVE_SCAN_SUPPRESS  1
-#endif 
-
-#if defined(SOFTAP)
-inline static void MUTEX_LOCK_SOFTAP_SET_INIT(dhd_pub_t * dhdp)
-{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
-        mutex_init(&dhdp->wl_softap_lock);
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
-}
 
-inline static void MUTEX_LOCK_SOFTAP_SET(dhd_pub_t * dhdp)
-{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
-        mutex_lock(&dhdp->wl_softap_lock);
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
-}
 
-inline static void MUTEX_UNLOCK_SOFTAP_SET(dhd_pub_t * dhdp)
-{
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
-        mutex_unlock(&dhdp->wl_softap_lock);
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
-}
+	struct mutex  g_wl_ss_scan_lock; 
+#endif 
 
-#define WL_SOFTAP(x) printk x
+#if defined(SOFTAP)
+#define WL_SOFTAP(x)
 static struct net_device *priv_dev;
 static bool 	ap_cfg_running = FALSE;
+#if defined(CONFIG_LGE_BCM432X_PATCH)		//by sjpark 11-02-01
+bool            ap_fw_loaded = FALSE;
+#else
 static bool 	ap_fw_loaded = FALSE;
+#endif
+//static long ap_cfg_pid = -1;
 struct net_device *ap_net_dev = NULL;
-struct semaphore  ap_eth_sema;
+//struct semaphore  ap_eth_sema;
+//static struct completion ap_cfg_exited;
+tsk_ctl_t       ap_eth_ctl;
 static int wl_iw_set_ap_security(struct net_device *dev, struct ap_profile *ap);
-static int wl_iw_softap_deassoc_stations(struct net_device *dev);
-#endif /* SOFTAP */
+static int wl_iw_softap_deassoc_stations(struct net_device *dev, u8 *mac);
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//20110121
+bool ap_priv_running = FALSE;
+#endif
+#endif 
 
-static int wl_keep_alive_set(struct net_device *dev, char* extra);
 #define WL_IW_IOCTL_CALL(func_call) \
 	do {				\
 		func_call;		\
 	} while (0)
 
 static int		g_onoff = G_WLAN_SET_ON;
+wl_iw_extra_params_t	 g_wl_iw_params;
 
-#if defined(STA) || defined(BCMDONGLEHOST)
 extern bool wl_iw_conn_status_str(uint32 event_type, uint32 status,
 	uint32 reason, char* stringBuf, uint buflen);
 #include <bcmsdbus.h>
 extern void dhd_customer_gpio_wlan_ctrl(int onoff);
 extern uint dhd_dev_reset(struct net_device *dev, uint8 flag);
 extern void dhd_dev_init_ioctl(struct net_device *dev);
-#endif 
+int dev_iw_write_cfg1_bss_var(struct net_device *dev, int val);
 
-#ifdef BCMDONGLEHOST
 uint wl_msg_level = WL_ERROR_VAL;
-#endif
 
 #define MAX_WLIW_IOCTL_LEN 1024
 
 
-#if defined(BCMDONGLEHOST) && defined(IL_BIGENDIAN)
+#if defined(IL_BIGENDIAN)
 #include <bcmendian.h>
 #define htod32(i) (bcmswap32(i))
 #define htod16(i) (bcmswap16(i))
@@ -193,12 +179,8 @@ uint wl_msg_level = WL_ERROR_VAL;
 
 #ifdef CONFIG_WIRELESS_EXT
 
-#if defined(BCMDONGLEHOST)
 extern struct iw_statistics *dhd_get_wireless_stats(struct net_device *dev);
 extern int dhd_wait_pend8021x(struct net_device *dev);
-#else
-extern struct iw_statistics *wl_get_wireless_stats(struct net_device *dev);
-#endif 
 #endif 
 
 #if WIRELESS_EXT < 19
@@ -207,24 +189,18 @@ extern struct iw_statistics *wl_get_wireless_stats(struct net_device *dev);
 #endif 
 
 static void *g_scan = NULL;
-static uint g_scan_specified_ssid;
-
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-08-16, Fix the getting ISCAN/SCAN results */
-#if defined(CONFIG_LGE_BCM432X_PATCH) && defined(WL_IW_USE_ISCAN)
-static uint g_completed_scan_type = 0; /* 0: ISCAN, 1: SCAN */
-#endif /* CONFIG_LGE_BCM432X_PATCH */
-/* LGE_CHANGE_E [yoohoo@lge.com] 2009-08-16, Fix the getting ISCAN/SCAN results */
-
-#if !defined(CONFIG_BRCM_USE_DEEPSLEEP)
-/* Do not use GPIO Reset at On/Off. Use mpc. */
-//#define CONFIG_BRCM_USE_GPIO_RESET
-#endif	/* !defined(CONFIG_BRCM_USE_DEEPSLEEP) */
+static volatile uint g_scan_specified_ssid;	
+static wlc_ssid_t g_specific_ssid;		
 
 static wlc_ssid_t g_ssid;
 
-wl_iw_ss_cache_ctrl_t g_ss_cache_ctrl;	
+static wl_iw_ss_cache_ctrl_t g_ss_cache_ctrl;	
+#if defined(CONFIG_FIRST_SCAN)
+static volatile uint g_first_broadcast_scan;	
+static volatile uint g_first_counter_scans; 
+#define MAX_ALLOWED_BLOCK_SCAN_FROM_FIRST_SCAN 3
+#endif 
 
-#if defined(BCMDONGLEHOST)
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
 #define DAEMONIZE(a) daemonize(a); \
@@ -240,7 +216,14 @@ wl_iw_ss_cache_ctrl_t g_ss_cache_ctrl;
 #endif 
 
 #if defined(WL_IW_USE_ISCAN)
-
+#if  !defined(CSCAN)
+static void wl_iw_free_ss_cache(void);
+static int   wl_iw_run_ss_cache_timer(int kick_off);
+#endif 
+#if defined(CONFIG_FIRST_SCAN)
+int  wl_iw_iscan_set_scan_broadcast_prep(struct net_device *dev, uint flag);
+#endif 
+static int dev_wlc_bufvar_set(struct net_device *dev, char *name, char *buf, int len);
 #define ISCAN_STATE_IDLE   0
 #define ISCAN_STATE_SCANING 1
 
@@ -260,48 +243,44 @@ typedef struct iscan_info {
 	iscan_buf_t * list_hdr;
 	iscan_buf_t * list_cur;
 
-	
+#if 0	
 	long sysioc_pid;
 	struct semaphore sysioc_sem;
 	struct completion sysioc_exited;
-
+#else
+	tsk_ctl_t tsk_ctl;
+#endif
 	uint32 scan_flag;	
-
+#if defined CSCAN
+	char ioctlbuf[WLC_IOCTL_MEDLEN];
+#else
 	char ioctlbuf[WLC_IOCTL_SMLEN];
-} iscan_info_t;
-iscan_info_t *g_iscan = NULL;
-static void wl_iw_timerfunc(ulong data);
-static int
-wl_iw_iscan(iscan_info_t *iscan, wlc_ssid_t *ssid, uint16 action);
 #endif 
 
-#if defined(WL_IW_USE_ESCAN)
+	wl_iscan_params_t *iscan_ex_params_p;
+	int iscan_ex_param_size;
+} iscan_info_t;
 
-#define ESCAN_STATE_IDLE   0
-#define ESCAN_STATE_SCANING 1
-#define ESCAN_BUF_SIZE (64 * 1024)
-#ifdef CONFIG_LGE_BCM432X_PATCH // escan buf to array
-char escan_array[ESCAN_BUF_SIZE]={0,};
-#endif /* CONFIG_LGE_BCM432X_PATCH escan buf to array */
-typedef struct escan_info {
-	struct net_device *dev;
-	int escan_state;
-#ifdef CONFIG_LGE_BCM432X_PATCH // escan buf to array
-	char *escan_buf;
-#else
-	char escan_buf[ESCAN_BUF_SIZE];
-#endif /* CONFIG_LGE_BCM432X_PATCH escan buf to array */
 
-	uint32 scan_flag;	
 
-	char ioctlbuf[WLC_IOCTL_SMLEN];
-} escan_info_t;
-escan_info_t *g_escan = NULL;
-static int wl_iw_escan(escan_info_t *escan, wlc_ssid_t *ssid, uint16 action);
+#define  COEX_DHCP 1	
+
+#define BT_DHCP_eSCO_FIX 
+#define BT_DHCP_USE_FLAGS  
+#define BT_DHCP_OPPORTUNITY_WINDOW_TIME	 2500 
+#define BT_DHCP_FLAG_FORCE_TIME 5500 
+
+
+
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+static int wl_iw_set_btcoex_dhcp(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+);
 #endif 
 
-#define  COEX_DHCP 1 
-#ifdef COEX_DHCP
 static void wl_iw_bt_flag_set(struct net_device *dev, bool set);
 static void wl_iw_bt_release(void);
 
@@ -311,27 +290,39 @@ typedef enum bt_coex_status {
 	BT_DHCP_OPPORTUNITY_WINDOW,
 	BT_DHCP_FLAG_FORCE_TIMEOUT
 } coex_status_t;
-#define BT_DHCP_OPPORTUNITY_WINDOW_TIEM	2500	
-#define BT_DHCP_FLAG_FORCE_TIME				5500 	
+
 
 typedef struct bt_info {
 	struct net_device *dev;
 	struct timer_list timer;
 	uint32 timer_ms;
 	uint32 timer_on;
+	uint32 ts_dhcp_start; 
+	uint32 ts_dhcp_ok;    
+	bool	dhcp_done; 
 	int	bt_state;
 
-	
+#if 0	
 	long bt_pid;
 	struct semaphore bt_sem;
 	struct completion bt_exited;
+#else
+	tsk_ctl_t tsk_ctl;	
+#endif
 } bt_info_t;
 
 bt_info_t *g_bt = NULL;
 static void wl_iw_bt_timerfunc(ulong data);
-#endif 
+
+
+iscan_info_t *g_iscan = NULL;
+static void wl_iw_timerfunc(ulong data);
 static void wl_iw_set_event_mask(struct net_device *dev);
+static int
+wl_iw_iscan(iscan_info_t *iscan, wlc_ssid_t *ssid, uint16 action);
 #endif 
+
+
 static int
 wl_iw_set_scan(
 	struct net_device *dev,
@@ -339,6 +330,7 @@ wl_iw_set_scan(
 	union iwreq_data *wrqu,
 	char *extra
 );
+#ifndef CSCAN
 static int
 wl_iw_get_scan(
 	struct net_device *dev,
@@ -354,6 +346,7 @@ wl_iw_get_scan_prep(
 	char *extra,
 	short max_size
 );
+#endif 
 
 static void swap_key_from_BE(
 	        wl_wsec_key_t *key
@@ -392,15 +385,17 @@ dev_wlc_ioctl(
 	struct ifreq ifr;
 	wl_ioctl_t ioc;
 	mm_segment_t fs;
-	int ret = -1;
+	int ret = -EINVAL;
 
 	if (!dev) {
 		WL_ERROR(("%s: dev is null\n", __FUNCTION__));
 		return ret;
 	}
 
-	WL_TRACE(("\n%s, PID:%x: send Local IOCTL -> dhd: cmd:0x%x, buf:%p, len:%d ,\n",
+	WL_INFORM(("\n%s, PID:%x: send Local IOCTL -> dhd: cmd:0x%x, buf:%p, len:%d ,\n",
 		__FUNCTION__, current->pid, cmd, arg, len));
+
+	if (g_onoff == G_WLAN_SET_ON) {
 	memset(&ioc, 0, sizeof(ioc));
 	ioc.cmd = cmd;
 	ioc.buf = arg;
@@ -410,7 +405,11 @@ dev_wlc_ioctl(
 	ifr.ifr_data = (caddr_t) &ioc;
 
 	
-	dev_open(dev);
+		ret = dev_open(dev);
+		if (ret) {
+			WL_ERROR(("%s: Error dev_open: %d\n", __func__, ret));
+			return ret;
+		}
 
 	fs = get_fs();
 	set_fs(get_ds());
@@ -420,12 +419,13 @@ dev_wlc_ioctl(
 	ret = dev->netdev_ops->ndo_do_ioctl(dev, &ifr, SIOCDEVPRIVATE);
 #endif
 	set_fs(fs);
-
+	}
+	else {
+		WL_TRACE(("%s: call after driver stop : ignored\n", __FUNCTION__));
+	}
 	return ret;
 }
 
-
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
 static int
 dev_wlc_intvar_get_reg(
 	struct net_device *dev,
@@ -447,9 +447,24 @@ dev_wlc_intvar_get_reg(
 	*retval = dtoh32(var.val);
 	return (error);
 }
-#endif	/* !defined(CONFIG_LGE_BCM432X_PATCH) */
 
 
+static int
+dev_wlc_intvar_set_reg(
+	struct net_device *dev,
+	char *name,
+	char *addr,
+	char * val)
+{
+	char reg_addr[8];
+
+	memset(reg_addr, 0, sizeof(reg_addr));
+	memcpy((char *)&reg_addr[0], (char *)addr, 4);
+	memcpy((char *)&reg_addr[4], (char *)val, 4);
+
+	return (dev_wlc_bufvar_set(dev, name,  (char *)&reg_addr[0], sizeof(reg_addr)));
+}
+
 
 
 static int
@@ -468,7 +483,8 @@ dev_wlc_intvar_set(
 	return (dev_wlc_ioctl(dev, WLC_SET_VAR, buf, len));
 }
 
-#if defined(BCMDONGLEHOST) && (defined(WL_IW_USE_ISCAN) || defined(WL_IW_USE_ESCAN))
+
+#if defined(WL_IW_USE_ISCAN)
 static int
 dev_iw_iovar_setbuf(
 	struct net_device *dev,
@@ -483,12 +499,12 @@ dev_iw_iovar_setbuf(
 	iolen = bcm_mkiovar(iovar, param, paramlen, bufptr, buflen);
 	ASSERT(iolen);
 
+	if (iolen == 0)
+		return 0;
+
 	return (dev_wlc_ioctl(dev, WLC_SET_VAR, bufptr, iolen));
 }
 
-#endif 
-
-#if defined(WL_IW_USE_ISCAN) || defined(WL_IW_USE_ESCAN)
 static int
 dev_iw_iovar_getbuf(
 	struct net_device *dev,
@@ -514,7 +530,11 @@ dev_wlc_bufvar_set(
 	char *name,
 	char *buf, int len)
 {
-	char ioctlbuf[WLC_IOCTL_SMLEN];
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
+	char ioctlbuf[MAX_WLIW_IOCTL_LEN];
+#else
+	static char ioctlbuf[MAX_WLIW_IOCTL_LEN];
+#endif 
 	uint buflen;
 
 	buflen = bcm_mkiovar(name, buf, len, ioctlbuf, sizeof(ioctlbuf));
@@ -531,9 +551,12 @@ dev_wlc_bufvar_get(
 	char *name,
 	char *buf, int buflen)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
 	char ioctlbuf[MAX_WLIW_IOCTL_LEN];
+#else
+	static char ioctlbuf[MAX_WLIW_IOCTL_LEN];
+#endif 
 	int error;
-
 	uint len;
 
 	len = bcm_mkiovar(name, NULL, 0, ioctlbuf, sizeof(ioctlbuf));
@@ -587,8 +610,6 @@ wl_iw_set_active_scan(
 
 #if defined(WL_IW_USE_ISCAN)
 	if (g_iscan->iscan_state == ISCAN_STATE_IDLE)
-#elif defined(WL_IW_USE_ESCAN)
-	if (g_escan->escan_state == ESCAN_STATE_IDLE)
 #endif 
 		error = dev_wlc_ioctl(dev, WLC_SET_PASSIVE_SCAN, &as, sizeof(as));
 #if defined(WL_IW_USE_ISCAN)
@@ -598,9 +619,6 @@ wl_iw_set_active_scan(
 #endif /* CONFIG_LGE_BCM432X_PATCH */
 /* LGE_CHANGE_E [yoohoo@lge.com] 2009-04-15, fixed passive/active scan */
 		g_iscan->scan_flag = as;
-#elif defined(WL_IW_USE_ESCAN)
-	else
-		g_escan->scan_flag = as;
 #endif 
 	p += snprintf(p, MAX_WX_STRING, "OK");
 
@@ -622,8 +640,6 @@ wl_iw_set_passive_scan(
 
 #if defined(WL_IW_USE_ISCAN)
 	if (g_iscan->iscan_state == ISCAN_STATE_IDLE) {
-#elif defined(WL_IW_USE_ESCAN)
-	if (g_escan->escan_state == ESCAN_STATE_IDLE) {
 #endif 
 
 		 
@@ -638,10 +654,6 @@ wl_iw_set_passive_scan(
 #endif /* CONFIG_LGE_BCM432X_PATCH */
 /* LGE_CHANGE_E [yoohoo@lge.com] 2009-04-15, fixed passive/active scan */
 		g_iscan->scan_flag = ps;
-#elif defined(WL_IW_USE_ESCAN)
-	}
-	else
-		g_escan->scan_flag = ps;
 #endif 
 
 	p += snprintf(p, MAX_WX_STRING, "OK");
@@ -675,189 +687,64 @@ wl_iw_get_macaddr(
 	return error;
 }
 
-/*
-static int
-wl_iw_set_scan_unassoc_time_ms(
-	struct net_device *dev,
-	struct iw_request_info *info,
-	union iwreq_data *wrqu,
-	char *extra
-)
-{
-    int timems = 0;
-    int ret = 0;
-	char *p = extra;
-
-    ASSERT( dev && wrqu );
-
-
-	if (sscanf(extra, "%*s %d", &timems) != 1)
-		return -EINVAL;
-	
-	
-    if( timems < 0 ) 
-    {
-		printk(KERN_ERR "%s: time value is out of range. value[%d]\n",\
-                __FUNCTION__, timems);
-        return -1;
-    }
-
-	if( ( ret = dev_wlc_ioctl(dev, WLC_SET_SCAN_UNASSOC_TIME, &timems, sizeof(timems)) ) < 0 )
-    {
-		printk(KERN_ERR "%s: set failed. value[%d], ret[%d]\n",\
-                __FUNCTION__, timems, ret);
-    }
-
-	p += snprintf(p, MAX_WX_STRING, ret < 0 ? "FAIL\n" : "OK\n");
-	wrqu->data.length = p - extra + 1;
+#if defined(CONFIG_BRCM_LGE_WL_ARPOFFLOAD)
 		
+//by sjpark 10-12-15	[
+uint wl_dtim_val = 0;		//by sjpark 100824
+// 20110210 mingi.sung@lge.com DLNA settings [START]
+uint dnla_dtim_val = 0;
+// 20110210 mingi.sung@lge.com DLNA settings [END]
+int wl_iw_set_dtim_val(struct net_device *dev)	//hyeok	: 100824
+{
+	int ret, cal_dtim;
+	struct ether_addr bssid;
+	wl_bss_info_t *bi;
+	char buf[WLC_IOCTL_SMLEN]  = {0};
+	
+	if ((ret = dev_wlc_ioctl(dev, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN)) == 0) {
+		/* The adapter is associated. */
+		*(uint32*)buf = htod32(WLC_IOCTL_SMLEN);
+		if ((ret = dev_wlc_ioctl(dev, WLC_GET_BSS_INFO, buf, sizeof(buf))) < 0)
     return ret;
-}
-*/
-
-/*
-static int
-wl_iw_set_scan_unassoc_time_30_ms(
-	struct net_device *dev,
-	struct iw_request_info *info,
-	union iwreq_data *wrqu,
-	char *extra
-)
-{
-    int timems = 30;
-    int ret = 0;
-	char *p = extra;
 
-    ASSERT( dev && wrqu );
-
-	if( ( ret = dev_wlc_ioctl(dev, WLC_SET_SCAN_UNASSOC_TIME, &timems, sizeof(timems)) ) < 0 )
+		bi = (wl_bss_info_t*)(buf + 4);
+// 20110210 mingi.sung@lge.com DLNA settings [START]
+//		if (dtoh32(bi->version) == WL_BSS_INFO_VERSION )
+		if (dtoh32(bi->version) == WL_BSS_INFO_VERSION && (!dnla_dtim_val) )
+// 20110210 mingi.sung@lge.com DLNA settings [END]
+		{
+			printk("[%s] beacon_period[%d], dtim_period[%d]\n",__FUNCTION__,bi->beacon_period,bi->dtim_period);
+			cal_dtim = (bi->beacon_period) * (bi->dtim_period);
+			if( cal_dtim <= 100)
     {
-		printk(KERN_ERR "%s: set failed. value[%d], ret[%d]\n",\
-                __FUNCTION__, timems, ret);
+				wl_dtim_val = 3;
+				printk("[%s]wl dtim val set : %d",__FUNCTION__, wl_dtim_val);
     }
-
-	p += snprintf(p, MAX_WX_STRING, ret < 0 ? "FAIL\n" : "OK\n");
-	wrqu->data.length = p - extra + 1;
-		
-    return ret;
-}
-
-
-static int
-wl_iw_set_scan_unassoc_time_80_ms(
-	struct net_device *dev,
-	struct iw_request_info *info,
-	union iwreq_data *wrqu,
-	char *extra
-)
-{
-    int timems = 80;
-    int ret = 0;
-	char *p = extra;
-
-    ASSERT( dev && wrqu );
-
-	if( ( ret = dev_wlc_ioctl(dev, WLC_SET_SCAN_UNASSOC_TIME, &timems, sizeof(timems)) ) < 0 )
+			else if( (100 < cal_dtim) && (cal_dtim <= 200))
     {
-		printk(KERN_ERR "%s: set failed. value[%d], ret[%d]\n",\
-                __FUNCTION__, timems, ret);
+				wl_dtim_val = 2;
+				printk("[%s]wl dtim val set : %d",__FUNCTION__, wl_dtim_val);
     }
-
-	p += snprintf(p, MAX_WX_STRING, ret < 0 ? "FAIL\n" : "OK\n");
-	wrqu->data.length = p - extra + 1;
-		
-    return ret;
-}
-*/
-
-
-/* BRCM_UPDATE_S for KEEP_ALIVE */
-static int wl_keep_alive_set(struct net_device *dev, char* extra)
-{
-	wl_keep_alive_pkt_t keep_alive_pkt;
-	wl_keep_alive_pkt_t *keep_alive_pktp;
-	int                     buf_len;
-	int                     str_len;
-	int ret = 0;
-	char buf[100]  = {0,};
-    uint period_msec = 0;
-
-    if( extra == NULL ) 
+			else
     {
-        WL_ERROR(( "%s: extra is NULL\n", __FUNCTION__ ));
-        return -1;
+				wl_dtim_val = 1;
+				printk("[%s]wl dtim val set : %d",__FUNCTION__, wl_dtim_val);
     }
-
-	if (sscanf(extra, "%*s %d", &period_msec) != 1)
-    {
-        WL_ERROR(( "%s: sscanf error. check period_msec value\n", __FUNCTION__ ));
-		return -EINVAL;
     }
-	
-    WL_TRACE(( "%s: period_msec is %d\n", __FUNCTION__, period_msec ));
-
-	memset(&keep_alive_pkt, 0, sizeof(wl_keep_alive_pkt_t));
-
-    strcpy( buf, "keep_alive" );
-    str_len = strlen( buf );
-    buf[ str_len ] = '\0';
-
-	keep_alive_pktp = (wl_keep_alive_pkt_t *) (buf + str_len + 1);
-	keep_alive_pkt.period_msec = htod32(period_msec);		
-	keep_alive_pkt.len_bytes = 0;
-
-	buf_len = str_len + 1;
-	buf_len += (WL_KEEP_ALIVE_FIXED_LEN + keep_alive_pkt.len_bytes);
-
-	memcpy(keep_alive_pktp, &keep_alive_pkt, WL_KEEP_ALIVE_FIXED_LEN);
-
-	if( (ret= dev_wlc_ioctl(dev, WLC_SET_VAR, buf, buf_len)) < 0)
-		WL_ERROR(("%s:keep_alive set failed. ret[%d]\n",__FUNCTION__, ret));
 	else
-		WL_TRACE(("%s:keep_alive set ok. ret[%d]\n",__FUNCTION__, ret));
-
-	return ret;
-}
-/* BRCM_UPDATE_E for KEEP_ALIVE */
-/* BRCM_UPDATE_S for PM2_SLEEP_RET */
-static int
-wl_iw_set_pm2_sleep_ret(
-	struct net_device *dev,
-	struct iw_request_info *info,
-	union iwreq_data *wrqu,
-	char *extra
-)
-{
-	uint msec = 200; // Default value
-	int error = 0;
-	char *p = extra;
-	char buf[100]  = {0};
-	int len = 0;
-
-
-	WL_ERROR(("%s: wl_iw_set_pm2_sleep_ret requst = %s\n",
-		dev->name, extra));
-
-	if (sscanf(extra, "%*s %d", &msec) != 1)
-	{
-		return -EINVAL;
+			printk("Sorry, your driver has bss_info_version %d "
+					"but this program supports only version %d.\n",
+				bi->version, WL_BSS_INFO_VERSION);
+	} else {
+		printk("Not associated. Last associated with ");
 	}
-//	WL_ERROR("%swl_iw_set_pm2_sleep_ret : extra %s",__FUNCTION__,extra);
-
-	len = bcm_mkiovar("pm2_sleep_ret", (char *)&msec, sizeof(msec), buf, sizeof(buf));
-	ASSERT(len);
 
-	if ((error = dev_wlc_ioctl(dev, WLC_SET_VAR, buf, len)) < 0)
-	{
-		WL_ERROR(("%s:pm2_sleep_ret set failed. msec[%d]:error[%d]\n",__FUNCTION__, msec, error));
-	}
+	return ret;
 	
-	p += snprintf(p, MAX_WX_STRING, error < 0 ? "FAIL\n" : "OK\n");
-	wrqu->data.length = p - extra + 1;
-	return error;
 }
-/* BRCM_UPDATE_E for PM2_SLEEP_RET */
-#if defined(CONFIG_BRCM_LGE_WL_HOSTWAKEUP) && defined(CONFIG_BRCM_LGE_WL_ARPOFFLOAD)
+//by sjpark 10-12-15	]
+
+#if 0
 static int
 wl_iw_set_hostip(
 	struct net_device *dev,
@@ -882,7 +769,7 @@ wl_iw_set_hostip(
 
 	ret = strict_strtol((extra+1+ip_offset), 0, &ipaddr_int);
 
-//	printk("%s: Received IP Address: " NIPQUAD_FMT "\n" ,__FUNCTION__, NIPQUAD(ipaddr_int));
+	printk("%s: Received IP Address: " NIPQUAD_FMT "\n" ,__FUNCTION__, NIPQUAD(ipaddr_int));
 
 	ipaddr[0] = ((unsigned char *)&ipaddr_int)[0];
 	ipaddr[1] = ((unsigned char *)&ipaddr_int)[1];
@@ -904,18 +791,15 @@ wl_iw_set_hostip(
 	if( (ret= dev_wlc_ioctl(dev, WLC_SET_VAR, buf, len)) < 0)
 		printk(KERN_ERR "%s:arp_hostip set failed. ret[%d]\n",__FUNCTION__, ret);
 		
-#if 0  // no more use.
-/* BRCM_UPDATE_S for KEEP_ALIVE */
-	wl_keep_alive_set(dev);
-/* BRCM_UPDATE_E for KEEP_ALIVE */
-#endif
+//	wl_iw_set_dtim_val(dev);	//by sjpark 10-12-15		
 
        p += snprintf(p, MAX_WX_STRING, "OK");
        wrqu->data.length = p - extra + 1;
 
     return 0;
 }
-#endif	/* defined(CONFIG_BRCM_LGE_WL_HOSTWAKEUP) && defined(CONFIG_BRCM_LGE_WL_ARPOFFLOAD) */
+#endif
+#endif	/* defined(CONFIG_BRCM_LGE_WL_ARPOFFLOAD) */
 
 static int
 wl_iw_set_country(
@@ -925,14 +809,17 @@ wl_iw_set_country(
 	char *extra
 )
 {
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
 	char country_code[WLC_CNTRY_BUF_SZ];
 	int error = 0;
 	char *p = extra;
 	int country_offset;
 	int country_code_size;
+	wl_country_t cspec = {{0}, 0, {0}};
+	char smbuf[WLC_IOCTL_SMLEN];
 
+	cspec.rev = -1;
 	memset(country_code, 0, sizeof(country_code));
+	memset(smbuf, 0, sizeof(smbuf));
 
 	
 	country_offset = strcspn(extra, " ");
@@ -944,28 +831,37 @@ wl_iw_set_country(
 			MIN(country_code_size, sizeof(country_code)));
 
 		
-		if ((error = dev_wlc_ioctl(dev, WLC_SET_COUNTRY,
-			&country_code, sizeof(country_code))) >= 0) {
+		memcpy(cspec.country_abbrev, country_code, WLC_CNTRY_BUF_SZ);
+		memcpy(cspec.ccode, country_code, WLC_CNTRY_BUF_SZ);
+
+		get_customized_country_code((char *)&cspec.country_abbrev, &cspec);
+
+		
+		if ((error = dev_iw_iovar_setbuf(dev, "country", &cspec, \
+				sizeof(cspec), smbuf, sizeof(smbuf))) >= 0) {
 			p += snprintf(p, MAX_WX_STRING, "OK");
-			WL_TRACE(("%s: set country %s OK\n", __FUNCTION__, country_code));
+				WL_TRACE(("%s: set country for %s as %s rev %d is OK\n", \
+					__FUNCTION__, country_code, cspec.ccode, cspec.rev));
+				dhd_bus_country_set(dev, &cspec);
 			goto exit;
 		}
 	}
 
-	WL_ERROR(("%s: set country %s failed code %d\n", __FUNCTION__, country_code, error));
+	WL_ERROR(("%s: set country for %s as %s rev %d failed\n", \
+			__FUNCTION__, country_code, cspec.ccode, cspec.rev));
+
 	p += snprintf(p, MAX_WX_STRING, "FAIL");
 
 exit:
 	wrqu->data.length = p - extra + 1;
 	return error;
-#else
-	return 0;
-#endif
 }
 
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
+
+
+#ifdef CUSTOMER_HW2
 static int
-wl_iw_set_btcoex_dhcp(
+wl_iw_set_power_mode(
 	struct net_device *dev,
 	struct iw_request_info *info,
 	union iwreq_data *wrqu,
@@ -974,92 +870,312 @@ wl_iw_set_btcoex_dhcp(
 {
 	int error = 0;
 	char *p = extra;
-	uint val;
-#ifdef  CUSTOMER_HW2
 	static int  pm = PM_FAST;
 	int  pm_local = PM_OFF;
-#endif
 	char powermode_val = 0;
-	char buf_reg66va_dhcp_on[8] = { 66, 00, 00, 00, 0x10, 0x27, 0x00, 0x00 };
-	char buf_reg41va_dhcp_on[8] = { 41, 00, 00, 00, 0x33, 0x00, 0x00, 0x00 };
-	char buf_reg68va_dhcp_on[8] = { 68, 00, 00, 00, 0x90, 0x01, 0x00, 0x00 };
 
-	char buf_reg66val_defualt[8] = { 66, 00, 00, 00, 0x88, 0x13, 0x00, 0x00 };
-	char buf_reg41val_defualt[8] = { 41, 00, 00, 00, 0x13, 0x00, 0x00, 0x00 };
-	char buf_reg68val_defualt[8] = { 68, 00, 00, 00, 0x14, 0x00, 0x00, 0x00 };
+	WL_TRACE_COEX(("%s: DHCP session cmd:%s\n", __FUNCTION__, extra));
 
-#ifdef COEX_DHCP
-	char buf_flag7_default[8] =   { 7, 00, 00, 00, 0x0, 0x00, 0x00, 0x00};
-#endif 
-
-	
 	strncpy((char *)&powermode_val, extra + strlen("POWERMODE") +1, 1);
 
+	if (strnicmp((char *)&powermode_val, "1", strlen("1")) == 0) {
+
+		dev_wlc_ioctl(dev, WLC_GET_PM, &pm, sizeof(pm));
+		dev_wlc_ioctl(dev, WLC_SET_PM, &pm_local, sizeof(pm_local));
+
+		
+		net_os_set_packet_filter(dev, 0);
+
+		g_bt->ts_dhcp_start = JF2MS;
+		g_bt->dhcp_done = false;
+		WL_TRACE_COEX(("%s: DHCP start, pm:%d changed to pm:%d\n",
+			__FUNCTION__, pm, pm_local));
+
+	} else if (strnicmp((char *)&powermode_val, "0", strlen("0")) == 0) {
+		
+
+		dev_wlc_ioctl(dev, WLC_SET_PM, &pm, sizeof(pm));
+
+		
+		net_os_set_packet_filter(dev, 1);
+
+		g_bt->dhcp_done = true;
+		g_bt->ts_dhcp_ok = JF2MS;
+		WL_TRACE_COEX(("%s: DHCP done for:%d ms, restored pm:%d\n",
+			__FUNCTION__, (g_bt->ts_dhcp_ok - g_bt->ts_dhcp_start), pm));
+
+	} else {
+		WL_ERROR(("%s Unkwown yet power setting, ignored\n",
+			__FUNCTION__));
+	}
+
+	p += snprintf(p, MAX_WX_STRING, "OK");
+
+	wrqu->data.length = p - extra + 1;
+
+	return error;
+}
+#endif 
+
+
+bool btcoex_is_sco_active(struct net_device *dev)
+{
+	int ioc_res = 0;
+	bool res = false;
+	int temp = 0;
+
+	ioc_res = dev_wlc_intvar_get_reg(dev, "btc_params", 4, &temp);
+
+	if (ioc_res == 0) {
+		WL_TRACE_COEX(("%s: read btc_params[4] = %x\n",
+			__FUNCTION__, temp));
+
+		if ((temp > 0xea0) && (temp < 0xed8)) {
+			WL_TRACE_COEX(("%s: BT SCO/eSCO is ACTIVE \n", __FUNCTION__));
+			res = true;
+		} else {
+			WL_TRACE_COEX(("%s: BT SCO/eSCO is NOT detected\n", __FUNCTION__));
+		}
+	} else {
+		WL_ERROR(("%s ioc read btc params error\n", __FUNCTION__));
+	}
+	return res;
+}
+
+#if defined(BT_DHCP_eSCO_FIX)
+
+static int set_btc_esco_params(struct net_device *dev, bool trump_sco)
+{
+	static bool saved_status = false;
+
+	char buf_reg50va_dhcp_on[8] = { 50, 00, 00, 00, 0x22, 0x80, 0x00, 0x00 };
+	char buf_reg51va_dhcp_on[8] = { 51, 00, 00, 00, 0x00, 0x00, 0x00, 0x00 };
+	char buf_reg64va_dhcp_on[8] = { 64, 00, 00, 00, 0x00, 0x00, 0x00, 0x00 };
+	char buf_reg65va_dhcp_on[8] = { 65, 00, 00, 00, 0x00, 0x00, 0x00, 0x00 };
+	char buf_reg71va_dhcp_on[8] = { 71, 00, 00, 00, 0x00, 0x00, 0x00, 0x00 };
+
+	uint32 regaddr;
+	static uint32 saved_reg50;
+	static uint32 saved_reg51;
+	static uint32 saved_reg64;
+	static uint32 saved_reg65;
+	static uint32 saved_reg71;
+
+	if (trump_sco) { 
+
+		
+		WL_TRACE_COEX(("Do new SCO/eSCO coex algo {save & override} \n"));
+
+
+		if  ((!dev_wlc_intvar_get_reg(dev, "btc_params", 50,  &saved_reg50)) &&
+			(!dev_wlc_intvar_get_reg(dev, "btc_params", 51,  &saved_reg51)) &&
+			(!dev_wlc_intvar_get_reg(dev, "btc_params", 64,  &saved_reg64)) &&
+			(!dev_wlc_intvar_get_reg(dev, "btc_params", 65,  &saved_reg65)) &&
+			(!dev_wlc_intvar_get_reg(dev, "btc_params", 71,  &saved_reg71))) {
+
+			saved_status = TRUE;
+			WL_TRACE_COEX(("%s saved bt_params[50,51,64,65,71]:"
+				" 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+				__FUNCTION__, saved_reg50, saved_reg51,
+				saved_reg64, saved_reg65, saved_reg71));
+
+		} else {
+			WL_ERROR((":%s: save btc_params failed\n",
+				__FUNCTION__));
+			saved_status = false;
+			return -1;
+		}
+
+		WL_TRACE_COEX(("override with [50,51,64,65,71]:"
+			" 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+			*(u32 *)(buf_reg50va_dhcp_on+4),
+			*(u32 *)(buf_reg51va_dhcp_on+4),
+			*(u32 *)(buf_reg64va_dhcp_on+4),
+			*(u32 *)(buf_reg65va_dhcp_on+4),
+			*(u32 *)(buf_reg71va_dhcp_on+4)));
+
+		dev_wlc_bufvar_set(dev, "btc_params", (char *)&buf_reg50va_dhcp_on[0], 8);
+		dev_wlc_bufvar_set(dev, "btc_params", (char *)&buf_reg51va_dhcp_on[0], 8);
+		dev_wlc_bufvar_set(dev, "btc_params", (char *)&buf_reg64va_dhcp_on[0], 8);
+		dev_wlc_bufvar_set(dev, "btc_params", (char *)&buf_reg65va_dhcp_on[0], 8);
+		dev_wlc_bufvar_set(dev, "btc_params", (char *)&buf_reg71va_dhcp_on[0], 8);
+
+		saved_status = true;
+
+	} else if (saved_status) {
+		
+		WL_TRACE_COEX(("Do new SCO/eSCO coex algo {save & override} \n"));
+
+		regaddr = 50;
+		dev_wlc_intvar_set_reg(dev, "btc_params",
+			(char *)&regaddr, (char *)&saved_reg50);
+		regaddr = 51;
+		dev_wlc_intvar_set_reg(dev, "btc_params",
+			(char *)&regaddr, (char *)&saved_reg51);
+		regaddr = 64;
+		dev_wlc_intvar_set_reg(dev, "btc_params",
+			(char *)&regaddr, (char *)&saved_reg64);
+		regaddr = 65;
+		dev_wlc_intvar_set_reg(dev, "btc_params",
+			(char *)&regaddr, (char *)&saved_reg65);
+		regaddr = 71;
+		dev_wlc_intvar_set_reg(dev, "btc_params",
+			(char *)&regaddr, (char *)&saved_reg71);
+
+		WL_TRACE_COEX(("restore bt_params[50,51,64,65,71]: 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+			saved_reg50, saved_reg51, saved_reg64,
+			saved_reg65, saved_reg71));
+
+		saved_status = false;
+	} else {
+		WL_ERROR((":%s att to restore not saved BTCOEX params\n",
+			__FUNCTION__));
+		return -1;
+	}
+	return 0;
+}
+#endif 
+
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+static int
+wl_iw_set_btcoex_dhcp(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+)
+{
+	int error = 0;
+	char *p = extra;
+
+
+#ifndef CUSTOMER_HW2
+	static int  pm = PM_FAST;
+	int  pm_local = PM_OFF;
+#endif
+	char powermode_val = 0;
+	char buf_reg66va_dhcp_on[8] = { 66, 00, 00, 00, 0x10, 0x27, 0x00, 0x00 };
+	char buf_reg41va_dhcp_on[8] = { 41, 00, 00, 00, 0x33, 0x00, 0x00, 0x00 };
+	char buf_reg68va_dhcp_on[8] = { 68, 00, 00, 00, 0x90, 0x01, 0x00, 0x00 };
+
+	uint32 regaddr;
+	static uint32 saved_reg66;
+	static uint32 saved_reg41;
+	static uint32 saved_reg68;
+	static bool saved_status = FALSE;
+
+	char buf_flag7_default[8] =   { 7, 00, 00, 00, 0x0, 0x00, 0x00, 0x00};
+
 	
-	dev_wlc_intvar_get_reg(dev, "btc_params", 68,  &val);
+#ifdef  CUSTOMER_HW2
+	strncpy((char *)&powermode_val, extra + strlen("BTCOEXMODE") +1, 1);
+#else
+	strncpy((char *)&powermode_val, extra + strlen("POWERMODE") +1, 1);
+#endif
 
 	if (strnicmp((char *)&powermode_val, "1", strlen("1")) == 0) {
+	
+		WL_TRACE_COEX(("%s: DHCP session start, cmd:%s\n", __FUNCTION__, extra));
 
-		WL_TRACE(("%s: DHCP session starts\n", __FUNCTION__));
 
-#ifdef  CUSTOMER_HW2
+		if ((saved_status == FALSE) &&
+#ifndef CUSTOMER_HW2
+			(!dev_wlc_ioctl(dev, WLC_GET_PM, &pm, sizeof(pm))) &&
+#endif
+			(!dev_wlc_intvar_get_reg(dev, "btc_params", 66,  &saved_reg66)) &&
+			(!dev_wlc_intvar_get_reg(dev, "btc_params", 41,  &saved_reg41)) &&
+			(!dev_wlc_intvar_get_reg(dev, "btc_params", 68,  &saved_reg68)))   {
 
-		dev_wlc_ioctl(dev, WLC_GET_PM, &pm, sizeof(pm));
+				WL_TRACE_COEX(("save regs {66,41,68} ->: 0x%x 0x%x 0x%x\n", \
+					saved_reg66, saved_reg41, saved_reg68));
+
+#ifndef CUSTOMER_HW2
 
 		dev_wlc_ioctl(dev, WLC_SET_PM, &pm_local, sizeof(pm_local));
 #endif
 
-		dev_wlc_bufvar_set(dev, "btc_params",
-			(char *)&buf_reg66va_dhcp_on[0], sizeof(buf_reg66va_dhcp_on));
 		
-		dev_wlc_bufvar_set(dev, "btc_params",
-			(char *)&buf_reg41va_dhcp_on[0], sizeof(buf_reg41va_dhcp_on));
-		
-		dev_wlc_bufvar_set(dev, "btc_params",
-			(char *)&buf_reg68va_dhcp_on[0], sizeof(buf_reg68va_dhcp_on));
-
-#ifdef COEX_DHCP
+				if (btcoex_is_sco_active(dev)) {
+
+					dev_wlc_bufvar_set(dev, "btc_params", \
+						(char *)&buf_reg66va_dhcp_on[0], \
+						 sizeof(buf_reg66va_dhcp_on));
+					
+					dev_wlc_bufvar_set(dev, "btc_params", \
+						(char *)&buf_reg41va_dhcp_on[0], \
+						 sizeof(buf_reg41va_dhcp_on));
+					
+					dev_wlc_bufvar_set(dev, "btc_params", \
+						(char *)&buf_reg68va_dhcp_on[0], \
+						 sizeof(buf_reg68va_dhcp_on));
+					saved_status = TRUE;
 		
 		g_bt->bt_state = BT_DHCP_START;
 		g_bt->timer_on = 1;
 		mod_timer(&g_bt->timer, g_bt->timer.expires);
-		WL_TRACE(("%s enable BT DHCP Timer\n", __FUNCTION__));
-#endif 
-
+					WL_TRACE_COEX(("%s enable BT DHCP Timer\n", \
+					__FUNCTION__));
+				}
+	}
+		else if (saved_status == TRUE) {
+			WL_ERROR(("%s was called w/o DHCP OFF. Continue\n", __FUNCTION__));
+		}
 	}
+#ifdef  CUSTOMER_HW2
+	else if (strnicmp((char *)&powermode_val, "2", strlen("2")) == 0) {
+#else
 	else if (strnicmp((char *)&powermode_val, "0", strlen("0")) == 0) {
+#endif
 
-		WL_TRACE(("%s: DHCP session done\n", __FUNCTION__));
 
-#ifdef  CUSTOMER_HW2
+#ifndef CUSTOMER_HW2
 
 		dev_wlc_ioctl(dev, WLC_SET_PM, &pm, sizeof(pm));
 #endif
-#ifdef COEX_DHCP
 		
-		WL_TRACE(("%s disable BT DHCP Timer\n", __FUNCTION__));
+		
+		WL_TRACE_COEX(("%s disable BT DHCP Timer\n", __FUNCTION__));
 		if (g_bt->timer_on) {
 			g_bt->timer_on = 0;
+
 			del_timer_sync(&g_bt->timer);
+
+			if (g_bt->bt_state != BT_DHCP_IDLE) {
+			
+				WL_TRACE_COEX(("%s bt->bt_state:%d\n",
+					__FUNCTION__, g_bt->bt_state));
+					up(&g_bt->tsk_ctl.sema);			
+//				up(&g_bt->bt_sem);
+			}
 		}
 
 		
-		dev_wlc_bufvar_set(dev, "btc_flags",
+		if (saved_status == TRUE)
+			dev_wlc_bufvar_set(dev, "btc_flags", \
 			(char *)&buf_flag7_default[0], sizeof(buf_flag7_default));
-#endif 
 
 		
-		dev_wlc_bufvar_set(dev, "btc_params",
-			(char *)&buf_reg66val_defualt[0], sizeof(buf_reg66val_defualt));
+		if (saved_status == TRUE) {
+			regaddr = 66;
+			dev_wlc_intvar_set_reg(dev, "btc_params", \
+				(char *)&regaddr, (char *)&saved_reg66);
+			regaddr = 41;
+			dev_wlc_intvar_set_reg(dev, "btc_params", \
+				(char *)&regaddr, (char *)&saved_reg41);
+			regaddr = 68;
+			dev_wlc_intvar_set_reg(dev, "btc_params", \
+				(char *)&regaddr, (char *)&saved_reg68);
+
+			WL_TRACE_COEX(("restore regs {66,41,68} <- 0x%x 0x%x 0x%x\n", \
+					saved_reg66, saved_reg41, saved_reg68));
+		}
+		saved_status = FALSE;
 		
-		dev_wlc_bufvar_set(dev, "btc_params",
-			(char *)&buf_reg41val_defualt[0], sizeof(buf_reg41val_defualt));
 		
-		dev_wlc_bufvar_set(dev, "btc_params",
-			(char *)&buf_reg68val_defualt[0], sizeof(buf_reg68val_defualt));
 	}
 	else {
-		WL_ERROR(("Unkwown yet power setting, ignored\n"));
+		WL_ERROR(("%s Unkwown yet power setting, ignored\n",
+			__FUNCTION__));
 	}
 
 	p += snprintf(p, MAX_WX_STRING, "OK");
@@ -1068,7 +1184,39 @@ wl_iw_set_btcoex_dhcp(
 
 	return error;
 }
-#endif	/* !defined(CONFIG_LGE_BCM432X_PATCH) */
+#endif /* CONFIG_LGE_BCM432X_PATCH */
+
+
+static int
+wl_iw_set_suspend(
+struct net_device *dev,
+struct iw_request_info *info,
+union iwreq_data *wrqu,
+char *extra
+)
+{
+	int suspend_flag;
+	int ret_now;
+	int ret = 0;
+
+	suspend_flag = *(extra + strlen(SETSUSPEND_CMD) + 1) - '0';
+
+	if (suspend_flag != 0)
+		suspend_flag = 1;
+
+	ret_now = net_os_set_suspend_disable(dev, suspend_flag);
+
+	
+	if (ret_now != suspend_flag) {
+		if (!(ret = net_os_set_suspend(dev, ret_now)))
+			WL_ERROR(("%s: Suspend Flag %d -> %d\n", \
+					__FUNCTION__, ret_now, suspend_flag));
+		else
+			WL_ERROR(("%s: failed %d\n", __FUNCTION__, ret));
+	}
+
+	return ret;
+}
 
 int
 wl_format_ssid(char* ssid_buf, uint8* ssid, int ssid_len)
@@ -1083,7 +1231,7 @@ wl_format_ssid(char* ssid_buf, uint8* ssid, int ssid_len)
 		if (c == '\\') {
 			*p++ = '\\';
 			*p++ = '\\';
-		} else if (isprint((uchar)c)) {
+		} else if (isprintf((uchar)c)) {
 			*p++ = (char)c;
 		} else {
 			p += sprintf(p, "\\x%02X", c);
@@ -1126,6 +1274,329 @@ wl_iw_get_link_speed(
 	return error;
 }
 
+
+static int
+wl_iw_get_dtim_skip(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+)
+{
+	int error = -1;
+	char *p = extra;
+	char iovbuf[32];
+
+	if (g_onoff == G_WLAN_SET_ON) {
+
+			memset(iovbuf, 0, sizeof(iovbuf));
+			strcpy(iovbuf, "bcn_li_dtim");
+
+			if ((error = dev_wlc_ioctl(dev, WLC_GET_VAR,
+				&iovbuf, sizeof(iovbuf))) >= 0) {
+
+				p += snprintf(p, MAX_WX_STRING, "Dtim_skip %d", iovbuf[0]);
+				WL_TRACE(("%s: get dtim_skip = %d\n", __FUNCTION__, iovbuf[0]));
+				wrqu->data.length = p - extra + 1;
+			}
+			else
+				WL_ERROR(("%s: get dtim_skip failed code %d\n", \
+					__FUNCTION__, error));
+	}
+	return error;
+}
+
+
+static int
+wl_iw_set_dtim_skip(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+)
+{
+	int error = -1;
+	char *p = extra;
+	int bcn_li_dtim;
+	char iovbuf[32];
+
+	if (g_onoff == G_WLAN_SET_ON) {
+
+		bcn_li_dtim = htod32((uint)*(extra + strlen(DTIM_SKIP_SET_CMD) + 1) - '0');
+
+		if ((bcn_li_dtim >= 0) || ((bcn_li_dtim <= 5))) {
+
+			memset(iovbuf, 0, sizeof(iovbuf));
+			bcm_mkiovar("bcn_li_dtim", (char *)&bcn_li_dtim,
+				4, iovbuf, sizeof(iovbuf));
+
+			if ((error = dev_wlc_ioctl(dev, WLC_SET_VAR,
+				&iovbuf, sizeof(iovbuf))) >= 0) {
+				p += snprintf(p, MAX_WX_STRING, "OK");
+
+				
+				net_os_set_dtim_skip(dev, bcn_li_dtim);
+
+				WL_TRACE(("%s: set dtim_skip %d OK\n", __FUNCTION__, \
+					bcn_li_dtim));
+				goto exit;
+			}
+			else  WL_ERROR(("%s: set dtim_skip %d failed code %d\n", \
+				__FUNCTION__, bcn_li_dtim, error));
+		}
+		else  WL_ERROR(("%s Incorrect dtim_skip setting %d, ignored\n", \
+			__FUNCTION__, bcn_li_dtim));
+	}
+
+	p += snprintf(p, MAX_WX_STRING, "FAIL");
+
+exit:
+	wrqu->data.length = p - extra + 1;
+	return error;
+}
+
+
+static int
+wl_iw_get_band(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+)
+{
+	int error = -1;
+	char *p = extra;
+	static int band;
+
+	if (g_onoff == G_WLAN_SET_ON) {
+		error = dev_wlc_ioctl(dev, WLC_GET_BAND, &band, sizeof(band));
+
+		p += snprintf(p, MAX_WX_STRING, "Band %d", band);
+
+		wrqu->data.length = p - extra + 1;
+	}
+	return error;
+}
+
+
+static int
+wl_iw_set_band(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+)
+{
+	int error = -1;
+	char *p = extra;
+	uint band;
+
+	if (g_onoff == G_WLAN_SET_ON) {
+
+		band = htod32((uint)*(extra + strlen(BAND_SET_CMD) + 1) - '0');
+
+		if ((band == WLC_BAND_AUTO) || (band == WLC_BAND_5G) || (band == WLC_BAND_2G)) {
+
+			
+			if ((error = dev_wlc_ioctl(dev, WLC_SET_BAND,
+				&band, sizeof(band))) >= 0) {
+				p += snprintf(p, MAX_WX_STRING, "OK");
+				WL_TRACE(("%s: set band %d OK\n", __FUNCTION__, band));
+				goto exit;
+			}
+			else  WL_ERROR(("%s: set band %d failed code %d\n", __FUNCTION__, \
+					band, error));
+		}
+		else  WL_ERROR(("%s Incorrect band setting %d, ignored\n", __FUNCTION__, band));
+	}
+
+	p += snprintf(p, MAX_WX_STRING, "FAIL");
+
+exit:
+	wrqu->data.length = p - extra + 1;
+	return error;
+}
+
+#ifdef PNO_SUPPORT
+
+static int
+wl_iw_set_pno_reset(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+)
+{
+	int error = -1;
+	char *p = extra;
+
+	if ((g_onoff == G_WLAN_SET_ON) && (dev != NULL)) {
+
+		if ((error = dhd_dev_pno_reset(dev)) >= 0) {
+				p += snprintf(p, MAX_WX_STRING, "OK");
+				WL_TRACE(("%s: set OK\n", __FUNCTION__));
+				goto exit;
+		}
+		else  WL_ERROR(("%s: failed code %d\n", __FUNCTION__, error));
+	}
+
+	p += snprintf(p, MAX_WX_STRING, "FAIL");
+
+exit:
+	wrqu->data.length = p - extra + 1;
+	return error;
+}
+
+
+
+static int
+wl_iw_set_pno_enable(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+)
+{
+	int error = -1;
+	char *p = extra;
+	int pfn_enabled;
+
+	pfn_enabled = htod32((uint)*(extra + strlen(PNOENABLE_SET_CMD) + 1) - '0');
+
+	if ((g_onoff == G_WLAN_SET_ON) && (dev != NULL)) {
+
+		if ((error = dhd_dev_pno_enable(dev, pfn_enabled)) >= 0) {
+				p += snprintf(p, MAX_WX_STRING, "OK");
+				WL_TRACE(("%s: set OK\n", __FUNCTION__));
+				goto exit;
+		}
+		else  WL_ERROR(("%s: failed code %d\n", __FUNCTION__, error));
+	}
+
+	p += snprintf(p, MAX_WX_STRING, "FAIL");
+
+exit:
+	wrqu->data.length = p - extra + 1;
+	return error;
+}
+
+
+
+static int
+wl_iw_set_pno_set(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+)
+{
+	int res = -1;
+	wlc_ssid_t ssids_local[MAX_PFN_LIST_COUNT];
+	int nssid = 0;
+	cmd_tlv_t *cmd_tlv_temp;
+	char *str_ptr;
+	char *str_ptr_end;
+	int tlv_size_left;
+	int pno_time;
+
+#ifdef PNO_SET_DEBUG
+	int i;
+	char pno_in_example[] = {'P', 'N', 'O', 'S', 'E', 'T', 'U', 'P', ' ', \
+							'S', '1', '2', '0',
+							'S',    
+							0x04, 
+							'B', 'R', 'C', 'M',
+							'S',    
+							0x04, 
+							'G', 'O', 'O', 'G',
+							'T',
+							'1','E',  
+  
+							0x00   
+							};
+#endif 
+
+	WL_ERROR(("\n### %s: info->cmd:%x, info->flags:%x, u.data=0x%p, u.len=%d\n",
+		__FUNCTION__, info->cmd, info->flags,
+		wrqu->data.pointer, wrqu->data.length));
+
+	if (g_onoff == G_WLAN_SET_OFF) {
+		WL_TRACE(("%s: driver is not up yet after START\n", __FUNCTION__));
+		return -1;
+	}
+
+	if (wrqu->data.length < (strlen(PNOSETUP_SET_CMD) + sizeof(cmd_tlv_t))) {
+		WL_ERROR(("%s aggument=%d  less %d\n", __FUNCTION__, \
+			wrqu->data.length, strlen(PNOSETUP_SET_CMD) + sizeof(cmd_tlv_t)));
+		return -1;
+	}
+
+#ifdef PNO_SET_DEBUG
+	if (!(extra = kmalloc(sizeof(pno_in_example) +100, GFP_KERNEL)))
+		return -ENOMEM;
+	memcpy(extra, pno_in_example, sizeof(pno_in_example));
+	wrqu->data.length = sizeof(pno_in_example);
+	for (i = 0; i < wrqu->data.length; i++)
+		printf("%02X ", extra[i]);
+	printf("\n");
+#endif 
+
+	str_ptr = extra;
+#ifdef PNO_SET_DEBUG
+	str_ptr +=  strlen("PNOSETUP ");
+	tlv_size_left = wrqu->data.length - strlen("PNOSETUP ");
+#else
+	str_ptr +=  strlen(PNOSETUP_SET_CMD);
+	tlv_size_left = wrqu->data.length - strlen(PNOSETUP_SET_CMD);
+#endif
+
+	cmd_tlv_temp = (cmd_tlv_t *)str_ptr;
+	memset(ssids_local, 0, sizeof(ssids_local));
+	
+	if ((cmd_tlv_temp->prefix == PNO_TLV_PREFIX) && \
+		(cmd_tlv_temp->version == PNO_TLV_VERSION) && \
+		(cmd_tlv_temp->subver == PNO_TLV_SUBVERSION))
+	{
+		str_ptr += sizeof(cmd_tlv_t);
+		tlv_size_left  -= sizeof(cmd_tlv_t);
+
+		
+		if ((nssid = wl_iw_parse_ssid_list_tlv(&str_ptr, ssids_local, \
+				MAX_PFN_LIST_COUNT, &tlv_size_left)) <= 0) {
+			WL_ERROR(("SSID is not presented or corrupted ret=%d\n", nssid));
+			goto exit_proc;
+		}
+		else {
+			if ((str_ptr[0] != PNO_TLV_TYPE_TIME) || (tlv_size_left <= 1)) {
+				WL_ERROR(("%s scan duration corrupted field size %d\n", \
+						__FUNCTION__, tlv_size_left));
+				goto exit_proc;
+			}
+			str_ptr++;
+			pno_time = simple_strtoul(str_ptr, &str_ptr_end, 16);
+			WL_ERROR((" got %d bytes left pno_time %d or %#x\n", \
+					tlv_size_left, pno_time, pno_time));
+		}
+	}
+	else {
+		WL_ERROR(("%s get wrong TLV command\n", __FUNCTION__));
+		goto exit_proc;
+	}
+
+	
+	res = dhd_dev_pno_set(dev, ssids_local, nssid, pno_time);
+
+exit_proc:
+	return res;
+}
+#endif 
+/* BEGIN: 0005568 mingi.sung@lge.com 2010-03-27 */
+/* MOD 0005568: [WLAN] Wi-Fi will be disconnected if the RSSI value is lower than -92 */
+int less_than_rssi = 0;
+/* END: 0005568 mingi.sung@lge.com 2010-03-27 */
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+int wl_dtim_set = 0;
+#endif
 static int
 wl_iw_get_rssi(
 	struct net_device *dev,
@@ -1135,8 +1606,10 @@ wl_iw_get_rssi(
 )
 {
 	static int rssi = 0;
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+	static wlc_ssid_t ssid = {0};
+#endif
 	int error = 0;
-	wlc_ssid_t ssid;
 	char *p = extra;
 /* LGE_CHANGE_S, [yoohoo@lge.com], 2009-05-13,
  * <some ssid use '<' character sometimes and it cause response discard
@@ -1149,20 +1622,17 @@ wl_iw_get_rssi(
  * in wpa_supplicant (wpa_ctrl_request())> */
 	scb_val_t scb_val;
 
-	scb_val.val = 0;
+	bzero(&scb_val, sizeof(scb_val_t));
 
-	bzero(&ssid, sizeof(ssid));
 	if (g_onoff == G_WLAN_SET_ON) {
 		error = dev_wlc_ioctl(dev, WLC_GET_RSSI, &scb_val, sizeof(scb_val_t));
 		rssi = dtoh32(scb_val.val);
 
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
 		error = dev_wlc_ioctl(dev, WLC_GET_SSID, &ssid, sizeof(ssid));
 
 		ssid.SSID_len = dtoh32(ssid.SSID_len);
-	}
-
-	if (!ssid.SSID_len) {
-		return 0;
+#endif
 	}
 
 /* LGE_CHANGE_S, [yoohoo@lge.com], 2009-05-13,
@@ -1171,12 +1641,41 @@ wl_iw_get_rssi(
 #if defined(CONFIG_LGE_BCM432X_PATCH)
 	p += snprintf(p, MAX_WX_STRING, "ssid rssi %d", rssi);
 #else /* CONFIG_LGE_BCM432X_PATCH */
+	if (ssid.SSID_len == 0) { 
+		rssi = -1;
+	}
+	WL_ASSOC(("%s ssid_len:%d, rssi:%d\n", __FUNCTION__, ssid.SSID_len, rssi));
+
 	wl_format_ssid(ssidbuf, ssid.SSID, dtoh32(ssid.SSID_len));
 	p += snprintf(p, MAX_WX_STRING, "%s rssi %d ", ssidbuf, rssi);
 #endif /* CONFIG_LGE_BCM432X_PATCH */
 /* LGE_CHANGE_E, [yoohoo@lge.com], 2009-05-13,
  * <some ssid use '<' character sometimes and it cause response discard
  * in wpa_supplicant (wpa_ctrl_request())> */
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+	if (wl_dtim_set && rssi < 0){
+//		wl_iw_set_dtim_val(dev);	//by sjpark 10-12-15
+		wl_dtim_set = 0 ;
+	}
+#endif
+/* BEGIN: 0005568 mingi.sung@lge.com 2010-03-27 */
+/* MOD 0005568: [WLAN] Wi-Fi will be disconnected if the RSSI value is lower than -92 */
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+	if( rssi < -92 ){
+		less_than_rssi ++;
+	}else{
+		if( less_than_rssi != 0)
+			less_than_rssi --;
+	}
+
+	if( less_than_rssi > 2){
+		scb_val_t scbval;
+		bzero(&scbval, sizeof(scb_val_t));
+		(void) dev_wlc_ioctl(dev, WLC_DISASSOC, &scbval, sizeof(scb_val_t));
+		less_than_rssi =0 ;
+	}
+#endif	/* defined(CONFIG_LGE_BCM432X_PATCH) */
+/* END: 0005568 mingi.sung@lge.com 2010-03-27 */
 
 	wrqu->data.length = p - extra + 1;
 
@@ -1211,80 +1710,62 @@ wl_iw_send_priv_event(
 extern int dhd_deep_sleep(struct net_device *dev, int flag);
 #endif /* CONFIG_LGE_BCM432X_PATCH && CONFIG_BRCM_USE_DEEPSLEEP */
 /* LGE_CHANGE_E, [yoohoo@lge.com], 2009-11-19, Use deepsleep instead of dhd_dev_reset when driver start or stop */
-/* Do not use GPIO Reset at On/Off. Use mpc. */
-#if defined(CONFIG_BRCM_USE_GPIO_RESET) || defined(CONFIG_BRCM_USE_DEEPSLEEP)
-static int
-_wl_control_sysioc_thread_wl_off(void *data)
+
+int
+wl_control_wl_start(struct net_device *dev)
 {
-	struct wl_ctrl *wl_ctl = (struct wl_ctrl *)data;
+	int ret = 0;
+	wl_iw_t *iw;
 
-#if defined(BCMDONGLEHOST)
-	wl_iw_t *iw = *(wl_iw_t **)netdev_priv(wl_ctl->dev);
-#endif 
-	DAEMONIZE("wlcontrol_sysioc");
+	WL_TRACE(("Enter %s \n", __FUNCTION__));
 
-	WL_TRACE(("%s Entered\n", __FUNCTION__));
+	if (!dev) {
+		WL_ERROR(("%s: dev is null\n", __FUNCTION__));
+		return -1;
+	}
 
-#if defined(BCMDONGLEHOST)
-	//WAKE_LOCK_INIT(iw->pub, WAKE_LOCK_OFF, "sysioc_thread_wl_off");
-	//WAKE_LOCK(iw->pub, WAKE_LOCK_OFF);
-	DHD_OS_WAKE_LOCK(iw->pub);
-#endif 
-	while (down_interruptible(&wl_ctl->timer_sem) == 0) {
+	iw = *(wl_iw_t **)netdev_priv(dev);
 
-		WL_TRACE(("%s Turning off wifi dev\n", __FUNCTION__));
+	if (!iw) {
+		WL_ERROR(("%s: wl is null\n", __FUNCTION__));
+		return -1;
+	}
+	dhd_os_start_lock(iw->pub);
 
-		g_onoff = G_WLAN_SET_OFF;
+	if (g_onoff == G_WLAN_SET_OFF) {
+/* LGE_CHANGE_S, [yoohoo@lge.com], 2009-11-19, Use deepsleep instead of dhd_dev_reset when driver start or stop */
+#if defined(CONFIG_LGE_BCM432X_PATCH) && defined(CONFIG_BRCM_USE_DEEPSLEEP)
+		/* Use Deep Sleep instead of WL RESET */
+		dhd_deep_sleep(dev, FALSE);
+#else /* CONFIG_LGE_BCM432X_PATCH && CONFIG_BRCM_USE_DEEPSLEEP */
+#if defined(CONFIG_BRCM_USE_GPIO_RESET) /* Do not use GPIO Reset at On/Off. Use mpc. */
+		dhd_customer_gpio_wlan_ctrl(WLAN_RESET_ON);
 
-#if defined(WL_IW_USE_ISCAN)
-		g_iscan->iscan_state = ISCAN_STATE_IDLE;
-#elif defined(WL_IW_USE_ESCAN)
-		g_escan->escan_state = ESCAN_STATE_IDLE;
+#if defined(BCMLXSDMMC)
+		sdioh_start(NULL, 0);
 #endif
 
-/* LGE_CHANGE_S, [yoohoo@lge.com], 2009-11-19, Use deepsleep instead of dhd_dev_reset when driver start or stop */
-#if defined(CONFIG_BRCM_USE_DEEPSLEEP)
-		/* Use Deep Sleep instead of WL Reset*/
-		dhd_deep_sleep(wl_ctl->dev, TRUE);
-#elif defined(CONFIG_BRCM_USE_GPIO_RESET)
-		dhd_dev_reset(wl_ctl->dev, 1);
+		ret = dhd_dev_reset(dev, 0);
 
 #if defined(BCMLXSDMMC)
-		sdioh_stop(NULL);
+		sdioh_start(NULL, 1);
 #endif
 
-		dhd_customer_gpio_wlan_ctrl(WLAN_RESET_OFF);
-#endif
+		dhd_dev_init_ioctl(dev);
+#else	/* defined(CONFIG_BRCM_USE_GPIO_RESET) */
+		 g_onoff = G_WLAN_SET_ON;
+		 wl_iw_send_priv_event(dev, "START");
+		 printk("Exited %s \n", __FUNCTION__);
+#endif	/* defined(CONFIG_BRCM_USE_GPIO_RESET) */ /* Do not use GPIO Reset at On/Off. Use mpc. */
+#endif /* CONFIG_LGE_BCM432X_PATCH && CONFIG_BRCM_USE_DEEPSLEEP */
 /* LGE_CHANGE_E, [yoohoo@lge.com], 2009-11-19, Use deepsleep instead of dhd_dev_reset when driver start or stop */
-
-		wl_iw_send_priv_event(wl_ctl->dev, "STOP");
-
-		break;
+		g_onoff = G_WLAN_SET_ON;
 	}
+	WL_ERROR(("Exited %s \n", __FUNCTION__));
 
-	WL_TRACE(("%s Exited\n", __FUNCTION__));
-#if defined(BCMDONGLEHOST)
-	DHD_OS_WAKE_UNLOCK(iw->pub);
-	//WAKE_LOCK_DESTROY(iw->pub, WAKE_LOCK_OFF);
-#endif 
-
-	complete_and_exit(&wl_ctl->sysioc_exited, 0);
-	KILL_PROC(wl_ctl->sysioc_pid, SIGTERM);
-}
-
-static void
-wl_iw_stop_timerfunc(ulong data)
-{
-	struct wl_ctrl * wl_ctl = (struct wl_ctrl *)data;
-
-	WL_TRACE(("%s\n", __FUNCTION__));
-
-	del_timer(wl_ctl->timer);
-
-	up(&wl_ctl->timer_sem);
+	dhd_os_start_unlock(iw->pub);
+	return ret;
 }
-#endif	/* CONFIG_LGE_BCM432X_PATCH */
-
 static int
 wl_iw_control_wl_off(
 	struct net_device *dev,
@@ -1292,48 +1773,79 @@ wl_iw_control_wl_off(
 )
 {
 	int ret = 0;
-#if 0 // defined(CONFIG_BRCM_USE_GPIO_RESET) || defined(CONFIG_BRCM_USE_DEEPSLEEP)  // louislee : for ping+suspend(lcd off) error
-	static struct wl_ctrl ctl;
-	static struct timer_list timer;
+	wl_iw_t *iw;
+
+	WL_ERROR(("Enter %s\n", __FUNCTION__));
+
+	if (!dev) {
+		WL_ERROR(("%s: dev is null\n", __FUNCTION__));
+		return -1;
+	}
+	
+	iw = *(wl_iw_t **)netdev_priv(dev);
+	if (!iw) {
+		WL_ERROR(("%s: dev is null\n", __FUNCTION__));
+		return -1;
+	}
+	dhd_os_start_lock(iw->pub);
+	
+#ifdef SOFTAP
+	ap_cfg_running = FALSE;
 
-	WL_TRACE(("Enter %s\n", __FUNCTION__));
+#endif 
+	
+	if (g_onoff == G_WLAN_SET_ON) {
+		g_onoff = G_WLAN_SET_OFF;
+
+#if defined(CONFIG_LGE_BCM432X_PATCH) && !defined(CONFIG_BRCM_USE_GPIO_RESET)
+{
+		scb_val_t scbval;
+		bzero(&scbval, sizeof(scb_val_t));
+		(void) dev_wlc_ioctl(dev, WLC_DISASSOC, &scbval, sizeof(scb_val_t));
+}
+#endif /* defined(CONFIG_LGE_BCM432X_PATCH) && !defined(CONFIG_BRCM_USE_GPIO_RESET) */
 
-	
-	
-	ctl.timer = &timer;
-	ctl.dev = dev;
-	sema_init(&ctl.timer_sem, 0);
-	init_completion(&ctl.sysioc_exited);
+#if defined(WL_IW_USE_ISCAN)
+		g_iscan->iscan_state = ISCAN_STATE_IDLE;
+#endif 
 
-	
-	ctl.sysioc_pid = kernel_thread(_wl_control_sysioc_thread_wl_off, &ctl, 0);
+/* LGE_CHANGE_S, [yoohoo@lge.com], 2009-11-19, Use deepsleep instead of dhd_dev_reset when driver start or stop */
+#if defined(CONFIG_BRCM_USE_DEEPSLEEP)
+		/* Use Deep Sleep instead of WL Reset*/
+		dhd_deep_sleep(wl_ctl->dev, TRUE);
+#elif defined(CONFIG_BRCM_USE_GPIO_RESET)
+		dhd_dev_reset(dev, 1);
+#endif /* CONFIG_BRCM_USE_DEEPSLEEP, CONFIG_BRCM_USE_GPIO_RESET */
 
-	timer.data = (ulong)&ctl;
-	timer.function = wl_iw_stop_timerfunc;
-	init_timer(&timer);
-#if defined(CONFIG_LGE_BCM432X_PATCH)
-	timer.expires = jiffies + 100 * HZ / 1000;
-#else
-	timer.expires = jiffies + 2000 * HZ / 1000;
-#endif	/* CONFIG_LGE_BCM432X_PATCH */
-	add_timer(&timer);
+#if defined(WL_IW_USE_ISCAN)
+#if !defined(CSCAN)
 
-	WL_TRACE(("Exited %s\n", __FUNCTION__));
-#else	/* defined(CONFIG_BRCM_USE_GPIO_RESET) || defined(CONFIG_BRCM_USE_DEEPSLEEP) */
+		wl_iw_free_ss_cache();
+		wl_iw_run_ss_cache_timer(0);
+		
+		g_ss_cache_ctrl.m_link_down = 1;
+#endif 
+		memset(g_scan, 0, G_SCAN_RESULTS);
+		g_scan_specified_ssid = 0;
+#if defined(CONFIG_FIRST_SCAN)
+		
+		g_first_broadcast_scan = BROADCAST_SCAN_FIRST_IDLE;
+		g_first_counter_scans = 0;
+#endif 
+#endif 
 
-	scb_val_t scbval;
+#if defined(CONFIG_BRCM_USE_GPIO_RESET) && !defined(CONFIG_BRCM_USE_DEEPSLEEP)
+#if defined(BCMLXSDMMC)
+		sdioh_stop(NULL);
+#endif
 
-	printk("Enter %s\n", __FUNCTION__);
-#ifdef SOFTAP
-	ap_cfg_running = FALSE;
-#endif /* SOFTAP */
 
-	if(g_onoff == G_WLAN_SET_ON){
-		g_onoff = G_WLAN_SET_OFF;
+		net_os_set_dtim_skip(dev, 0);
 
-		bzero(&scbval, sizeof(scb_val_t));
-		(void) dev_wlc_ioctl(dev, WLC_DISASSOC, &scbval, sizeof(scb_val_t));
+		dhd_customer_gpio_wlan_ctrl(WLAN_RESET_OFF);
+#endif /* CONFIG_BRCM_USE_GPIO_RESET */
 
+// 20110413 mingi.sung@lge.com [Wi-Fi] Patch for BELKIN AP - to succeed DHCP procedure after wakeup [START]
 #if defined(CONFIG_BRCM_LGE_WL_ARPOFFLOAD)
         do
         {   
@@ -1343,30 +1855,30 @@ wl_iw_control_wl_off(
             len = bcm_mkiovar("arp_hostip_clear", NULL, 0, buf, sizeof(buf));
             ASSERT(len);
 
+/*			if( (ret= dev_wlc_ioctl(dev, WLC_SET_VAR, buf, len)) < 0)
+				printk(KERN_ERR "%s:arp_hostip_clear failed.ret[%d]\n",\
+						__FUNCTION__, ret);
+*/
+
             dev_wlc_ioctl(dev, WLC_SET_VAR, buf, len);
-        } while(0);
-#endif //CONFIG_BRCM_LGE_WL_ARPOFFLOAD
 
-// LGE_CHANGE_S, [WiFi][ella.hwang@lge.com, moon-wifi@lge.com], 20120417, Wi-Fi driver skip start/stop cmd on ICS
+		} while(0);
+#endif //                             
+//                                                                                                       
+//                                                                                                               
 	#if !defined(CONFIG_LGE_BCM432X_PATCH)
 		wl_iw_send_priv_event(dev, "STOP");
 	#endif
-// LGE_CHANGE_E, [WiFi][ella.hwang@lge.com, moon-wifi@lge.com], 20120417, Wi-Fi driver skip start/stop cmd on ICS
-		
-		printk("Exit %s\n", __FUNCTION__);
+//                                                                                                               
 	}
-#endif
 
-	printk("Enter %s -5 \n", __FUNCTION__); 	
+	dhd_os_start_unlock(iw->pub);
 
+	WL_TRACE(("Exited %s\n", __FUNCTION__));
 
 	return ret;
 }
 
-#if defined(CONFIG_LGE_BCM432X_PATCH) && defined(CONFIG_BRCM_USE_GPIO_RESET)
-#include <linux/sched.h>
-#endif/* defined(CONFIG_LGE_BCM432X_PATCH) && defined(CONFIG_BRCM_USE_GPIO_RESET) */
-
 static int
 wl_iw_control_wl_on(
 	struct net_device *dev,
@@ -1377,40 +1889,14 @@ wl_iw_control_wl_on(
 
 	WL_TRACE(("Enter %s \n", __FUNCTION__));
 
-	if (g_onoff == G_WLAN_SET_OFF) {
-/* LGE_CHANGE_S, [yoohoo@lge.com], 2009-11-19, Use deepsleep instead of dhd_dev_reset when driver start or stop */
-#if defined(CONFIG_BRCM_USE_DEEPSLEEP)
-		/* Use Deep Sleep instead of WL RESET */
-		dhd_deep_sleep(dev, FALSE);
-#elif defined(CONFIG_BRCM_USE_GPIO_RESET)
-		dhd_customer_gpio_wlan_ctrl(WLAN_RESET_ON);
-
-#if defined(BCMLXSDMMC)
-		 sdioh_start(NULL, 0);
-#endif
-
-		dhd_dev_reset(dev, 0);
-
-#if defined(BCMLXSDMMC)
-		 sdioh_start(NULL, 1);
-#endif
-
-#if 0 // defined(CONFIG_LGE_BCM432X_PATCH) && defined(CONFIG_BRCM_USE_GPIO_RESET) // louislee : for ping+suspend(lcd off) error
-		 schedule_timeout((100*HZ)/1000);
-#endif	/* defined(CONFIG_LGE_BCM432X_PATCH) && defined(CONFIG_BRCM_USE_GPIO_RESET) */
-		 dhd_dev_init_ioctl(dev);
-#else	/* #elif defined(CONFIG_BRCM_USE_GPIO_RESET) */
-		g_onoff = G_WLAN_SET_ON;
-// LGE_CHANGE_S, [WiFi][ella.hwang@lge.com, moon-wifi@lge.com], 20120417, Wi-Fi driver skip start/stop cmd on ICS
-	#if !defined(CONFIG_LGE_BCM432X_PATCH)
-		wl_iw_send_priv_event(dev, "START");
-	#endif
-// LGE_CHANGE_E, [WiFi][ella.hwang@lge.com, moon-wifi@lge.com], 20120417, Wi-Fi driver skip start/stop cmd on ICS
-		printk("Exited %s \n", __FUNCTION__);
-#endif	/* CONFIG_BRCM_USE_DEEPSLEEP *//* Do not use GPIO Reset at On/Off. Use mpc. */
-/* LGE_CHANGE_E, [yoohoo@lge.com], 2009-11-19, Use deepsleep instead of dhd_dev_reset when driver start or stop */
-
-		g_onoff = G_WLAN_SET_ON;
+	if ((ret = wl_control_wl_start(dev)) == BCME_SDIO_ERROR) {
+		WL_ERROR(("%s failed first attemp\n", __FUNCTION__));
+		bcm_mdelay(100);
+		if ((ret = wl_control_wl_start(dev)) == BCME_SDIO_ERROR) {
+			WL_ERROR(("%s failed second attemp\n", __FUNCTION__));
+			net_os_send_hang_message(dev);
+			return ret;
+		}
 	}
 
 /* LGE_CHANGE_S [yoohoo@lge.com] 2009-07-09, send wl_iw_send_priv_event only if receiving regular START command */
@@ -1420,19 +1906,28 @@ wl_iw_control_wl_on(
 #endif /* CONFIG_LGE_BCM432X_PATCH */
 /* LGE_CHANGE_E [yoohoo@lge.com] 2009-07-09, send wl_iw_send_priv_event only if receiving regular START command */
 
+#ifdef SOFTAP
+	if (!ap_fw_loaded) {
+		wl_iw_iscan_set_scan_broadcast_prep(dev, 0);
+	}
+#else
+	wl_iw_iscan_set_scan_broadcast_prep(dev, 0);
+#endif
+//20110926 fmcine@lge.com, fixed reconnection issue when wakeup [START]
+	WL_TRACE(("%s : call net_os_set_suspend(resuming) \n", __FUNCTION__));
+	net_os_set_suspend(dev, 0);
+//20110926 fmcine@lge.com, fixed reconnection issue when wakeup [END]
 	WL_TRACE(("Exited %s \n", __FUNCTION__));
 
 	return ret;
 }
-
 #if defined(CONFIG_LGE_BCM432X_PATCH) && defined(SOFTAP)
 int
-wl_control_wl_start_real(struct net_device *dev, int restart)
+wl_control_wl_start_softap(struct net_device *dev)
 {
 	int ret = 0;
 	wl_iw_t *iw;
-
-	WL_ERROR(("Enter %s (restarting: %d) \n", __FUNCTION__, restart));
+	WL_ERROR(("Enter %s \n", __FUNCTION__));
 
 	if (!dev) {
 		WL_ERROR(("%s: dev is null\n", __FUNCTION__));
@@ -1440,57 +1935,37 @@ wl_control_wl_start_real(struct net_device *dev, int restart)
 	}
 
 	iw = *(wl_iw_t **)netdev_priv(dev);
-//	MUTEX_LOCK(iw->pub);
-
-	if (g_onoff == G_WLAN_SET_OFF) {
-		if (restart) {
-		dhd_customer_gpio_wlan_ctrl(WLAN_RESET_ON);
-#if defined(BCMLXSDMMC)
-		sdioh_start(NULL, 0);
-#endif
 
-		dhd_dev_reset(dev, 0);
-
-#if defined(BCMLXSDMMC)
-		sdioh_start(NULL, 1);
-#endif
-
-		dhd_dev_init_ioctl(dev);
-		}
-		g_onoff = G_WLAN_SET_ON;
+	if (!iw) {
+		WL_ERROR(("%s: wl is null\n", __FUNCTION__));
+		return -1;
 	}
-	else if (restart) {
-		dhd_dev_reset(dev, 1);
-#if defined(BCMLXSDMMC)
-		sdioh_stop(NULL);
-#endif
-		dhd_customer_gpio_wlan_ctrl(WLAN_RESET_OFF);
+	dhd_os_start_lock(iw->pub);
 
-		bcm_mdelay(200); 
+	if (g_onoff == G_WLAN_SET_OFF) {
+		//dhd_customer_gpio_wlan_ctrl(WLAN_RESET_ON);	// 2012.03.05	fmcine@lge.com	WIFI tethering bring-up
 
-		dhd_customer_gpio_wlan_ctrl(WLAN_RESET_ON);
 #if defined(BCMLXSDMMC)
-		sdioh_start(NULL, 0);
+		//sdioh_start(NULL, 0);	// 2012.03.05	fmcine@lge.com	WIFI tethering bring-up
 #endif
 
 		dhd_dev_reset(dev, 0);
+		bcm_mdelay(700);  //20120313 sangjun.bae@lge.com SoftAp delay for not turning on soft ap
 
 #if defined(BCMLXSDMMC)
-		sdioh_start(NULL, 1);
+		//sdioh_start(NULL, 1);	// 2012.03.05	fmcine@lge.com	WIFI tethering bring-up
 #endif
 
+		dhd_dev_init_ioctl(dev);
+
+		g_onoff = G_WLAN_SET_ON;
+		wl_iw_send_priv_event(dev, "START");	// 2012.03.05	fmcine@lge.com	WIFI tethering bring-up
 	}
 	WL_ERROR(("Exited %s \n", __FUNCTION__));
 
-//	MUTEX_UNLOCK(iw->pub);
+	dhd_os_start_unlock(iw->pub);
 	return ret;
 }
-
-int
-wl_control_wl_start(struct net_device *dev) {
-       wl_control_wl_start_real(dev, false);
-}
-
 static int
 wl_iw_control_wl_off_softap(
 	struct net_device *dev,
@@ -1508,11 +1983,16 @@ wl_iw_control_wl_off_softap(
 	}
 
 	iw = *(wl_iw_t **)netdev_priv(dev);
-//	MUTEX_LOCK(iw->pub);
+	if (!iw) {
+		WL_ERROR(("%s: dev is null\n", __FUNCTION__));
+		return -1;
+	}
+	dhd_os_start_lock(iw->pub);
 
-//#ifdef SOFTAP
+#ifdef SOFTAP
 	ap_cfg_running = FALSE;
-//#endif /* SOFTAP */
+
+#endif 
 
 	if (g_onoff == G_WLAN_SET_ON) {
 		g_onoff = G_WLAN_SET_OFF;
@@ -1522,27 +2002,35 @@ wl_iw_control_wl_off_softap(
 #endif 
 
 		dhd_dev_reset(dev, 1);
+		bcm_mdelay(200); //20120313 sangjun.bae@lge.com SoftAp delay for not turning on soft ap
 
 #if defined(WL_IW_USE_ISCAN)
+		
+#if  !defined(CSCAN)
 		wl_iw_free_ss_cache();
 		wl_iw_run_ss_cache_timer(0);
 		memset(g_scan, 0, G_SCAN_RESULTS);
 		
 		g_ss_cache_ctrl.m_link_down = 1;
+#endif
 		g_scan_specified_ssid = 0;
 		
+#if defined(CONFIG_FIRST_SCAN)
+		
 		g_first_broadcast_scan = BROADCAST_SCAN_FIRST_IDLE;
+		g_first_counter_scans = 0;
+#endif 		
 #endif
 
 #if defined(BCMLXSDMMC)
-		sdioh_stop(NULL);
+		//sdioh_stop(NULL);	// 2012.03.05	fmcine@lge.com	WIFI tethering bring-up
 #endif
-		dhd_customer_gpio_wlan_ctrl(WLAN_RESET_OFF);
-
+		//dhd_customer_gpio_wlan_ctrl(WLAN_RESET_OFF);	// 2012.03.05	fmcine@lge.com	WIFI tethering bring-up
 		wl_iw_send_priv_event(dev, "STOP");
+
 	}
 
-//	MUTEX_UNLOCK(iw->pub);
+	dhd_os_start_unlock(iw->pub);
 
 	WL_TRACE(("Exited %s\n", __FUNCTION__));
 
@@ -1559,9 +2047,25 @@ wl_iw_control_wl_on_softap(
 
 	WL_TRACE(("Enter %s \n", __FUNCTION__));
 
-	ret = wl_control_wl_start_real(dev, 1);
+	if ((ret = wl_control_wl_start_softap(dev)) == BCME_SDIO_ERROR) {
+		WL_ERROR(("%s failed first attemp\n", __FUNCTION__));
+		bcm_mdelay(100);
+		if ((ret = wl_control_wl_start_softap(dev)) == BCME_SDIO_ERROR) {
+			WL_ERROR(("%s failed second attemp\n", __FUNCTION__));
+			net_os_send_hang_message(dev);
+			return ret;
+		}
+	}
+	/* Modify not sending wl_iw_send_priv_event in wl_iw_control_wl_on() */
+	//wl_iw_send_priv_event(dev, "START");	// 2012.03.05	fmcine@lge.com	WIFI tethering bring-up
 
-	wl_iw_send_priv_event(dev, "START");
+#ifdef SOFTAP
+	if (!ap_fw_loaded) {
+		wl_iw_iscan_set_scan_broadcast_prep(dev, 0);
+	}
+#else
+	wl_iw_iscan_set_scan_broadcast_prep(dev, 0);
+#endif
 
 	WL_TRACE(("Exited %s \n", __FUNCTION__));
 
@@ -1573,7 +2077,7 @@ wl_iw_control_wl_on_softap(
 static struct ap_profile my_ap;
 static int set_ap_cfg(struct net_device *dev, struct ap_profile *ap); 
 static int get_assoc_sta_list(struct net_device *dev, char *buf, int len);
-static int set_ap_mac_list(struct net_device *dev, char *buf);
+static int set_ap_mac_list(struct net_device *dev, void *buf);
 
 #define PTYPE_STRING 0
 #define PTYPE_INTDEC 1   
@@ -1582,10 +2086,7 @@ static int set_ap_mac_list(struct net_device *dev, char *buf);
 int get_parmeter_from_string(
 	char **str_ptr, const char *token, int param_type, void  *dst, int param_max_len);
 
-#ifdef CONFIG_LGE_BCM432X_PATCH
-static int get_SSID_from_string(
-	char **str_ptr, const char *token, int param_type, void  *dst, int ssid_len);
-#endif /*CONFIG_LGE_BCM432X_PATCH*/
+#endif 
 
 int hex2num(char c)
 {
@@ -1629,14 +2130,88 @@ int hstr_2_buf(const char *txt, u8 *buf, int len)
 	return 0;
 }
 
+#if defined(SOFTAP) && defined(SOFTAP_TLV_CFG)
+
+static int wl_iw_softap_cfg_tlv(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+)
+{
+	int res = -1;
+	char *str_ptr;
+	int tlv_size_left;
+
+
+#define  SOFTAP_TLV_DEBUG  1
+#ifdef SOFTAP_TLV_DEBUG
+char softap_cmd_example[] = {
+	
+	'S', 'O', 'F', 'T', 'A', 'P', 'S', 'E', 'T', ' ',
+	
+	SOFTAP_TLV_PREFIX, SOFTAP_TLV_VERSION,
+	SOFTAP_TLV_SUBVERSION, SOFTAP_TLV_RESERVED,
+	
+	TLV_TYPE_SSID,		9, 'B', 'R', 'C', 'M', ',', 'G', 'O', 'O', 'G',
+	
+	TLV_TYPE_SECUR,		4, 'O', 'P', 'E', 'N',
+	
+	TLV_TYPE_KEY,		4, 0x31, 0x32, 0x33, 0x34,
+	
+	TLV_TYPE_CHANNEL,	4, 0x06, 0x00, 0x00, 0x00
+};
+#endif 
+
+
+#ifdef SOFTAP_TLV_DEBUG
+	{
+	int i;
+	if (!(extra = kmalloc(sizeof(softap_cmd_example) +10, GFP_KERNEL)))
+		return -ENOMEM;
+	memcpy(extra, softap_cmd_example, sizeof(softap_cmd_example));
+	wrqu->data.length = sizeof(softap_cmd_example);
+	print_buf(extra, wrqu->data.length, 16);
+	for (i = 0; i < wrqu->data.length; i++)
+		printf("%c ", extra[i]);
+	printf("\n");
+	}
+#endif 
+
+	WL_ERROR(("\n### %s: info->cmd:%x, info->flags:%x, u.data=0x%p, u.len=%d\n",
+		__FUNCTION__, info->cmd, info->flags,
+		wrqu->data.pointer, wrqu->data.length));
+
+	if (g_onoff == G_WLAN_SET_OFF) {
+		WL_TRACE(("%s: driver is not up yet after START\n", __FUNCTION__));
+		return -1;
+	}
+
+	
+	if (wrqu->data.length < (strlen(SOFTAP_SET_CMD) + sizeof(cmd_tlv_t))) {
+		WL_ERROR(("%s argument=%d  less %d\n", __FUNCTION__,
+			wrqu->data.length, strlen(SOFTAP_SET_CMD) + sizeof(cmd_tlv_t)));
+		return -1;
+	}
+
+	
+	str_ptr =  extra + strlen(SOFTAP_SET_CMD)+1; 
+	tlv_size_left = wrqu->data.length - (strlen(SOFTAP_SET_CMD)+1);
+
+	
+	memset(&my_ap, 0, sizeof(my_ap));
+
+	return res;
+}
+#endif
+
+
+#ifdef SOFTAP
 int init_ap_profile_from_string(char *param_str, struct ap_profile *ap_cfg)
 {
 	char *str_ptr = param_str;
 	char sub_cmd[16];
 	int ret = 0;
-#ifdef CONFIG_LGE_BCM432X_PATCH
-	uint32 ssid_len;
-#endif
 
 	memset(sub_cmd, 0, sizeof(sub_cmd));
 	memset(ap_cfg, 0, sizeof(struct ap_profile));
@@ -1650,12 +2225,8 @@ int init_ap_profile_from_string(char *param_str, struct ap_profile *ap_cfg)
 		return -1;
 	}
 
-#ifdef CONFIG_LGE_BCM432X_PATCH
-	ret = get_parmeter_from_string(&str_ptr, "SSIDLEN=", PTYPE_INTDEC, &ssid_len, 5);
-	if(ret == 0)
-		ret = get_SSID_from_string(&str_ptr, "SSID=", PTYPE_STRING, ap_cfg->ssid, ssid_len);
-	else
-#endif /*CONFIG_LGE_BCM432X_PATCH*/
+	
+	
 		ret = get_parmeter_from_string(&str_ptr, "SSID=", PTYPE_STRING, ap_cfg->ssid, SSID_LEN);
 
 	ret |= get_parmeter_from_string(&str_ptr, "SEC=", PTYPE_STRING,  ap_cfg->sec, SEC_LEN);
@@ -1664,13 +2235,27 @@ int init_ap_profile_from_string(char *param_str, struct ap_profile *ap_cfg)
 
 	ret |= get_parmeter_from_string(&str_ptr, "CHANNEL=", PTYPE_INTDEC, &ap_cfg->channel, 5);
 
-	ret |= get_parmeter_from_string(&str_ptr, "PREAMBLE=", PTYPE_INTDEC, &ap_cfg->preamble, 5);
 
-	ret |= get_parmeter_from_string(&str_ptr, "MAX_SCB=", PTYPE_INTDEC,  &ap_cfg->max_scb, 5);
+	get_parmeter_from_string(&str_ptr, "PREAMBLE=", PTYPE_INTDEC, &ap_cfg->preamble, 5);
+
+	
+	get_parmeter_from_string(&str_ptr, "MAX_SCB=", PTYPE_INTDEC,  &ap_cfg->max_scb, 5);
+
+	
+	get_parmeter_from_string(&str_ptr, "HIDDEN=",
+		PTYPE_INTDEC,  &ap_cfg->closednet, 5);
+
+	
+	get_parmeter_from_string(&str_ptr, "COUNTRY=",
+		PTYPE_STRING,  &ap_cfg->country_code, 3);
 
 	return ret;
 }
+#endif 
+
 
+
+#ifdef SOFTAP
 static int iwpriv_set_ap_config(struct net_device *dev,
             struct iw_request_info *info,
             union iwreq_data *wrqu,
@@ -1680,7 +2265,8 @@ static int iwpriv_set_ap_config(struct net_device *dev,
 	char  *extra = NULL;
 	struct ap_profile *ap_cfg = &my_ap;
 
-	WL_TRACE(("> Got IWPRIV SET_AP IOCTL: info->cmd:%x, info->flags:%x, u.data:%p, u.len:%d\n",
+	WL_TRACE(("%s: info->cmd:%x, info->flags:%x, u.data:%p, u.len:%d\n",
+		__FUNCTION__,
 		info->cmd, info->flags,
 		wrqu->data.pointer, wrqu->data.length));
 
@@ -1698,7 +2284,7 @@ static int iwpriv_set_ap_config(struct net_device *dev,
 		}
 
 		extra[wrqu->data.length] = 0;
-		WL_SOFTAP((" Got str param in iw_point:\n %s\n", extra));
+		WL_TRACE(("%s Got str param in iw_point:\n %s\n", __FUNCTION__, extra));
 
 		memset(ap_cfg, 0, sizeof(struct ap_profile));
 
@@ -1725,7 +2311,11 @@ static int iwpriv_set_ap_config(struct net_device *dev,
 
 	return res;
 }
+#endif 
+
 
+
+#ifdef SOFTAP
 static int iwpriv_get_assoc_list(struct net_device *dev,
         struct iw_request_info *info,
         union iwreq_data *p_iwrq,
@@ -1735,55 +2325,104 @@ static int iwpriv_get_assoc_list(struct net_device *dev,
 	char mac_buf[256];
 	struct maclist *sta_maclist = (struct maclist *)mac_buf;
 
-	char mac_lst[256];
+	char mac_lst[384];
 	char *p_mac_str;
+	char *p_mac_str_end;
+	wl_iw_t *iw;
+
+	if ((!dev) || (!extra)) {
+		
+		return -EINVAL;
+	}
+
+	iw = *(wl_iw_t **)netdev_priv(dev);
+	MUTEX_LOCK_SOFTAP_SET(iw->pub);
+	WAKE_LOCK_INIT(iw->pub, WAKE_LOCK_SOFTAP_SET, "SoftAP_assoc_list");
+	WAKE_LOCK(iw->pub, WAKE_LOCK_SOFTAP_SET);
 
 	WL_TRACE(("\n %s: IWPRIV IOCTL: cmd:%hx, flags:%hx, extra:%p, iwp.len:%d, \
 		iwp.len:%p, iwp.flags:%x  \n", __FUNCTION__, info->cmd, info->flags, \
 		extra, p_iwrq->data.length, p_iwrq->data.pointer, p_iwrq->data.flags));
 
-	WL_SOFTAP(("extra:%s\n", extra));
-	print_buf((u8 *)p_iwrq, 16, 0);
-
 	memset(sta_maclist, 0, sizeof(mac_buf));
 
 	sta_maclist->count = 8;
 
-	WL_TRACE((" net device:%s, buf_sz:%d\n", dev->name, sizeof(mac_buf)));
-	get_assoc_sta_list(dev, mac_buf, 256);
-	WL_TRACE((" got %d stations\n", sta_maclist->count));
+	WL_SOFTAP(("%s: net device:%s, buf_sz:%d\n",
+		__FUNCTION__, dev->name, sizeof(mac_buf)));
+
+	if ((ret = get_assoc_sta_list(dev, mac_buf, sizeof(mac_buf))) < 0) {
+		WL_ERROR(("%s: sta list ioctl error:%d\n",
+			__FUNCTION__, ret));
+		goto func_exit;
+	}
+
+	WL_SOFTAP(("%s: got %d stations\n", __FUNCTION__,
+		sta_maclist->count));
+
 
 	memset(mac_lst, 0, sizeof(mac_lst));
 	p_mac_str = mac_lst;
+	p_mac_str_end = &mac_lst[sizeof(mac_lst)-1];
 
 	for (i = 0; i < 8; i++) {
 		struct ether_addr * id = &sta_maclist->ea[i];
+		if (!ETHER_ISNULLADDR(id->octet)) {
+			scb_val_t scb_val;
+			int rssi = 0;
+			bzero(&scb_val, sizeof(scb_val_t));
+
 
-		WL_SOFTAP(("dhd_drv>> sta_mac[%d] :", i));
-		print_buf((unsigned char *)&sta_maclist->ea[i], 6, 0);
+			if ((p_mac_str_end - p_mac_str) <= 36) {
+				WL_ERROR(("%s: mac list buf is < 36 for item[%i] item\n",
+					__FUNCTION__, i));
+				break;
+			}
 
 		p_mac_str += snprintf(p_mac_str, MAX_WX_STRING,
-			"Mac[%d]=%02X:%02X:%02X:%02X:%02X:%02X\n", i,
+			"\nMac[%d]=%02X:%02X:%02X:%02X:%02X:%02X,", i,
 			id->octet[0], id->octet[1], id->octet[2],
 			id->octet[3], id->octet[4], id->octet[5]);
+
+			
+			bcopy(id->octet, &scb_val.ea, 6);
+			ret = dev_wlc_ioctl(dev, WLC_GET_RSSI, &scb_val, sizeof(scb_val_t));
+			if (ret  < 0) {
+				snprintf(p_mac_str, MAX_WX_STRING, "RSSI:ERR");
+				WL_ERROR(("%s: RSSI ioctl error:%d\n",
+					__FUNCTION__, ret));
+				break;
+			}
+
+			rssi = dtoh32(scb_val.val);
+			p_mac_str += snprintf(p_mac_str, MAX_WX_STRING,
+			"RSSI:%d", rssi);
+		}
 	}
 
-	p_iwrq->data.length = strlen(mac_lst);
+	p_iwrq->data.length = strlen(mac_lst)+1; 
 
-	WL_TRACE(("u.pointer:%p\n", p_iwrq->data.pointer));
-	WL_TRACE(("resulting str:\n%s \n len:%d\n\n", mac_lst, p_iwrq->data.length));
+	WL_SOFTAP(("%s: data to user:\n%s\n usr_ptr:%p\n", __FUNCTION__,
+		mac_lst, p_iwrq->data.pointer));
 
 	if (p_iwrq->data.length) {
-		if (copy_to_user(p_iwrq->data.pointer, mac_lst, p_iwrq->data.length)) {
-			WL_ERROR(("%s: Can't copy to user\n", __FUNCTION__));
-			return -EFAULT;
-		}
+		bcopy(mac_lst, extra, p_iwrq->data.length);
 	}
 
-	WL_ERROR(("Exited %s \n", __FUNCTION__));
+func_exit:
+	WAKE_UNLOCK(iw->pub, WAKE_LOCK_SOFTAP_SET);
+	WAKE_LOCK_DESTROY(iw->pub, WAKE_LOCK_SOFTAP_SET);
+	MUTEX_UNLOCK_SOFTAP_SET(iw->pub);
+
+	WL_SOFTAP(("%s: Exited\n", __FUNCTION__));
 	return ret;
 }
+#endif 
 
+
+#ifdef SOFTAP
+
+#define MAC_FILT_MAX 8
 static int iwpriv_set_mac_filters(struct net_device *dev,
         struct iw_request_info *info,
         union iwreq_data *wrqu,
@@ -1791,11 +2430,12 @@ static int iwpriv_set_mac_filters(struct net_device *dev,
 {
 	int i, ret = -1;
 	char  * extra = NULL;
-	u8  macfilt[8][6];
 	int mac_cnt = 0; 
-	char sub_cmd[16];
+	int mac_mode = 0;
+	struct ether_addr *p_ea;
+	struct mac_list_set mflist_set; 
 
-	WL_TRACE((">>> Got IWPRIV SET_MAC_FILTER IOCTL:  info->cmd:%x, \
+	WL_SOFTAP((">>> Got IWPRIV SET_MAC_FILTER IOCTL:  info->cmd:%x, \
 			info->flags:%x, u.data:%p, u.len:%d\n",
 			info->cmd, info->flags,
 			wrqu->data.pointer, wrqu->data.length));
@@ -1815,25 +2455,24 @@ static int iwpriv_set_mac_filters(struct net_device *dev,
 		extra[wrqu->data.length] = 0;
 		WL_SOFTAP((" Got parameter string in iw_point:\n %s \n", extra));
 
-		memset(macfilt, 0, sizeof(macfilt));
-		memset(sub_cmd, 0, sizeof(sub_cmd));
+		memset(&mflist_set, 0, sizeof(mflist_set));
+
 
 		str_ptr = extra;
 
-		if (get_parmeter_from_string(&str_ptr, "ASCII_CMD=", PTYPE_STRING, sub_cmd, 15) != 0) {
-			goto exit_proc;
-		}
 
-#define MAC_FILT_MAX 8
 	   
-		if (strncmp(sub_cmd, "MAC_FLT_W", strlen("MAC_FLT_W"))) {
-		   WL_ERROR(("ERROR: sub_cmd:%s != 'MAC_FLT_W'!\n", sub_cmd));
+		if (get_parmeter_from_string(&str_ptr, "MAC_MODE=",
+			PTYPE_INTDEC, &mac_mode, 4) != 0) {
+			WL_ERROR(("ERROR: 'MAC_MODE=' token is missing\n"));
 			goto exit_proc;
 		}
 
+		p_ea = &mflist_set.mac_list.ea[0];
+
 		if (get_parmeter_from_string(&str_ptr, "MAC_CNT=",
 			PTYPE_INTDEC, &mac_cnt, 4) != 0) {
-			WL_ERROR(("ERROR: MAC_CNT param is missing \n"));
+			WL_ERROR(("ERROR: 'MAC_CNT=' token param is missing \n"));
 			goto exit_proc;
 		}
 
@@ -1844,16 +2483,23 @@ static int iwpriv_set_mac_filters(struct net_device *dev,
 
 		for (i=0; i< mac_cnt; i++)	
 		if (get_parmeter_from_string(&str_ptr, "MAC=",
-			PTYPE_STR_HEX, macfilt[i], 12) != 0) {
+			PTYPE_STR_HEX, &p_ea[i], 12) != 0) {
 			WL_ERROR(("ERROR: MAC_filter[%d] is missing !\n", i));
 			goto exit_proc;
 		}
 
+		WL_SOFTAP(("MAC_MODE=:%d, MAC_CNT=%d, MACs:..\n", mac_mode, mac_cnt));
 		for (i = 0; i < mac_cnt; i++) {
 		   WL_SOFTAP(("mac_filt[%d]:", i));
-		   print_buf(macfilt[i], 6, 0);
+		   print_buf(&p_ea[i], 6, 0);
 		}
 
+		
+		mflist_set.mode = mac_mode;
+		mflist_set.mac_list.count = mac_cnt;
+		set_ap_mac_list(dev, &mflist_set);
+
+		
 		wrqu->data.pointer = NULL;
 		wrqu->data.length = 0;
 		ret = 0;
@@ -1866,10 +2512,46 @@ static int iwpriv_set_mac_filters(struct net_device *dev,
 	kfree(extra);
 	return ret;
 }
-#endif /* SOFTAP */
-
 #endif 
 
+
+#ifdef SOFTAP
+
+static int iwpriv_set_ap_sta_disassoc(struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *ext)
+{
+	int res = 0;
+	char sta_mac[6] = {0, 0, 0, 0, 0, 0};
+	char cmd_buf[256];
+	char *str_ptr = cmd_buf;
+
+	WL_SOFTAP((">>%s called\n args: info->cmd:%x,"
+		" info->flags:%x, u.data.p:%p, u.data.len:%d\n",
+		__FUNCTION__, info->cmd, info->flags,
+		wrqu->data.pointer, wrqu->data.length));
+
+	if (wrqu->data.length != 0) {
+
+		if (copy_from_user(cmd_buf, wrqu->data.pointer, wrqu->data.length)) {
+			return -EFAULT;
+		}
+
+		if (get_parmeter_from_string(&str_ptr,
+			"MAC=", PTYPE_STR_HEX, sta_mac, 12) == 0) {
+			res = wl_iw_softap_deassoc_stations(dev, sta_mac);
+		} else  {
+			WL_ERROR(("ERROR: STA_MAC= token not found\n"));
+		}
+	}
+
+	return res;
+}
+#endif 
+#endif 
+
+
 #if WIRELESS_EXT < 13
 struct iw_request_info
 {
@@ -1877,8 +2559,10 @@ struct iw_request_info
 	__u16		flags;		
 };
 
-typedef int (*iw_handler)(struct net_device *dev, struct iw_request_info *info,
-	void *wrqu, char *extra);
+typedef int (*iw_handler)(struct net_device *dev,
+                struct iw_request_info *info,
+                void *wrqu,
+                char *extra);
 #endif 
 
 static int
@@ -1895,10 +2579,6 @@ wl_iw_config_commit(
 
 	WL_TRACE(("%s: SIOCSIWCOMMIT\n", dev->name));
 
-// WBT Fix TD# 37078
-	memset(&ssid, 0, sizeof(wlc_ssid_t));
-//
-
 	if ((error = dev_wlc_ioctl(dev, WLC_GET_SSID, &ssid, sizeof(ssid))))
 		return error;
 
@@ -1909,7 +2589,7 @@ wl_iw_config_commit(
 
 	bzero(&bssid, sizeof(struct sockaddr));
 	if ((error = dev_wlc_ioctl(dev, WLC_REASSOC, &bssid, ETHER_ADDR_LEN))) {
-		WL_ERROR(("Invalid ioctl data.\n"));
+		WL_ERROR(("%s: WLC_REASSOC to %s failed \n", __FUNCTION__, ssid.SSID));
 		return error;
 	}
 
@@ -1942,14 +2622,15 @@ wl_iw_set_freq(
 	int error, chan;
 	uint sf = 0;
 
-	WL_TRACE(("%s: SIOCSIWFREQ\n", dev->name));
+	WL_TRACE(("\n %s %s: SIOCSIWFREQ\n", __FUNCTION__, dev->name));
 
 #if defined(SOFTAP)
 	if (ap_cfg_running) {
 		WL_TRACE(("%s:>> not executed, 'SOFT_AP is active' \n", __FUNCTION__));
 		return 0;
 	}
-#endif /* SOFTAP */
+#endif
+
 	
 	if (fwrq->e == 0 && fwrq->m < MAXCHANNEL) {
 		chan = fwrq->m;
@@ -1976,6 +2657,7 @@ wl_iw_set_freq(
 	if ((error = dev_wlc_ioctl(dev, WLC_SET_CHANNEL, &chan, sizeof(chan))))
 		return error;
 
+	g_wl_iw_params.target_channel = chan;
 	
 	return -EINPROGRESS;
 }
@@ -1991,10 +2673,6 @@ wl_iw_get_freq(
 	channel_info_t ci;
 	int error;
 
-// WBT Fix TD# 37079
-	memset(&ci, 0, sizeof(channel_info_t));
-//
-
 	WL_TRACE(("%s: SIOCGIWFREQ\n", dev->name));
 
 	if ((error = dev_wlc_ioctl(dev, WLC_GET_CHANNEL, &ci, sizeof(ci))))
@@ -2074,18 +2752,15 @@ wl_iw_get_range(
 )
 {
 	struct iw_range *range = (struct iw_range *) extra;
-	int channels[MAXCHANNEL+1];
-	wl_uint32_list_t *list = (wl_uint32_list_t *) channels;
+	wl_uint32_list_t *list;
 	wl_rateset_t rateset;
+	int8 *channels;
 	int error, i, k;
 	uint sf, ch;
 
-// WBT Fix TD# 37082
-	int phytype = 0;
-//
-	uint8 bw_cap = 0, sgi_tx = 0, nmode = 0;
+	int phytype;
+	int bw_cap = 0, sgi_tx = 0, nmode = 0;
 	channel_info_t ci;
-	char iovar_buf[4];
 	uint8 nrate_list2copy = 0;
 	uint16 nrate_list[4][8] = { {13, 26, 39, 52, 78, 104, 117, 130}, 
 		{14, 29, 43, 58, 87, 116, 130, 144}, 
@@ -2097,22 +2772,25 @@ wl_iw_get_range(
 	if (!extra)
 		return -EINVAL;
 
+	channels = kmalloc((MAXCHANNEL+1)*4, GFP_KERNEL);
+	if (!channels) {
+		WL_ERROR(("Could not alloc channels\n"));
+		return -ENOMEM;
+	}
+	list = (wl_uint32_list_t *)channels;
+
 	dwrq->length = sizeof(struct iw_range);
 	memset(range, 0, sizeof(range));
 
-// WBT Fix TD# 37080, 37081
-	memset(&rateset, 0, sizeof(wl_rateset_t));
-//
-// WBT Fix TD# 37083
-	memset(&ci, 0, sizeof(channel_info_t));
-//
 	
 	range->min_nwid = range->max_nwid = 0;
 
 	
 	list->count = htod32(MAXCHANNEL);
-	if ((error = dev_wlc_ioctl(dev, WLC_GET_VALID_CHANNELS, channels, sizeof(channels))))
+	if ((error = dev_wlc_ioctl(dev, WLC_GET_VALID_CHANNELS, channels, (MAXCHANNEL+1)*4))) {
+		kfree(channels);
 		return error;
+	}
 	for (i = 0; i < dtoh32(list->count) && i < IW_MAX_FREQUENCIES; i++) {
 		range->freq[i].i = dtoh32(list->element[i]);
 
@@ -2146,32 +2824,32 @@ wl_iw_get_range(
 #endif 
 
 	
-	if ((error = dev_wlc_ioctl(dev, WLC_GET_CURR_RATESET, &rateset, sizeof(rateset))))
+	if ((error = dev_wlc_ioctl(dev, WLC_GET_CURR_RATESET, &rateset, sizeof(rateset)))) {
+		kfree(channels);
 		return error;
+	}
 	rateset.count = dtoh32(rateset.count);
 	range->num_bitrates = rateset.count;
 	for (i = 0; i < rateset.count && i < IW_MAX_BITRATES; i++)
 		range->bitrate[i] = (rateset.rates[i]& 0x7f) * 500000; 
-	dev_wlc_bufvar_get(dev, "nmode", iovar_buf, sizeof(iovar_buf));
-	nmode = iovar_buf[0];
-
-	if (nmode == 1) {
-		dev_wlc_bufvar_get(dev, "mimo_bw_cap", iovar_buf, sizeof(iovar_buf));
-		bw_cap = iovar_buf[0];
-		dev_wlc_bufvar_get(dev, "sgi_tx", iovar_buf, sizeof(iovar_buf));
-		sgi_tx = iovar_buf[0];
+	dev_wlc_intvar_get(dev, "nmode", &nmode);
+	dev_wlc_ioctl(dev, WLC_GET_PHYTYPE, &phytype, sizeof(phytype));
+
+	if (nmode == 1 && phytype == WLC_PHY_TYPE_SSN) {
+		dev_wlc_intvar_get(dev, "mimo_bw_cap", &bw_cap);
+		dev_wlc_intvar_get(dev, "sgi_tx", &sgi_tx);
 		dev_wlc_ioctl(dev, WLC_GET_CHANNEL, &ci, sizeof(channel_info_t));
 		ci.hw_channel = dtoh32(ci.hw_channel);
-		dev_wlc_ioctl(dev, WLC_GET_PHYTYPE, &phytype, sizeof(phytype));
-		if (phytype == WLC_PHY_TYPE_SSN && (bw_cap == 0 ||
-			(bw_cap == 2 && ci.hw_channel <= 14))) {
+
+		if (bw_cap == 0 ||
+			(bw_cap == 2 && ci.hw_channel <= 14)) {
 			if (sgi_tx == 0)
 				nrate_list2copy = 0;
 			else
 				nrate_list2copy = 1;
 		}
-		if (phytype == WLC_PHY_TYPE_SSN && (bw_cap == 1 ||
-			(bw_cap == 2 && ci.hw_channel > 14))) {
+		if (bw_cap == 1 ||
+			(bw_cap == 2 && ci.hw_channel >= 36)) {
 			if (sgi_tx == 0)
 				nrate_list2copy = 2;
 			else
@@ -2185,8 +2863,10 @@ wl_iw_get_range(
 	}
 
 	
-	if ((error = dev_wlc_ioctl(dev, WLC_GET_PHYTYPE, &i, sizeof(i))))
+	if ((error = dev_wlc_ioctl(dev, WLC_GET_PHYTYPE, &i, sizeof(i)))) {
+		kfree(channels);
 		return error;
+	}
 	i = dtoh32(i);
 	if (i == WLC_PHY_TYPE_A)
 		range->throughput = 24000000;	
@@ -2259,6 +2939,8 @@ wl_iw_get_range(
 #endif
 #endif 
 
+	kfree(channels);
+
 	return 0;
 }
 
@@ -2333,6 +3015,43 @@ wl_iw_get_spy(
 	return 0;
 }
 
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+static int
+wl_iw_ch_to_chanspec(int ch, wl_join_params_t *join_params, int *join_params_size)
+{
+	chanspec_t chanspec = 0;
+
+	if (ch != 0) {
+		
+		join_params->params.chanspec_num = 1;
+		join_params->params.chanspec_list[0] = ch;
+
+		if (join_params->params.chanspec_list[0])
+			chanspec |= WL_CHANSPEC_BAND_2G;
+		else
+			chanspec |= WL_CHANSPEC_BAND_5G;
+
+		chanspec |= WL_CHANSPEC_BW_20;
+		chanspec |= WL_CHANSPEC_CTL_SB_NONE;
+
+		
+		*join_params_size += WL_ASSOC_PARAMS_FIXED_SIZE +
+			join_params->params.chanspec_num * sizeof(chanspec_t);
+
+		
+		join_params->params.chanspec_list[0]  &= WL_CHANSPEC_CHAN_MASK;
+		join_params->params.chanspec_list[0] |= chanspec;
+		join_params->params.chanspec_list[0] =
+		        htodchanspec(join_params->params.chanspec_list[0]);
+
+		join_params->params.chanspec_num = htod32(join_params->params.chanspec_num);
+
+		WL_TRACE(("%s  join_params->params.chanspec_list[0]= %X\n", \
+			__FUNCTION__, join_params->params.chanspec_list[0]));
+	}
+	return 1;
+}
+#endif
 static int
 wl_iw_set_wap(
 	struct net_device *dev,
@@ -2343,6 +3062,7 @@ wl_iw_set_wap(
 {
 	int error = -EINVAL;
 	wl_join_params_t join_params;
+	int join_params_size;
 
 	WL_TRACE(("%s: SIOCSIWAP\n", dev->name));
 
@@ -2356,21 +3076,35 @@ wl_iw_set_wap(
 		scb_val_t scbval;
 		
 		bzero(&scbval, sizeof(scb_val_t));
-		dev_wlc_ioctl(dev, WLC_DISASSOC, &scbval, sizeof(scb_val_t));
+		
+		(void) dev_wlc_ioctl(dev, WLC_DISASSOC, &scbval, sizeof(scb_val_t));
 		return 0;
 	}
 
 
 	
 	memset(&join_params, 0, sizeof(join_params));
+	join_params_size = sizeof(join_params.ssid);
 
 	memcpy(join_params.ssid.SSID, g_ssid.SSID, g_ssid.SSID_len);
 	join_params.ssid.SSID_len = htod32(g_ssid.SSID_len);
 	memcpy(&join_params.params.bssid, awrq->sa_data, ETHER_ADDR_LEN);
 
-	if ((error = dev_wlc_ioctl(dev, WLC_SET_SSID, &join_params, sizeof(join_params)))) {
-		WL_ERROR(("Invalid ioctl data.\n"));
-		return error;
+	
+	
+	WL_ASSOC(("%s  target_channel=%d\n", __FUNCTION__, g_wl_iw_params.target_channel));
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+	wl_iw_ch_to_chanspec(g_wl_iw_params.target_channel, &join_params, &join_params_size);
+#endif
+
+	if ((error = dev_wlc_ioctl(dev, WLC_SET_SSID, &join_params, join_params_size))) {
+		WL_ERROR(("%s Invalid ioctl data=%d\n", __FUNCTION__, error));
+	}
+
+	if (g_ssid.SSID_len) {
+		WL_ASSOC(("%s: join SSID=%s BSSID="MACSTR" ch=%d\n", __FUNCTION__,  \
+			g_ssid.SSID, MAC2STR((u8 *)awrq->sa_data), \
+			g_wl_iw_params.target_channel));
 	}
 
 	
@@ -2439,6 +3173,7 @@ wl_iw_mlme(
 }
 #endif 
 
+#ifndef WL_IW_USE_ISCAN
 static int
 wl_iw_get_aplist(
 	struct net_device *dev,
@@ -2473,13 +3208,22 @@ wl_iw_get_aplist(
 	list->buflen = dtoh32(list->buflen);
 	list->version = dtoh32(list->version);
 	list->count = dtoh32(list->count);
-	ASSERT(list->version == WL_BSS_INFO_VERSION);
+	if (list->version != WL_BSS_INFO_VERSION) {
+		WL_ERROR(("%s : list->version %d != WL_BSS_INFO_VERSION\n", \
+			 __FUNCTION__, list->version));
+		kfree(list);
+		return -EINVAL;
+	}
 
 	for (i = 0, dwrq->length = 0; i < list->count && dwrq->length < IW_MAX_AP; i++) {
 		bi = bi ? (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length)) : list->bss_info;
-		ASSERT(((uintptr)bi + dtoh32(bi->length)) <= ((uintptr)list +
-			buflen));
-
+		if ((dtoh32(bi->length) > buflen) ||
+		    (((uintptr)bi + dtoh32(bi->length)) > ((uintptr)list + buflen))) {
+			WL_ERROR(("%s: Scan results out of bounds: %u\n", \
+					  __FUNCTION__, dtoh32(bi->length)));
+			kfree(list);
+			return -E2BIG;
+		}
 		
 		if (!(dtoh16(bi->capability) & DOT11_CAP_ESS))
 			continue;
@@ -2511,10 +3255,11 @@ wl_iw_get_aplist(
 
 	return 0;
 }
+#endif 
 
-#if defined(WL_IW_USE_ISCAN) || defined(WL_IW_USE_ESCAN)
+#ifdef WL_IW_USE_ISCAN
 static int
-wl_iw_scan_get_aplist(
+wl_iw_iscan_get_aplist(
 	struct net_device *dev,
 	struct iw_request_info *info,
 	struct iw_point *dwrq,
@@ -2522,10 +3267,8 @@ wl_iw_scan_get_aplist(
 )
 {
 	wl_scan_results_t *list;
-#if defined(WL_IW_USE_ISCAN)
 	iscan_buf_t * buf;
 	iscan_info_t *iscan = g_iscan;
-#endif
 
 	struct sockaddr *addr = (struct sockaddr *) extra;
 	struct iw_quality qual[IW_MAX_AP];
@@ -2534,40 +3277,36 @@ wl_iw_scan_get_aplist(
 
 	WL_TRACE(("%s: SIOCGIWAPLIST\n", dev->name));
 
-// WBT Fix TD# 37084
-	memset(qual, 0, sizeof(struct iw_quality) * IW_MAX_AP);
-//
-
 	if (!extra)
 		return -EINVAL;
 
-#if defined(WL_IW_USE_ISCAN)
-	if ((!iscan) || (iscan->sysioc_pid < 0)) {
-#elif defined(WL_IW_USE_ESCAN)
-	if (!g_escan) {
-#endif
-		return wl_iw_get_aplist(dev, info, dwrq, extra);
+//	if ((!iscan) || (iscan->sysioc_pid < 0)) {
+	if ((!iscan) || (iscan->tsk_ctl.thr_pid < 0)) {
+		WL_ERROR(("%s error\n", __FUNCTION__));
+		return 0;
 	}
 
-#if defined(WL_IW_USE_ISCAN)
 	buf = iscan->list_hdr;
 	
 	while (buf) {
 		list = &((wl_iscan_results_t*)buf->iscan_buf)->results;
-		ASSERT(list->version == WL_BSS_INFO_VERSION);
-#elif defined(WL_IW_USE_ESCAN)
-	{
-		list = (wl_scan_results_t *) g_escan->escan_buf;
-#endif
+		if (list->version != WL_BSS_INFO_VERSION) {
+			WL_ERROR(("%s : list->version %d != WL_BSS_INFO_VERSION\n", \
+				__FUNCTION__, list->version));
+			return -EINVAL;
+		}
 
 		bi = NULL;
 		for (i = 0, dwrq->length = 0; i < list->count && dwrq->length < IW_MAX_AP; i++) {
 			bi = bi ? (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length))
 			          : list->bss_info;
-#if defined(WL_IW_USE_ISCAN)
-			ASSERT(((uintptr)bi + dtoh32(bi->length)) <= ((uintptr)list +
-				WLC_IW_ISCAN_MAXLEN));
-#endif
+			if ((dtoh32(bi->length) > WLC_IW_ISCAN_MAXLEN) ||
+				(((uintptr)bi + dtoh32(bi->length)) > \
+				((uintptr)list + WLC_IW_ISCAN_MAXLEN))) {
+				WL_ERROR(("%s: Scan results out of bounds: %u\n", \
+					__FUNCTION__, dtoh32(bi->length)));
+				return -E2BIG;
+			}
 
 			
 			if (!(dtoh16(bi->capability) & DOT11_CAP_ESS))
@@ -2589,9 +3328,7 @@ wl_iw_scan_get_aplist(
 
 			dwrq->length++;
 		}
-#if defined(WL_IW_USE_ISCAN)
 		buf = buf->next;
-#endif
 	}
 	if (dwrq->length) {
 		memcpy(&addr[dwrq->length], qual, sizeof(struct iw_quality) * dwrq->length);
@@ -2603,7 +3340,7 @@ wl_iw_scan_get_aplist(
 }
 
 static int
-wl_iw_scan_prep(wl_scan_params_t *params, wlc_ssid_t *ssid)
+wl_iw_iscan_prep(wl_scan_params_t *params, wlc_ssid_t *ssid)
 {
 	int err = 0;
 
@@ -2616,6 +3353,11 @@ wl_iw_scan_prep(wl_scan_params_t *params, wlc_ssid_t *ssid)
 	params->home_time = -1;
 	params->channel_num = 0;
 
+#if defined(CONFIG_FIRST_SCAN)
+	
+	if (g_first_broadcast_scan == BROADCAST_SCAN_FIRST_STARTED)
+		params->passive_time = 30;
+#endif 
 	params->nprobes = htod32(params->nprobes);
 	params->active_time = htod32(params->active_time);
 	params->passive_time = htod32(params->passive_time);
@@ -2625,39 +3367,30 @@ wl_iw_scan_prep(wl_scan_params_t *params, wlc_ssid_t *ssid)
 
 	return err;
 }
-#endif 
 
-#if defined(WL_IW_USE_ISCAN)
+
 static int
 wl_iw_iscan(iscan_info_t *iscan, wlc_ssid_t *ssid, uint16 action)
 {
-	int params_size = (WL_SCAN_PARAMS_FIXED_SIZE + OFFSETOF(wl_iscan_params_t, params));
-	wl_iscan_params_t *params;
 	int err = 0;
 
-	if (ssid && ssid->SSID_len) {
-		params_size += sizeof(wlc_ssid_t);
-	}
-	params = (wl_iscan_params_t*)kmalloc(params_size, GFP_KERNEL);
-	if (params == NULL) {
-		return -ENOMEM;
-	}
-	memset(params, 0, params_size);
-	ASSERT(params_size < WLC_IOCTL_SMLEN);
-
-	err = wl_iw_scan_prep(&params->params, ssid);
+	iscan->iscan_ex_params_p->version = htod32(ISCAN_REQ_VERSION);
+	iscan->iscan_ex_params_p->action = htod16(action);
+	iscan->iscan_ex_params_p->scan_duration = htod16(0);
 
-	if (!err) {
-		params->version = htod32(ISCAN_REQ_VERSION);
-		params->action = htod16(action);
-		params->scan_duration = htod16(0);
+	WL_SCAN(("%s : nprobes=%d\n", __FUNCTION__, iscan->iscan_ex_params_p->params.nprobes));
+	WL_SCAN(("active_time=%d\n", iscan->iscan_ex_params_p->params.active_time));
+	WL_SCAN(("passive_time=%d\n", iscan->iscan_ex_params_p->params.passive_time));
+	WL_SCAN(("home_time=%d\n", iscan->iscan_ex_params_p->params.home_time));
+	WL_SCAN(("scan_type=%d\n", iscan->iscan_ex_params_p->params.scan_type));
+	WL_SCAN(("bss_type=%d\n", iscan->iscan_ex_params_p->params.bss_type));
 
-		
-		(void) dev_iw_iovar_setbuf(iscan->dev, "iscan", params, params_size,
-			iscan->ioctlbuf, WLC_IOCTL_SMLEN);
+	if ((err = dev_iw_iovar_setbuf(iscan->dev, "iscan", iscan->iscan_ex_params_p, \
+		iscan->iscan_ex_param_size, iscan->ioctlbuf, sizeof(iscan->ioctlbuf)))) {
+			WL_ERROR(("Set ISCAN for %s failed with %d\n", __FUNCTION__, err));
+			err = -1;
 	}
 
-	kfree(params);
 	return err;
 }
 
@@ -2669,13 +3402,11 @@ wl_iw_timerfunc(ulong data)
 		iscan->timer_on = 0;
 		if (iscan->iscan_state != ISCAN_STATE_IDLE) {
 			WL_TRACE(("timer trigger\n"));
-			up(&iscan->sysioc_sem);
+//			up(&iscan->sysioc_sem);
+			up(&iscan->tsk_ctl.sema);
 		}
 	}
 }
-#endif 
-
-#if defined(WL_IW_USE_ISCAN) || defined(WL_IW_USE_ESCAN)
 static void wl_iw_set_event_mask(struct net_device *dev)
 {
 	char eventmask[WL_EVENTING_MASK_LEN];
@@ -2683,17 +3414,11 @@ static void wl_iw_set_event_mask(struct net_device *dev)
 
 	dev_iw_iovar_getbuf(dev, "event_msgs", "", 0, iovbuf, sizeof(iovbuf));
 	bcopy(iovbuf, eventmask, WL_EVENTING_MASK_LEN);
-#if defined(WL_IW_USE_ISCAN)
 	setbit(eventmask, WLC_E_SCAN_COMPLETE);
-#elif defined(WL_IW_USE_ESCAN)
-	setbit(eventmask, WLC_E_ESCAN_RESULT);
-#endif
 	dev_iw_iovar_setbuf(dev, "event_msgs", eventmask, WL_EVENTING_MASK_LEN,
 		iovbuf, sizeof(iovbuf));
 }
-#endif 
 
-#if defined(WL_IW_USE_ISCAN)
 static uint32
 wl_iw_iscan_get(iscan_info_t *iscan)
 {
@@ -2703,16 +3428,22 @@ wl_iw_iscan_get(iscan_info_t *iscan)
 	wl_iscan_results_t list;
 	wl_scan_results_t *results;
 	uint32 status;
+	int res = 0;
 
 	
+	MUTEX_LOCK_WL_SCAN_SET();
 	if (iscan->list_cur) {
 		buf = iscan->list_cur;
 		iscan->list_cur = buf->next;
 	}
 	else {
 		buf = kmalloc(sizeof(iscan_buf_t), GFP_KERNEL);
-		if (!buf)
-			return WL_SCAN_RESULTS_ABORTED;
+		if (!buf) {
+			WL_ERROR(("%s can't alloc iscan_buf_t : going to abort currect iscan\n", \
+						__FUNCTION__));
+			MUTEX_UNLOCK_WL_SCAN_SET();
+			return WL_SCAN_RESULTS_NO_MEM;
+		}
 		buf->next = NULL;
 		if (!iscan->list_hdr)
 			iscan->list_hdr = buf;
@@ -2733,53 +3464,97 @@ wl_iw_iscan_get(iscan_info_t *iscan)
 
 	memset(&list, 0, sizeof(list));
 	list.results.buflen = htod32(WLC_IW_ISCAN_MAXLEN);
-	(void) dev_iw_iovar_getbuf(
+	res = dev_iw_iovar_getbuf(
 		iscan->dev,
 		"iscanresults",
 		&list,
 		WL_ISCAN_RESULTS_FIXED_SIZE,
 		buf->iscan_buf,
 		WLC_IW_ISCAN_MAXLEN);
+	if (res == 0) {
 	results->buflen = dtoh32(results->buflen);
 	results->version = dtoh32(results->version);
 	results->count = dtoh32(results->count);
 	WL_TRACE(("results->count = %d\n", results->count));
-
 	WL_TRACE(("results->buflen = %d\n", results->buflen));
 	status = dtoh32(list_buf->status);
+	}
+	else {
+		WL_ERROR(("%s returns error %d\n", __FUNCTION__, res));
+		
+		status = WL_SCAN_RESULTS_NO_MEM;
+	}
+	MUTEX_UNLOCK_WL_SCAN_SET();
 	return status;
 }
 
+static void wl_iw_force_specific_scan(iscan_info_t *iscan)
+{
+	WL_TRACE(("%s force Specific SCAN for %s\n", __FUNCTION__, g_specific_ssid.SSID));
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+	rtnl_lock();
+#endif
+
+	(void) dev_wlc_ioctl(iscan->dev, WLC_SCAN, &g_specific_ssid, sizeof(g_specific_ssid));
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+	rtnl_unlock();
+#endif
+}
+
+
 static void wl_iw_send_scan_complete(iscan_info_t *iscan)
 {
 #ifndef SANDGATE2G
 	union iwreq_data wrqu;
-	char extra[IW_CUSTOM_MAX + 1];
 
 		memset(&wrqu, 0, sizeof(wrqu));
-		memset(extra, 0, sizeof(extra));
-		wireless_send_event(iscan->dev, SIOCGIWSCAN, &wrqu, NULL);//extra);
-		WL_TRACE(("Send Event SCAN complete\n"));
+	
+	wireless_send_event(iscan->dev, SIOCGIWSCAN, &wrqu, NULL);
+#if defined(CONFIG_FIRST_SCAN)
+		if (g_first_broadcast_scan == BROADCAST_SCAN_FIRST_STARTED)
+			g_first_broadcast_scan = BROADCAST_SCAN_FIRST_RESULT_READY;
+#endif 
+		WL_TRACE(("Send Event ISCAN complete\n"));
 #endif
 }
+
+
 static int
 _iscan_sysioc_thread(void *data)
 {
 	uint32 status;
-	iscan_info_t *iscan = (iscan_info_t *)data;
 
+	tsk_ctl_t *tsk_ctl = (tsk_ctl_t *)data;
+	iscan_info_t *iscan = (iscan_info_t *) tsk_ctl->parent;
+//	iscan_info_t *iscan = (iscan_info_t *)data;
+	static bool iscan_pass_abort = FALSE;
 	DAEMONIZE("iscan_sysioc");
 
 	status = WL_SCAN_RESULTS_PARTIAL;
+#if 0
 	while (down_interruptible(&iscan->sysioc_sem) == 0) {
+#else
+
+	complete(&tsk_ctl->completed);
+
+	while (down_interruptible(&tsk_ctl->sema) == 0) {
+
+		SMP_RD_BARRIER_DEPENDS();
+		if (tsk_ctl->terminated) {
+			break;
+		}
+#endif
+
 #if defined(SOFTAP)
+		
 		if (ap_cfg_running) {
 			WL_TRACE(("%s skipping SCAN ops in AP mode !!!\n", __FUNCTION__));
 			continue;
 		}
-#endif /* SOFTAP */
+#endif 
 		if (iscan->timer_on) {
-			del_timer(&iscan->timer);
+			del_timer_sync(&iscan->timer);
 			iscan->timer_on = 0;
 		}
 
@@ -2790,10 +3565,16 @@ _iscan_sysioc_thread(void *data)
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 		rtnl_unlock();
 #endif
+	if  (g_scan_specified_ssid && (iscan_pass_abort == TRUE)) {
+		WL_TRACE(("%s Get results from specific scan status=%d\n", __FUNCTION__, status));
+			wl_iw_send_scan_complete(iscan);
+			iscan_pass_abort = FALSE;
+			status  = -1;
+		}
 
 		switch (status) {
 			case WL_SCAN_RESULTS_PARTIAL:
-				WL_TRACE(("iscanresults incomplete\n"));
+				WL_TRACE_SCAN(("%s:iscanresults incomplete\n", __FUNCTION__));
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 				rtnl_lock();
 #endif
@@ -2807,102 +3588,75 @@ _iscan_sysioc_thread(void *data)
 				iscan->timer_on = 1;
 				break;
 			case WL_SCAN_RESULTS_SUCCESS:
-				WL_TRACE(("iscanresults complete\n"));
+				WL_TRACE_SCAN(("%s:iscanresults complete\n", __FUNCTION__));
 				iscan->iscan_state = ISCAN_STATE_IDLE;
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-08-16, fix the getting ISCAN/SCAN results */
-#if defined(CONFIG_LGE_BCM432X_PATCH)
-				g_completed_scan_type = 0; /* 0 is ISCAN */
-#endif /* CONFIG_LGE_BCM432X_PATCH */				
-/* LGE_CHANGE_E [yoohoo@lge.com] 2009-08-16, fix the getting ISCAN/SCAN results */
 				wl_iw_send_scan_complete(iscan);
 				break;
 			case WL_SCAN_RESULTS_PENDING:
-				WL_TRACE(("iscanresults pending\n"));
+				WL_TRACE_SCAN(("%s:iscanresults pending\n", __FUNCTION__));
 				
 				mod_timer(&iscan->timer, jiffies + iscan->timer_ms*HZ/1000);
 				iscan->timer_on = 1;
 				break;
 			case WL_SCAN_RESULTS_ABORTED:
-				WL_TRACE(("iscanresults aborted\n"));
+				WL_TRACE_SCAN(("%s:iscanresults aborted\n", __FUNCTION__));
 				iscan->iscan_state = ISCAN_STATE_IDLE;
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-08-16, fix the getting ISCAN/SCAN results */
-#if defined(CONFIG_LGE_BCM432X_PATCH)
-				g_completed_scan_type = 1; /* 1 is SCAN */
-				if(g_completed_scan_type != g_scan_specified_ssid) {
-					printk(KERN_ERR "[%s:%d]  ?????? [ISCAN results are not valid:%d]\n", 
-						__func__, __LINE__, g_scan_specified_ssid);
-					g_completed_scan_type = g_scan_specified_ssid;
-				}
-#endif /* CONFIG_LGE_BCM432X_PATCH */
-/* LGE_CHANGE_E [yoohoo@lge.com] 2009-08-16, fix the getting ISCAN/SCAN results */				
+				if (g_scan_specified_ssid == 0)
 				wl_iw_send_scan_complete(iscan);
+				else {
+					iscan_pass_abort = TRUE;
+					wl_iw_force_specific_scan(iscan);
+				}
+				break;
+			case WL_SCAN_RESULTS_NO_MEM:
+				WL_TRACE_SCAN(("%s:iscanresults can't alloc memory: skip\n",
+					__FUNCTION__));
+				iscan->iscan_state = ISCAN_STATE_IDLE;
 				break;
 			default:
-				WL_TRACE(("iscanresults returned unknown status %d\n", status));
+				WL_TRACE(("%s:iscanresults returned unknown status %d\n",
+					__FUNCTION__, status));
 				break;
 		 }
 	}
 
 	if (iscan->timer_on) {
-		del_timer(&iscan->timer);
+		del_timer_sync(&iscan->timer);
 		iscan->timer_on = 0;
 	}
-	complete_and_exit(&iscan->sysioc_exited, 0);
+//	complete_and_exit(&iscan->sysioc_exited, 0);
+	complete_and_exit(&tsk_ctl->completed, 0);
 }
 #endif 
 
-#ifdef WL_IW_USE_ESCAN
-static int
-wl_iw_escan(escan_info_t *escan, wlc_ssid_t *ssid, uint16 action)
-{
-	int params_size = (WL_SCAN_PARAMS_FIXED_SIZE + OFFSETOF(wl_escan_params_t, params));
-	wl_escan_params_t *params;
-	int err = 0;
-
-	if (ssid && ssid->SSID_len) {
-		params_size += sizeof(wlc_ssid_t);
-	}
-	params = (wl_escan_params_t*)kmalloc(params_size, GFP_KERNEL);
-	if (params == NULL) {
-		return -ENOMEM;
-	}
-	memset(params, 0, params_size);
-	ASSERT(params_size < WLC_IOCTL_SMLEN);
-
-	err = wl_iw_scan_prep(&params->params, ssid);
-
-	if (!err) {
-		params->version = htod32(ISCAN_REQ_VERSION);
-		params->action = htod16(action);
-		params->sync_id = 0x1234;
-
-#ifdef CONFIG_LGE_BCM432X_PATCH // for escan fail
-		err = dev_iw_iovar_setbuf(escan->dev, "escan", params, params_size,
-			escan->ioctlbuf, WLC_IOCTL_SMLEN);
-#else
-		(void) dev_iw_iovar_setbuf(escan->dev, "escan", params, params_size,
-			escan->ioctlbuf, WLC_IOCTL_SMLEN);
-#endif /* CONFIG_LGE_BCM432X_PATCH for escan fail */
-	}
+#if !defined(CSCAN)
 
-	kfree(params);
-	return err;
+static void
+wl_iw_set_ss_cache_timer_flag(void)
+{
+	g_ss_cache_ctrl.m_timer_expired = 1;
+	WL_TRACE(("%s called\n", __FUNCTION__));
 }
 
-#endif 
-
-
-
-void
+static int
 wl_iw_init_ss_cache_ctrl(void)
 {
+	WL_TRACE(("%s :\n", __FUNCTION__));
 	g_ss_cache_ctrl.m_prev_scan_mode = 0;
 	g_ss_cache_ctrl.m_cons_br_scan_cnt = 0;
 	g_ss_cache_ctrl.m_cache_head = NULL;
 	g_ss_cache_ctrl.m_link_down = 0;
 	g_ss_cache_ctrl.m_timer_expired = 0;
-	g_ss_cache_ctrl.m_timer = NULL;
 	memset(g_ss_cache_ctrl.m_active_bssid, 0, ETHER_ADDR_LEN);
+
+	g_ss_cache_ctrl.m_timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
+	if (!g_ss_cache_ctrl.m_timer) {
+		return -ENOMEM;
+	}
+	g_ss_cache_ctrl.m_timer->function = (void *)wl_iw_set_ss_cache_timer_flag;
+	init_timer(g_ss_cache_ctrl.m_timer);
+
+	return 0;
 }
 
 
@@ -2915,6 +3669,7 @@ wl_iw_free_ss_cache(void)
 
 	WL_TRACE(("%s called\n", __FUNCTION__));
 
+	MUTEX_LOCK_WL_SCAN_SET();
 	spec_scan_head = &g_ss_cache_ctrl.m_cache_head;
 	node = *spec_scan_head;
 
@@ -2925,14 +3680,9 @@ wl_iw_free_ss_cache(void)
 		kfree(cur);
 	}
 	*spec_scan_head = NULL;
+	MUTEX_UNLOCK_WL_SCAN_SET();
 }
 
-static void
-wl_iw_set_ss_cache_timer_flag(void)
-{
-	g_ss_cache_ctrl.m_timer_expired = 1;
-	WL_TRACE(("%s called\n", __FUNCTION__));
-}
 
 
 static int
@@ -2942,25 +3692,16 @@ wl_iw_run_ss_cache_timer(int kick_off)
 
 	timer = &g_ss_cache_ctrl.m_timer;
 
+	if (*timer) {
 	if (kick_off) {
-		*timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
-		if (!(*timer)) {
-			return -ENOMEM;
-		}
-		(*timer)->function = (void *)wl_iw_set_ss_cache_timer_flag;
-		init_timer(*timer);
 		(*timer)->expires = jiffies + 30000 * HZ / 1000;	
 		add_timer(*timer);
 		WL_TRACE(("%s : timer starts \n", __FUNCTION__));
-	}
-	else {
-		if (*timer) {
-			del_timer(*timer);
-			kfree(*timer);
-			*timer = NULL;
-		}
+		} else {
+			del_timer_sync(*timer);
 		WL_TRACE(("%s : timer stops \n", __FUNCTION__));
 	}
+	}
 
 	return 0;
 }
@@ -2969,8 +3710,12 @@ wl_iw_run_ss_cache_timer(int kick_off)
 void
 wl_iw_release_ss_cache_ctrl(void)
 {
+	WL_TRACE(("%s :\n", __FUNCTION__));
 	wl_iw_free_ss_cache();
 	wl_iw_run_ss_cache_timer(0);
+	if (g_ss_cache_ctrl.m_timer) {
+		kfree(g_ss_cache_ctrl.m_timer);
+	}
 }
 
 
@@ -2981,6 +3726,7 @@ wl_iw_reset_ss_cache(void)
 	wl_iw_ss_cache_t *node, *prev, *cur;
 	wl_iw_ss_cache_t **spec_scan_head;
 
+	MUTEX_LOCK_WL_SCAN_SET();
 	spec_scan_head = &g_ss_cache_ctrl.m_cache_head;
 	node = *spec_scan_head;
 	prev = node;
@@ -3007,7 +3753,7 @@ wl_iw_reset_ss_cache(void)
 		prev = node;
 		node = node->next;
 	}
-
+	MUTEX_UNLOCK_WL_SCAN_SET();
 }
 
 
@@ -3020,13 +3766,13 @@ wl_iw_add_bss_to_ss_cache(wl_scan_results_t *ss_list)
 	wl_bss_info_t *bi = NULL;
 	int i;
 
-	spec_scan_head = &g_ss_cache_ctrl.m_cache_head;
 	
 	if (!ss_list->count) {
 		return 0;
 	}
 
-	
+	MUTEX_LOCK_WL_SCAN_SET();
+	spec_scan_head = &g_ss_cache_ctrl.m_cache_head;
 	for (i = 0; i < ss_list->count; i++) {
 
 		node = *spec_scan_head;
@@ -3034,7 +3780,7 @@ wl_iw_add_bss_to_ss_cache(wl_scan_results_t *ss_list)
 
 		bi = bi ? (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length)) : ss_list->bss_info;
 
-		WL_TRACE(("%s : %dth SSID %s\n", __FUNCTION__, i, bi->SSID));
+		WL_TRACE(("%s : find %d with specific SSID %s\n", __FUNCTION__, i, bi->SSID));
 		for (;node;) {
 			if (!memcmp(&node->bss_info->BSSID, &bi->BSSID, ETHER_ADDR_LEN)) {
 				
@@ -3049,17 +3795,18 @@ wl_iw_add_bss_to_ss_cache(wl_scan_results_t *ss_list)
 		if (node) {
 			continue;
 		}
-		leaf = kmalloc(WLC_IW_SS_CACHE_MAXLEN, GFP_KERNEL);
+
+		// 20101006	byoungwook.baek@lge.com, bug-fix: vmalloc [START]
+		leaf = kmalloc(bi->length + WLC_IW_SS_CACHE_CTRL_FIELD_MAXLEN, GFP_KERNEL);
+		//leaf =(wl_iw_ss_cache_t *) kmalloc(sizeof(wl_iw_ss_cache_t), GFP_KERNEL);
+		// 20101006	byoungwook.baek@lge.com, bug-fix: vmalloc [END]
 		if (!leaf) {
+			MUTEX_UNLOCK_WL_SCAN_SET();
+			WL_ERROR(("Memory alloc failure %d\n", \
+				bi->length + WLC_IW_SS_CACHE_CTRL_FIELD_MAXLEN));
 			return -ENOMEM;
 		}
 
-		if (bi->length > WLC_IW_BSS_INFO_MAXLEN) {
-			WL_TRACE(("bss info length is too long : %d\n", bi->length));
-			kfree(leaf);
-			continue;
-		}
-
 		memcpy(leaf->bss_info, bi, bi->length);
 		leaf->next = NULL;
 		leaf->dirty = 1;
@@ -3073,6 +3820,7 @@ wl_iw_add_bss_to_ss_cache(wl_scan_results_t *ss_list)
 			prev->next = leaf;
 		}
 	}
+	MUTEX_UNLOCK_WL_SCAN_SET();
 	return 0;
 
 }
@@ -3085,19 +3833,22 @@ __u16 *merged_len)
 	wl_iw_ss_cache_t *node;
 	wl_scan_results_t *list_merge;
 
+	MUTEX_LOCK_WL_SCAN_SET();
 	node = g_ss_cache_ctrl.m_cache_head;
 	for (;node;) {
-		list_merge = (wl_scan_results_t *)node;
-		WL_TRACE(("%s: Bcast APs list=%d\n", __FUNCTION__, list_merge->count));
+		list_merge = (wl_scan_results_t *)&node->buflen;
+		WL_TRACE(("%s: Cached Specific APs list=%d\n", __FUNCTION__, list_merge->count));
 		if (buflen_from_user - *merged_len > 0) {
 			*merged_len += (__u16) wl_iw_get_scan_prep(list_merge, info,
 				extra + *merged_len, buflen_from_user - *merged_len);
 		}
 		else {
+			WL_TRACE(("%s: exit with break\n", __FUNCTION__));
 			break;
 		}
 		node = node->next;
 	}
+	MUTEX_UNLOCK_WL_SCAN_SET();
 	return 0;
 }
 
@@ -3109,6 +3860,7 @@ wl_iw_delete_bss_from_ss_cache(void *addr)
 	wl_iw_ss_cache_t *node, *prev;
 	wl_iw_ss_cache_t **spec_scan_head;
 
+	MUTEX_LOCK_WL_SCAN_SET();
 	spec_scan_head = &g_ss_cache_ctrl.m_cache_head;
 	node = *spec_scan_head;
 	prev = node;
@@ -3131,10 +3883,12 @@ wl_iw_delete_bss_from_ss_cache(void *addr)
 	}
 
 	memset(addr, 0, ETHER_ADDR_LEN);
+	MUTEX_UNLOCK_WL_SCAN_SET();
 	return 0;
 
 }
 
+#endif	
 
 
 static int
@@ -3145,116 +3899,135 @@ wl_iw_set_scan(
 	char *extra
 )
 {
-	wlc_ssid_t ssid;
+	int error;
+	WL_TRACE_SCAN(("\n:%s dev:%s: ###### SIOCSIWSCAN: ##### \n", __FUNCTION__, dev->name));
 
-	WL_TRACE(("%s: SIOCSIWSCAN\n", dev->name));
+
+#if defined(CSCAN)
+		WL_ERROR(("%s: Scan from SIOCGIWSCAN not supported\n", __FUNCTION__));
+		return -EINVAL;
+#endif 
 
 #if defined(SOFTAP)
+	
 	if (ap_cfg_running) {
-		WL_TRACE(("\n>%s: Not executed, reason -'SOFTAP is active'\n", __FUNCTION__));
+		WL_TRACE_SCAN(("\n>%s: Not executed, reason -'SOFTAP is active'\n", __FUNCTION__));
 		return 0;
 	}
-#endif /* SOFTAP */
+#endif 
+
 	
 	if (g_onoff == G_WLAN_SET_OFF)
 		return 0;
 
 	
-	memset(&ssid, 0, sizeof(ssid));
+	memset(&g_specific_ssid, 0, sizeof(g_specific_ssid));
+#ifndef WL_IW_USE_ISCAN
+	
 	g_scan_specified_ssid	= 0;
+#endif 
 
 #if WIRELESS_EXT > 17
 	
 	if (wrqu->data.length == sizeof(struct iw_scan_req)) {
 		if (wrqu->data.flags & IW_SCAN_THIS_ESSID) {
 			struct iw_scan_req *req = (struct iw_scan_req *)extra;
-			ssid.SSID_len = MIN(sizeof(ssid.SSID), req->essid_len);
-			memcpy(ssid.SSID, req->essid, ssid.SSID_len);
-			ssid.SSID_len = htod32(ssid.SSID_len);
+#if defined(CONFIG_FIRST_SCAN)
+			if (g_first_broadcast_scan != BROADCAST_SCAN_FIRST_RESULT_CONSUMED) {
+				
+				WL_ERROR(("%s Ignoring SC %s first BC is not done = %d\n", \
+						__FUNCTION__, req->essid, \
+						g_first_broadcast_scan));
+				if(g_first_broadcast_scan !=BROADCAST_SCAN_FIRST_IDLE)  //hanzo.jung test
+				   g_first_broadcast_scan = BROADCAST_SCAN_FIRST_RESULT_CONSUMED;
+					return -EBUSY;
+			}
+#endif	
+			if (g_scan_specified_ssid) {
+				WL_TRACE_SCAN((
+					"%s Specific SCAN is not done ignore scan for = %s \n", \
+					__FUNCTION__, req->essid));
+				
+				return -EBUSY;
+			}
+			else {
+				g_specific_ssid.SSID_len = MIN(sizeof(g_specific_ssid.SSID), \
+										req->essid_len);
+				memcpy(g_specific_ssid.SSID, req->essid, g_specific_ssid.SSID_len);
+				g_specific_ssid.SSID_len = htod32(g_specific_ssid.SSID_len);
 			g_scan_specified_ssid = 1;
-			WL_TRACE(("Specific scan ssid=%s len=%d\n", ssid.SSID, ssid.SSID_len));
+				WL_TRACE(("### Specific scan ssid=%s len=%d\n", \
+						g_specific_ssid.SSID, g_specific_ssid.SSID_len));
+			}
 		}
 	}
 #endif
 	
-	(void) dev_wlc_ioctl(dev, WLC_SCAN, &ssid, sizeof(ssid));
 
+	if ((error = dev_wlc_ioctl(dev, WLC_SCAN, &g_specific_ssid, sizeof(g_specific_ssid)))) {
+		WL_TRACE_SCAN((" Set SCAN for %s failed with %d\n",
+			g_specific_ssid.SSID, error));
+		
+		g_scan_specified_ssid = 0;
+
+		return -EBUSY;
+	}
 	return 0;
 }
 
 #ifdef WL_IW_USE_ISCAN
-static int
-wl_iw_iscan_set_scan(
-	struct net_device *dev,
-	struct iw_request_info *info,
-	union iwreq_data *wrqu,
-	char *extra
-)
-{
-	wlc_ssid_t ssid;
-	iscan_info_t *iscan = g_iscan;
-
-	WL_TRACE(("%s: SIOCSIWSCAN\n", dev->name));
-
-	
-	if (g_onoff == G_WLAN_SET_OFF)
-		return 0;
-
-	
-	if ((!iscan) || (iscan->sysioc_pid < 0)) {
-		return wl_iw_set_scan(dev, info, wrqu, extra);
-	}
-	if (iscan->iscan_state == ISCAN_STATE_SCANING) {
-		return 0;
-	}
-
-	
-	memset(&ssid, 0, sizeof(ssid));
-
-	g_scan_specified_ssid = 0;
-#if WIRELESS_EXT > 17
-	
-	if (wrqu->data.length == sizeof(struct iw_scan_req)) {
-		if (wrqu->data.flags & IW_SCAN_THIS_ESSID) {
-			int as = 0;
-			struct iw_scan_req *req = (struct iw_scan_req *)extra;
-			ssid.SSID_len = MIN(sizeof(ssid.SSID), req->essid_len);
-			memcpy(ssid.SSID, req->essid, ssid.SSID_len);
-			ssid.SSID_len = htod32(ssid.SSID_len);
-			g_scan_specified_ssid = 1;
-			dev_wlc_ioctl(dev, WLC_SET_PASSIVE_SCAN, &as, sizeof(as));
-			return wl_iw_set_scan(dev, info, wrqu, extra);
-		}
+int
+wl_iw_iscan_set_scan_broadcast_prep(struct net_device *dev, uint flag)
+{
+	wlc_ssid_t ssid;
+	iscan_info_t *iscan = g_iscan;
+
+#if defined(CONFIG_FIRST_SCAN)
+	
+	if (g_first_broadcast_scan == BROADCAST_SCAN_FIRST_IDLE) {
+		g_first_broadcast_scan = BROADCAST_SCAN_FIRST_STARTED;
+		WL_TRACE_SCAN(("%s: First Brodcast scan was forced\n", __FUNCTION__));
+	}
+	else if (g_first_broadcast_scan == BROADCAST_SCAN_FIRST_STARTED) {
+		WL_TRACE_SCAN(("%s: ignore ISCAN request first BS is not done yet\n",
+			__FUNCTION__));
+		return 0;
 	}
 #endif 
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+	if (flag)
+		rtnl_lock();
+#endif
+	
+	dev_wlc_ioctl(dev, WLC_SET_PASSIVE_SCAN, &iscan->scan_flag, sizeof(iscan->scan_flag));
+	wl_iw_set_event_mask(dev);
+
+	WL_TRACE_SCAN(("+++: Set Broadcast ISCAN\n"));
+	
+	memset(&ssid, 0, sizeof(ssid));
+
 	iscan->list_cur = iscan->list_hdr;
 	iscan->iscan_state = ISCAN_STATE_SCANING;
-	(void) dev_wlc_ioctl(dev, WLC_SET_PASSIVE_SCAN,
-		&iscan->scan_flag, sizeof(iscan->scan_flag));
-	wl_iw_set_event_mask(dev);
+
+	memset(&iscan->iscan_ex_params_p->params, 0, iscan->iscan_ex_param_size);
+	wl_iw_iscan_prep(&iscan->iscan_ex_params_p->params, &ssid);
 	wl_iw_iscan(iscan, &ssid, WL_SCAN_ACTION_START);
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-05-08, to avoid duplicated add_timer */
-#if defined(CONFIG_LGE_BCM432X_PATCH)
-	if (iscan->timer_on) {
-		del_timer(&iscan->timer);
-		iscan->timer_on = 0;
-	}
-#else /* CONFIG_LGE_BCM432X_PATCH */
-	del_timer(&iscan->timer);
-#endif /* CONFIG_LGE_BCM432X_PATCH */
-/* LGE_CHANGE_E [yoohoo@lge.com] 2009-05-08, to avoid duplicated add_timer */
-	iscan->timer.expires = jiffies + iscan->timer_ms*HZ/1000;
-	add_timer(&iscan->timer);
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+	if (flag)
+		rtnl_unlock();
+#endif
+
+	mod_timer(&iscan->timer, jiffies + iscan->timer_ms*HZ/1000);
+
 	iscan->timer_on = 1;
 
 	return 0;
 }
-#endif 
-
-#ifdef WL_IW_USE_ESCAN
 static int
-wl_iw_escan_set_scan(
+wl_iw_iscan_set_scan(
 	struct net_device *dev,
 	struct iw_request_info *info,
 	union iwreq_data *wrqu,
@@ -3262,33 +4035,50 @@ wl_iw_escan_set_scan(
 )
 {
 	wlc_ssid_t ssid;
-	escan_info_t *escan = g_escan;
-	wl_scan_results_t *results;
-#ifdef CONFIG_LGE_BCM432X_PATCH // for escan fail
-	int err = 0;
-#endif /* CONFIG_LGE_BCM432X_PATCH for escan fail */
+	iscan_info_t *iscan = g_iscan;
+
+	WL_TRACE_SCAN(("%s: SIOCSIWSCAN : ISCAN\n", dev->name));
+
+#if defined(CSCAN)
+		WL_ERROR(("%s: Scan from SIOCGIWSCAN not supported\n", __FUNCTION__));
+		return -EINVAL;
+#endif 
 
-	WL_TRACE(("%s: SIOCSIWSCAN\n", dev->name));
 
 #if defined(SOFTAP)
 	if (ap_cfg_running) {
-		WL_TRACE(("\n>%s: Not executed, reason -'SOFTAP is active'\n", __FUNCTION__));
+		WL_TRACE_SCAN(("\n>%s: Not executed, reason -'SOFTAP is active'\n", __FUNCTION__));
 		return 0;
 	}
-#endif /* SOFTAP */
+#endif
 	
-	if (g_onoff == G_WLAN_SET_OFF)
+	if (g_onoff == G_WLAN_SET_OFF) {
+		WL_TRACE_SCAN(("%s: driver is not up yet after START\n", __FUNCTION__));
 		return 0;
+	}
+
+#ifdef PNO_SUPPORT
+	
+	if  (dhd_dev_get_pno_status(dev)) {
+		WL_TRACE_SCAN(("%s: Scan called when PNO is active\n", __FUNCTION__));
+	}
+#endif 
 
-	if (!escan)
-		return wl_iw_set_scan(dev, info, wrqu, extra);
-	if (escan->escan_state == ESCAN_STATE_SCANING) {
+	
+//	if ((!iscan) || (iscan->sysioc_pid < 0)) {
+	if ((!iscan) || (iscan->tsk_ctl.thr_pid < 0)) {
+		WL_ERROR(("%s error \n",  __FUNCTION__));
 		return 0;
 	}
 
+	if (g_scan_specified_ssid) {
+		WL_TRACE_SCAN(("%s Specific SCAN already running ignoring BC scan\n", \
+				__FUNCTION__));
+		return EBUSY;
+	}
+
 	
 	memset(&ssid, 0, sizeof(ssid));
-	g_scan_specified_ssid = 0;
 
 #if WIRELESS_EXT > 17
 	
@@ -3299,43 +4089,40 @@ wl_iw_escan_set_scan(
 			ssid.SSID_len = MIN(sizeof(ssid.SSID), req->essid_len);
 			memcpy(ssid.SSID, req->essid, ssid.SSID_len);
 			ssid.SSID_len = htod32(ssid.SSID_len);
-			g_scan_specified_ssid = 1;
 			dev_wlc_ioctl(dev, WLC_SET_PASSIVE_SCAN, &as, sizeof(as));
+			wl_iw_set_event_mask(dev);
 			return wl_iw_set_scan(dev, info, wrqu, extra);
 		}
+		else {
+			g_scan_specified_ssid = 0;
+
+			if (iscan->iscan_state == ISCAN_STATE_SCANING) {
+				WL_TRACE_SCAN(("%s ISCAN already in progress \n", __FUNCTION__));
+				return 0;
+			}
+		}
 	}
 #endif 
 
-	escan->escan_state = ESCAN_STATE_SCANING;
-	results = (wl_scan_results_t *) escan->escan_buf;
-	results->version = 0;
-	results->count = 0;
-	results->buflen = WL_SCAN_RESULTS_FIXED_SIZE;
+#if defined(CONFIG_FIRST_SCAN) && !defined(CSCAN)
+	if (g_first_broadcast_scan < BROADCAST_SCAN_FIRST_RESULT_CONSUMED) {
+		if (++g_first_counter_scans == MAX_ALLOWED_BLOCK_SCAN_FROM_FIRST_SCAN) {
 
-#ifdef CONFIG_LGE_BCM432X_PATCH // for escan fail
-	err = dev_wlc_ioctl(dev, WLC_SET_PASSIVE_SCAN,
-		&escan->scan_flag, sizeof(escan->scan_flag));
-#else
-	(void) dev_wlc_ioctl(dev, WLC_SET_PASSIVE_SCAN,
-		&escan->scan_flag, sizeof(escan->scan_flag));
-#endif /* CONFIG_LGE_BCM432X_PATCH for escan fail */
-	wl_iw_set_event_mask(dev);
-#ifdef CONFIG_LGE_BCM432X_PATCH // for escan fail
-	err = wl_iw_escan(escan, &ssid, WL_SCAN_ACTION_START);
-#else
-	wl_iw_escan(escan, &ssid, WL_SCAN_ACTION_START);
-#endif /* CONFIG_LGE_BCM432X_PATCH for escan fail */
+			WL_ERROR(("%s Clean up First scan flag which is %d\n", \
+				 __FUNCTION__, g_first_broadcast_scan));
+			g_first_broadcast_scan = BROADCAST_SCAN_FIRST_RESULT_CONSUMED;
+		}
+		else {
+			WL_ERROR(("%s Ignoring Broadcast Scan:First Scan is not done yet %d\n", \
+					__FUNCTION__, g_first_counter_scans));
+			return -EBUSY;
+		}
+	}
+#endif 
 
-#ifdef CONFIG_LGE_BCM432X_PATCH // for escan fail
-	if(err < 0)
-		escan->escan_state = ESCAN_STATE_IDLE;
-#endif /* CONFIG_LGE_BCM432X_PATCH for escan fail */
+	wl_iw_iscan_set_scan_broadcast_prep(dev, 0);
 
-#ifdef CONFIG_LGE_BCM432X_PATCH // for escan fail
-	return err;
-#else
 	return 0;
-#endif /* CONFIG_LGE_BCM432X_PATCH for escan fail */
 }
 #endif 
 
@@ -3385,6 +4172,32 @@ ie_is_wps_ie(uint8 **wpsie, uint8 **tlvs, int *tlvs_len)
 }
 #endif 
 
+static inline int _wpa_snprintf_hex(char *buf, size_t buf_size, const u8 *data,
+	size_t len, int uppercase)
+{
+	size_t i;
+	char *pos = buf, *end = buf + buf_size;
+	int ret;
+	if (buf_size == 0)
+		return 0;
+	for (i = 0; i < len; i++) {
+		ret = snprintf(pos, end - pos, uppercase ? "%02X" : "%02x",
+			data[i]);
+		if (ret < 0 || ret >= end - pos) {
+			end[-1] = '\0';
+			return pos - buf;
+		}
+		pos += ret;
+	}
+	end[-1] = '\0';
+	return pos - buf;
+}
+
+
+int wpa_snprintf_hex(char *buf, size_t buf_size, const u8 *data, size_t len)
+{
+	return _wpa_snprintf_hex(buf, buf_size, data, len, 0);
+}
 
 static int
 wl_iw_handle_scanresults_ies(char **event_p, char *end,
@@ -3393,6 +4206,8 @@ wl_iw_handle_scanresults_ies(char **event_p, char *end,
 #if WIRELESS_EXT > 17
 	struct iw_event	iwe;
 	char *event;
+	char *buf;
+	int custom_event_len;
 
 	event = *event_p;
 	if (bi->ie_length) {
@@ -3431,12 +4246,43 @@ wl_iw_handle_scanresults_ies(char **event_p, char *end,
 			}
 		}
 
+		ptr = ((uint8 *)bi) + sizeof(wl_bss_info_t);
+		ptr_len = bi->ie_length;
+
+		while ((ie = bcm_parse_tlvs(ptr, ptr_len, DOT11_MNG_WAPI_ID))) {
+			WL_TRACE(("%s: found a WAPI IE...\n", __FUNCTION__));
+#ifdef WAPI_IE_USE_GENIE
+			iwe.cmd = IWEVGENIE;
+			iwe.u.data.length = ie->len + 2;
+			event = IWE_STREAM_ADD_POINT(info, event, end, &iwe, (char *)ie);
+#else 
+			iwe.cmd = IWEVCUSTOM;
+			custom_event_len = strlen("wapi_ie=") + 2*(ie->len + 2);
+			iwe.u.data.length = custom_event_len;
+
+			buf = kmalloc(custom_event_len+1, GFP_KERNEL);
+			if (buf == NULL)
+			{
+				WL_ERROR(("malloc(%d) returned NULL...\n", custom_event_len));
+				break;
+			}
+
+			memcpy(buf, "wapi_ie=", 8);
+			wpa_snprintf_hex(buf + 8, 2+1, &(ie->id), 1);
+			wpa_snprintf_hex(buf + 10, 2+1, &(ie->len), 1);
+			wpa_snprintf_hex(buf + 12, 2*ie->len+1, ie->data, ie->len);
+			event = IWE_STREAM_ADD_POINT(info, event, end, &iwe, buf);
+#endif 
+			break;
+		}
 	*event_p = event;
 	}
 #endif 
 
 	return 0;
 }
+
+#ifndef CSCAN
 static uint
 wl_iw_get_scan_prep(
 	wl_scan_results_t *list,
@@ -3448,18 +4294,28 @@ wl_iw_get_scan_prep(
 	struct iw_event  iwe;
 	wl_bss_info_t *bi = NULL;
 	char *event = extra, *end = extra + max_size - WE_ADD_EVENT_FIX, *value;
-	uint	ret = 0;
+	int	ret = 0;
+	int channel;
 
-	ASSERT(list);
+	if (!list) {
+		WL_ERROR(("%s: Null list pointer", __FUNCTION__));
+		return ret;
+	}
 
 	
 
 	for (i = 0; i < list->count && i < IW_MAX_AP; i++)
 	{
-		ASSERT(list->version == WL_BSS_INFO_VERSION);
+		if (list->version != WL_BSS_INFO_VERSION) {
+			WL_ERROR(("%s : list->version %d != WL_BSS_INFO_VERSION\n", \
+				__FUNCTION__, list->version));
+			return ret;
+		 }
 
 		bi = bi ? (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length)) : list->bss_info;
 
+		WL_TRACE(("%s : %s\n", __FUNCTION__, bi->SSID));
+
 		
 		iwe.cmd = SIOCGIWAP;
 		iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
@@ -3483,8 +4339,9 @@ wl_iw_get_scan_prep(
 
 		
 		iwe.cmd = SIOCGIWFREQ;
-		iwe.u.freq.m = wf_channel2mhz(CHSPEC_CHANNEL(bi->chanspec),
-			CHSPEC_CHANNEL(bi->chanspec) <= CH_MAX_2G_CHANNEL ?
+		channel = (bi->ctl_ch == 0) ? CHSPEC_CHANNEL(bi->chanspec) : bi->ctl_ch;
+		iwe.u.freq.m = wf_channel2mhz(channel,
+			channel <= CH_MAX_2G_CHANNEL ?
 			WF_CHAN_FACTOR_2_4_G : WF_CHAN_FACTOR_5_G);
 		iwe.u.freq.e = 6;
 		event = IWE_STREAM_ADD_EVENT(info, event, end, &iwe, IW_EV_FREQ_LEN);
@@ -3510,7 +4367,7 @@ wl_iw_get_scan_prep(
 
 		
 		if (bi->rateset.count) {
-			if (((event - extra) + IW_EV_LCP_LEN) <= (uintptr)end) {
+			if (((event -extra) + IW_EV_LCP_LEN) <= (uintptr)end) {
 				value = event + IW_EV_LCP_LEN;
 				iwe.cmd = SIOCGIWRATE;
 				
@@ -3531,8 +4388,7 @@ wl_iw_get_scan_prep(
 		ret = 0;
 	}
 	WL_TRACE(("%s: size=%d bytes prepared \n", __FUNCTION__, (unsigned int)(event - extra)));
-	return ret;
-
+	return (uint)ret;
 }
 
 static int
@@ -3548,38 +4404,34 @@ wl_iw_get_scan(
 	wl_scan_results_t *list = (wl_scan_results_t *) g_scan;
 	int error;
 	uint buflen_from_user = dwrq->length;
-#if defined(CONFIG_LGE_BCM432X_PATCH) && (DHD_USE_STATIC_BUF)
-	uint len =  G_SCAN_RESULTS - 32;
-#else
 	uint len =  G_SCAN_RESULTS;
-#endif //DHD_USE_STATIC_BUF
 	__u16 len_ret = 0;
+#if  !defined(CSCAN)
 	__u16 merged_len = 0;
-
+#endif
 #if defined(WL_IW_USE_ISCAN)
 	iscan_info_t *iscan = g_iscan;
 	iscan_buf_t * p_buf;
+#if  !defined(CSCAN)
+	uint32 counter = 0;
+#endif 
 #endif
 
 	WL_TRACE(("%s: buflen_from_user %d: \n", dev->name, buflen_from_user));
 
-// WBT Fix TD# 37096
-	memset(&ci, 0, sizeof(channel_info_t));
-//
-
 	if (!extra) {
 		WL_TRACE(("%s: wl_iw_get_scan return -EINVAL\n", dev->name));
 		return -EINVAL;
 	}
 
 	
-	if ((error = dev_wlc_ioctl(dev, WLC_GET_CHANNEL, &ci, sizeof(ci)))) {
+	if ((error = dev_wlc_ioctl(dev, WLC_GET_CHANNEL, &ci, sizeof(ci))))
 		return error;
-	}
 	ci.scan_channel = dtoh32(ci.scan_channel);
-	if (ci.scan_channel) {
+	if (ci.scan_channel)
 		return -EAGAIN;
-	}
+
+#if  !defined(CSCAN)
 	if (g_ss_cache_ctrl.m_timer_expired) {
 		wl_iw_free_ss_cache();
 		g_ss_cache_ctrl.m_timer_expired ^= 1;
@@ -3597,6 +4449,7 @@ wl_iw_get_scan(
 	else {
 		g_ss_cache_ctrl.m_cons_br_scan_cnt++;
 	}
+#endif 
 
 
 	
@@ -3605,6 +4458,7 @@ wl_iw_get_scan(
 		list = kmalloc(len, GFP_KERNEL);
 		if (!list) {
 			WL_TRACE(("%s: wl_iw_get_scan return -ENOMEM\n", dev->name));
+			g_scan_specified_ssid = 0;
 			return -ENOMEM;
 		}
 	}
@@ -3612,60 +4466,76 @@ wl_iw_get_scan(
 	memset(list, 0, len);
 	list->buflen = htod32(len);
 	if ((error = dev_wlc_ioctl(dev, WLC_SCAN_RESULTS, list, len))) {
-		WL_TRACE(("%s: %s : Scan_results too big %d\n", dev->name, __FUNCTION__, len));
+		WL_ERROR(("%s: %s : Scan_results ERROR %d\n", dev->name, __FUNCTION__, error));
 		dwrq->length = len;
 /* LGE_CHANGE_S [yoohoo@lge.com] 2009-08-16, fix the getting ISCAN/SCAN results */
-#if defined(CONFIG_LGE_BCM432X_PATCH) && defined(WL_IW_USE_ISCAN)
+#if defined(CONFIG_LGE_BCM432X_PATCH)
 		if (g_scan_specified_ssid) {
 			list->count = 0;
 			printk(KERN_ERR "[%s: %d] : You may only get ISCAN results, list->count: %d\n",
 				__func__, __LINE__, list->count);
 		}
-#else /* defined(CONFIG_LGE_BCM432X_PATCH) && defined(WL_IW_USE_ISCAN) */
-		if (g_scan_specified_ssid)
+#else /* CONFIG_LGE_BCM432X_PATCH */
+		if (g_scan_specified_ssid) {
+			g_scan_specified_ssid = 0;
 			kfree(list);
+		}
 		return 0;
-#endif /* defined(CONFIG_LGE_BCM432X_PATCH) && defined(WL_IW_USE_ISCAN) */
+#endif /* CONFIG_LGE_BCM432X_PATCH */
 /* LGE_CHANGE_E [yoohoo@lge.com] 2009-08-16, fix the getting ISCAN/SCAN results */
 	}
 /* LGE_CHANGE_S [yoohoo@lge.com] 2009-08-16, fix the getting ISCAN/SCAN results */
-#if defined(CONFIG_LGE_BCM432X_PATCH) && defined(WL_IW_USE_ISCAN)
+#if defined(CONFIG_LGE_BCM432X_PATCH)
 	else {
-#endif /* defined(CONFIG_LGE_BCM432X_PATCH) && defined(WL_IW_USE_ISCAN) */		
+#endif /* CONFIG_LGE_BCM432X_PATCH */		
 	list->buflen = dtoh32(list->buflen);
 	list->version = dtoh32(list->version);
 	list->count = dtoh32(list->count);
-#if defined(CONFIG_LGE_BCM432X_PATCH) && defined(WL_IW_USE_ISCAN)
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+	}
+#endif /* CONFIG_LGE_BCM432X_PATCH */		
+
+	
+	if (list->version != WL_BSS_INFO_VERSION) {
+		WL_ERROR(("%s : list->version %d != WL_BSS_INFO_VERSION\n", \
+			 __FUNCTION__, list->version));
+		if (g_scan_specified_ssid) {
+			g_scan_specified_ssid = 0;
+			kfree(list);
+		}
+		return -EINVAL;
 	}
-#endif /* defined(CONFIG_LGE_BCM432X_PATCH) && defined(WL_IW_USE_ISCAN) */		
 
+#if  !defined(CSCAN)
 	if (g_scan_specified_ssid) {
 		
 		wl_iw_add_bss_to_ss_cache(list);
 		kfree(list);
 	}
+#endif
 
+#if  !defined(CSCAN)
+	MUTEX_LOCK_WL_SCAN_SET();
 #if defined(WL_IW_USE_ISCAN)
+	if (g_scan_specified_ssid)
+		WL_TRACE(("%s: Specified scan APs from scan=%d\n", __FUNCTION__, list->count));
 	p_buf = iscan->list_hdr;
 	
 	while (p_buf != iscan->list_cur) {
 		list_merge = &((wl_iscan_results_t*)p_buf->iscan_buf)->results;
 		WL_TRACE(("%s: Bcast APs list=%d\n", __FUNCTION__, list_merge->count));
+		counter += list_merge->count;
 		if (list_merge->count > 0)
 			len_ret += (__u16) wl_iw_get_scan_prep(list_merge, info,
 				extra+len_ret, buflen_from_user -len_ret);
 		p_buf = p_buf->next;
 	}
-#elif defined(WL_IW_USE_ESCAN)
-	list_merge = (wl_scan_results_t *) g_escan->escan_buf;
-	if (list_merge->count > 0) {
-		// louislee add len_ret for scan list count
-		len_ret = (__u16) wl_iw_get_scan_prep(list_merge, info, extra, buflen_from_user);
-	}
+	WL_TRACE(("%s merged with total Bcast APs=%d\n", __FUNCTION__, counter));
 #else
 	list_merge = (wl_scan_results_t *) g_scan;
 	len_ret = (__u16) wl_iw_get_scan_prep(list_merge, info, extra, buflen_from_user);
 #endif 
+	MUTEX_UNLOCK_WL_SCAN_SET();
 	if (g_ss_cache_ctrl.m_link_down) {
 		
 		wl_iw_delete_bss_from_ss_cache(g_ss_cache_ctrl.m_active_bssid);
@@ -3675,8 +4545,43 @@ wl_iw_get_scan(
 	len_ret += merged_len;
 	wl_iw_run_ss_cache_timer(0);
 	wl_iw_run_ss_cache_timer(1);
+#else	
+
+	
+	if (g_scan_specified_ssid) {
+		WL_TRACE(("%s: Specified scan APs in the list =%d\n", __FUNCTION__, list->count));
+		len_ret = (__u16) wl_iw_get_scan_prep(list, info, extra, buflen_from_user);
+		kfree(list);
+
+#if defined(WL_IW_USE_ISCAN)
+		p_buf = iscan->list_hdr;
+		
+		while (p_buf != iscan->list_cur) {
+			list_merge = &((wl_iscan_results_t*)p_buf->iscan_buf)->results;
+			WL_TRACE(("%s: Bcast APs list=%d\n", __FUNCTION__, list_merge->count));
+			if (list_merge->count > 0)
+				len_ret += (__u16) wl_iw_get_scan_prep(list_merge, info,
+				    extra+len_ret, buflen_from_user -len_ret);
+			p_buf = p_buf->next;
+		}
+#else
+		list_merge = (wl_scan_results_t *) g_scan;
+		WL_TRACE(("%s: Bcast APs list=%d\n", __FUNCTION__, list_merge->count));
+		if (list_merge->count > 0)
+			len_ret += (__u16) wl_iw_get_scan_prep(list_merge, info, extra+len_ret,
+				buflen_from_user -len_ret);
+#endif 
+	}
+	else {
+		list = (wl_scan_results_t *) g_scan;
+		len_ret = (__u16) wl_iw_get_scan_prep(list, info, extra, buflen_from_user);
+	}
+#endif	
 
+#if defined(WL_IW_USE_ISCAN)
 
+	g_scan_specified_ssid = 0;
+#endif 
 	
 	if ((len_ret + WE_ADD_EVENT_FIX) < buflen_from_user)
 		len = len_ret;
@@ -3687,10 +4592,11 @@ wl_iw_get_scan(
 	WL_TRACE(("%s return to WE %d bytes APs=%d\n", __FUNCTION__, dwrq->length, list->count));
 	return 0;
 }
+#endif 
 
-#if defined(WL_IW_USE_ISCAN) || defined(WL_IW_USE_ESCAN)
+#if defined(WL_IW_USE_ISCAN)
 static int
-wl_iw_scan_get_scan(
+wl_iw_iscan_get_scan(
 	struct net_device *dev,
 	struct iw_request_info *info,
 	struct iw_point *dwrq,
@@ -3703,14 +4609,14 @@ wl_iw_scan_get_scan(
 	int ii, j;
 	int apcnt;
 	char *event = extra, *end = extra + dwrq->length, *value;
-#if defined(WL_IW_USE_ISCAN)
 	iscan_info_t *iscan = g_iscan;
 	iscan_buf_t * p_buf;
-#endif
 	uint32  counter = 0;
+	uint8   channel;
+#if !defined(CSCAN)
 	__u16 merged_len = 0;
 	uint buflen_from_user = dwrq->length;
-
+#endif
 
 	WL_TRACE(("%s %s buflen_from_user %d:\n", dev->name, __FUNCTION__, dwrq->length));
 
@@ -3719,24 +4625,30 @@ wl_iw_scan_get_scan(
 		WL_TRACE(("%s: Not executed, reason -'SOFTAP is active'\n", __FUNCTION__));
 		return -EINVAL;
 	}
-#endif /* SOFTAP */
+#endif
 
 	if (!extra) {
-		WL_TRACE(("%s: SIOCGIWSCAN GET bad parameter\n", dev->name));
+		WL_TRACE(("%s: INVALID SIOCGIWSCAN GET bad parameter\n", dev->name));
 		return -EINVAL;
 	}
 
-#if defined(WL_IW_USE_ISCAN)
-	
-	if ((!iscan) || (iscan->sysioc_pid < 0)) {
-#elif defined(WL_IW_USE_ESCAN)
-	if (!g_escan) {
+#if defined(CONFIG_FIRST_SCAN)
+	if (g_first_broadcast_scan < BROADCAST_SCAN_FIRST_RESULT_READY) {
+		WL_TRACE(("%s %s: first ISCAN results are NOT ready yet \n", \
+			 dev->name, __FUNCTION__));
+		return -EAGAIN;
+	}
 #endif
-		return wl_iw_get_scan(dev, info, dwrq, extra);
+	
+//	if ((!iscan) || (iscan->sysioc_pid < 0)) {
+	if ((!iscan) || (iscan->tsk_ctl.thr_pid < 0)) {
+		WL_ERROR(("%ssysioc_pid\n", __FUNCTION__));
+		return EAGAIN;
 	}
 
 	
 
+#if !defined(CSCAN)
 	if (g_ss_cache_ctrl.m_timer_expired) {
 		wl_iw_free_ss_cache();
 		g_ss_cache_ctrl.m_timer_expired ^= 1;
@@ -3757,37 +4669,33 @@ wl_iw_scan_get_scan(
 		g_ss_cache_ctrl.m_prev_scan_mode = g_scan_specified_ssid;
 		g_ss_cache_ctrl.m_cons_br_scan_cnt++;
 	}
-
+#endif 
 
 	WL_TRACE(("%s: SIOCGIWSCAN GET broadcast results\n", dev->name));
 	apcnt = 0;
-#if defined(WL_IW_USE_ISCAN)
 	p_buf = iscan->list_hdr;
 	
 	while (p_buf != iscan->list_cur) {
 	    list = &((wl_iscan_results_t*)p_buf->iscan_buf)->results;
-#elif defined(WL_IW_USE_ESCAN)
-//	{	LGE_CHANGE_S [WiFi][kyoohyun.kim@lge.com] Ioctl Fail bug fix  
-		list = (wl_scan_results_t *)g_escan->escan_buf;
-/* LGE_CHANGE_S [WiFi][kyoohyun.kim@lge.com] Ioctl Fail bug fix  */
-		if (list->count > 0)
-		{
-/* LGE_CHANGE_E [WiFi][kyoohyun.kim@lge.com] Ioctl Fail bug fix  */ 	
-#endif
+
 	    counter += list->count;
 
 	    if (list->version != WL_BSS_INFO_VERSION) {
-			WL_ERROR(("list->version %d != WL_BSS_INFO_VERSION\n", list->version));
+		WL_ERROR(("%s : list->version %d != WL_BSS_INFO_VERSION\n", \
+			 __FUNCTION__, list->version));
 			return -EINVAL;
 	    }
 
 	    bi = NULL;
 	    for (ii = 0; ii < list->count && apcnt < IW_MAX_AP; apcnt++, ii++) {
 		bi = bi ? (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length)) : list->bss_info;
-#if defined(WL_IW_USE_ISCAN)
-		ASSERT(((uintptr)bi + dtoh32(bi->length)) <= ((uintptr)list +
-			WLC_IW_ISCAN_MAXLEN));
-#endif
+
+		if ((dtoh32(bi->length) > WLC_IW_ISCAN_MAXLEN) ||
+		    (((uintptr)bi + dtoh32(bi->length)) > ((uintptr)list + WLC_IW_ISCAN_MAXLEN))) {
+			WL_ERROR(("%s: Scan results out of bounds: %u\n", \
+								__FUNCTION__, dtoh32(bi->length)));
+			return -E2BIG;
+		}
 
 		
 		if (event + ETHER_ADDR_LEN + bi->SSID_len + IW_EV_UINT_LEN + IW_EV_FREQ_LEN +
@@ -3817,8 +4725,9 @@ wl_iw_scan_get_scan(
 
 		
 		iwe.cmd = SIOCGIWFREQ;
-		iwe.u.freq.m = wf_channel2mhz(CHSPEC_CHANNEL(bi->chanspec),
-			CHSPEC_CHANNEL(bi->chanspec) <= CH_MAX_2G_CHANNEL ?
+		channel = (bi->ctl_ch == 0) ? CHSPEC_CHANNEL(bi->chanspec) : bi->ctl_ch;
+		iwe.u.freq.m = wf_channel2mhz(channel,
+			channel <= CH_MAX_2G_CHANNEL ?
 			WF_CHAN_FACTOR_2_4_G : WF_CHAN_FACTOR_5_G);
 		iwe.u.freq.e = 6;
 		event = IWE_STREAM_ADD_EVENT(info, event, end, &iwe, IW_EV_FREQ_LEN);
@@ -3859,19 +4768,23 @@ wl_iw_scan_get_scan(
 			event = value;
 		}
 	    }
-#if defined(WL_IW_USE_ISCAN)
 	    p_buf = p_buf->next;
-#endif
 	} 
 
 	dwrq->length = event - extra;
 	dwrq->flags = 0;	
 
+#if !defined(CSCAN)
 	
 	wl_iw_merge_scan_cache(info, event, buflen_from_user - dwrq->length, &merged_len);
 	dwrq->length += merged_len;
 	wl_iw_run_ss_cache_timer(0);
 	wl_iw_run_ss_cache_timer(1);
+#endif 
+	
+#if defined(CONFIG_FIRST_SCAN)
+	g_first_broadcast_scan = BROADCAST_SCAN_FIRST_RESULT_CONSUMED;
+#endif 
 
 	WL_TRACE(("%s return to WE %d bytes APs=%d\n", __FUNCTION__, dwrq->length, counter));
 
@@ -3888,12 +4801,17 @@ wl_iw_set_essid(
 )
 {
 	int error;
+	wl_join_params_t join_params;
+	int join_params_size;
 
 	WL_TRACE(("%s: SIOCSIWESSID\n", dev->name));
 
 	
+	
 	memset(&g_ssid, 0, sizeof(g_ssid));
 
+	CHECK_EXTRA_FOR_NULL(extra);
+
 	if (dwrq->length && extra) {
 #if WIRELESS_EXT > 20
 		g_ssid.SSID_len = MIN(sizeof(g_ssid.SSID), dwrq->length);
@@ -3906,9 +4824,29 @@ wl_iw_set_essid(
 		g_ssid.SSID_len = 0;
 	}
 	g_ssid.SSID_len = htod32(g_ssid.SSID_len);
-	if ((error = dev_wlc_ioctl(dev, WLC_SET_SSID, &g_ssid, sizeof(g_ssid))))
+
+	
+	memset(&join_params, 0, sizeof(join_params));
+	join_params_size = sizeof(join_params.ssid);
+
+	memcpy(&join_params.ssid.SSID, g_ssid.SSID, g_ssid.SSID_len);
+	join_params.ssid.SSID_len = htod32(g_ssid.SSID_len);
+	memcpy(&join_params.params.bssid, &ether_bcast, ETHER_ADDR_LEN);
+
+	
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+	wl_iw_ch_to_chanspec(g_wl_iw_params.target_channel, &join_params, &join_params_size);
+#endif
+
+	if ((error = dev_wlc_ioctl(dev, WLC_SET_SSID, &join_params, join_params_size))) {
+		WL_ERROR(("Invalid ioctl data=%d\n", error));
 		return error;
+	}
 
+	if (g_ssid.SSID_len) {
+		WL_TRACE(("%s: join SSID=%s ch=%d\n", __FUNCTION__, \
+			g_ssid.SSID,  g_wl_iw_params.target_channel));
+	}
 	return 0;
 }
 
@@ -3925,10 +4863,6 @@ wl_iw_get_essid(
 
 	WL_TRACE(("%s: SIOCGIWESSID\n", dev->name));
 
-// WBT Fix TD# 37085, 37086
-	memset(&ssid, 0, sizeof(wlc_ssid_t));
-//
-
 	if (!extra)
 		return -EINVAL;
 
@@ -4007,9 +4941,6 @@ static int wl_iw_set_rate(
 
 	WL_TRACE(("%s: SIOCSIWRATE\n", dev->name));
 
-// WBT Fix TD# 37087, 37088
-	memset(&rateset, 0, sizeof(wl_rateset_t));
-//
 	
 	if ((error = dev_wlc_ioctl(dev, WLC_GET_CURR_RATESET, &rateset, sizeof(rateset))))
 		return error;
@@ -4065,9 +4996,7 @@ static int wl_iw_get_rate(
 	char *extra
 )
 {
-// WBT Fix TD# 37089
-	int error, rate = 0;
-//
+	int error, rate;
 
 	WL_TRACE(("%s: SIOCGIWRATE\n", dev->name));
 
@@ -4222,9 +5151,7 @@ wl_iw_get_txpow(
 	char *extra
 )
 {
-// WBT Fix TD# 37090
-	int error, disable = 0, txpwrdbm = 0;
-//
+	int error, disable, txpwrdbm;
 	uint8 result;
 
 	WL_TRACE(("%s: SIOCGIWTXPOW\n", dev->name));
@@ -4299,9 +5226,7 @@ wl_iw_get_retry(
 	char *extra
 )
 {
-// WBT Fix TD# 37091, 37092
-	int error, lrl = 0, srl = 0;
-//
+	int error, lrl, srl;
 
 	WL_TRACE(("%s: SIOCGIWRETRY\n", dev->name));
 
@@ -4438,9 +5363,7 @@ wl_iw_get_encode(
 )
 {
 	wl_wsec_key_t key;
-// WBT Fix TD# 37093, 37094
-	int error, val, wsec = 0, auth = 0;
-//
+	int error, val, wsec, auth;
 
 	WL_TRACE(("%s: SIOCGIWENCODE\n", dev->name));
 
@@ -4474,7 +5397,7 @@ wl_iw_get_encode(
 	wsec = dtoh32(wsec);
 	auth = dtoh32(auth);
 	
-	dwrq->length = MIN(IW_ENCODING_TOKEN_MAX, key.len);
+	dwrq->length = MIN(DOT11_MAX_KEY_SIZE, key.len);
 
 	
 	dwrq->flags = key.index + 1;
@@ -4506,9 +5429,7 @@ wl_iw_set_power(
 
 	WL_TRACE(("%s: SIOCSIWPOWER\n", dev->name));
 
-	//bill.jung@lge.com - Don't use legacy power save mode.
-	//pm = vwrq->disabled ? PM_OFF : PM_MAX;
-	pm = vwrq->disabled ? PM_OFF : PM_FAST;
+	pm = vwrq->disabled ? PM_OFF : PM_MAX;
 
 	pm = htod32(pm);
 	if ((error = dev_wlc_ioctl(dev, WLC_SET_PM, &pm, sizeof(pm))))
@@ -4525,8 +5446,7 @@ wl_iw_get_power(
 	char *extra
 )
 {
-// WBT Fix TD# 37095
-	int error, pm = 0;
+	int error, pm;
 
 	WL_TRACE(("%s: SIOCGIWPOWER\n", dev->name));
 
@@ -4549,6 +5469,21 @@ wl_iw_set_wpaie(
 	char *extra
 )
 {
+	uchar buf[WLC_IOCTL_SMLEN] = {0};
+	uchar *p = buf;
+	int wapi_ie_size;
+
+	WL_TRACE(("%s: SIOCSIWGENIE\n", dev->name));
+
+	CHECK_EXTRA_FOR_NULL(extra);
+
+	if (extra[0] == DOT11_MNG_WAPI_ID)
+	{
+		wapi_ie_size = iwp->length;
+		memcpy(p, extra, iwp->length);
+		dev_wlc_bufvar_set(dev, "wapiie", buf, wapi_ie_size);
+	}
+	else
 		dev_wlc_bufvar_set(dev, "wpaie", extra, iwp->length);
 
 	return 0;
@@ -4580,7 +5515,10 @@ wl_iw_set_encodeext(
 	int error;
 	struct iw_encode_ext *iwe;
 
-	WL_TRACE(("%s: SIOCSIWENCODEEXT\n", dev->name));
+	WL_WSEC(("%s: dev:%s, got ioctl SIOCSIWENCODEEXT\n",
+		__FUNCTION__, dev->name));
+
+	CHECK_EXTRA_FOR_NULL(extra);
 
 	memset(&key, 0, sizeof(key));
 	iwe = (struct iw_encode_ext *)extra;
@@ -4647,37 +5585,160 @@ wl_iw_set_encodeext(
 			key.iv_initialized = TRUE;
 		}
 
-		switch (iwe->alg) {
-			case IW_ENCODE_ALG_NONE:
-				key.algo = CRYPTO_ALGO_OFF;
-				break;
-			case IW_ENCODE_ALG_WEP:
-				if (iwe->key_len == WEP1_KEY_SIZE)
-					key.algo = CRYPTO_ALGO_WEP1;
-				else
-					key.algo = CRYPTO_ALGO_WEP128;
-				break;
-			case IW_ENCODE_ALG_TKIP:
-				key.algo = CRYPTO_ALGO_TKIP;
-				break;
-			case IW_ENCODE_ALG_CCMP:
-				key.algo = CRYPTO_ALGO_AES_CCM;
-				break;
-			default:
-				break;
+		switch (iwe->alg) {
+			case IW_ENCODE_ALG_NONE:
+				key.algo = CRYPTO_ALGO_OFF;
+				break;
+			case IW_ENCODE_ALG_WEP:
+				if (iwe->key_len == WEP1_KEY_SIZE)
+					key.algo = CRYPTO_ALGO_WEP1;
+				else
+					key.algo = CRYPTO_ALGO_WEP128;
+				break;
+			case IW_ENCODE_ALG_TKIP:
+				key.algo = CRYPTO_ALGO_TKIP;
+				break;
+			case IW_ENCODE_ALG_CCMP:
+				key.algo = CRYPTO_ALGO_AES_CCM;
+				break;
+			case IW_ENCODE_ALG_SM4:
+				key.algo = CRYPTO_ALGO_SMS4;
+				if (iwe->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
+					key.flags &= ~WL_PRIMARY_KEY;
+				}
+				break;
+			default:
+				break;
+		}
+		swap_key_from_BE(&key);
+
+		dhd_wait_pend8021x(dev);
+
+		error = dev_wlc_ioctl(dev, WLC_SET_KEY, &key, sizeof(key));
+		if (error)
+			return error;
+	}
+	return 0;
+}
+
+#if WIRELESS_EXT > 17
+#ifdef BCMWPA2
+struct {
+	pmkid_list_t pmkids;
+	pmkid_t foo[MAXPMKID-1];
+} pmkid_list;
+
+static int
+wl_iw_set_pmksa(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	struct iw_param *vwrq,
+	char *extra
+)
+{
+	struct iw_pmksa *iwpmksa;
+	uint i;
+	int ret = 0;
+	char eabuf[ETHER_ADDR_STR_LEN];
+
+	WL_WSEC(("%s: SIOCSIWPMKSA\n", dev->name));
+
+	CHECK_EXTRA_FOR_NULL(extra);
+
+	iwpmksa = (struct iw_pmksa *)extra;
+	bzero((char *)eabuf, ETHER_ADDR_STR_LEN);
+
+	if (iwpmksa->cmd == IW_PMKSA_FLUSH) {
+		WL_WSEC(("wl_iw_set_pmksa - IW_PMKSA_FLUSH\n"));
+		bzero((char *)&pmkid_list, sizeof(pmkid_list));
+	}
+
+	else if (iwpmksa->cmd == IW_PMKSA_REMOVE) {
+		{
+			pmkid_list_t pmkid, *pmkidptr;
+			uint j;
+			pmkidptr = &pmkid;
+
+			bcopy(&iwpmksa->bssid.sa_data[0], &pmkidptr->pmkid[0].BSSID, \
+				ETHER_ADDR_LEN);
+			bcopy(&iwpmksa->pmkid[0], &pmkidptr->pmkid[0].PMKID, WPA2_PMKID_LEN);
+
+			WL_WSEC(("wl_iw_set_pmksa,IW_PMKSA_REMOVE - PMKID: %s = ",
+				bcm_ether_ntoa(&pmkidptr->pmkid[0].BSSID,
+				eabuf)));
+			for (j = 0; j < WPA2_PMKID_LEN; j++)
+				WL_WSEC(("%02x ", pmkidptr->pmkid[0].PMKID[j]));
+			WL_WSEC(("\n"));
 		}
-		swap_key_from_BE(&key);
 
-#if defined(BCMDONGLEHOST)
-		dhd_wait_pend8021x(dev);
-#endif 
+		for (i = 0; i < pmkid_list.pmkids.npmkid; i++)
+			if (!bcmp(&iwpmksa->bssid.sa_data[0], &pmkid_list.pmkids.pmkid[i].BSSID,
+				ETHER_ADDR_LEN))
+				break;
 
-		error = dev_wlc_ioctl(dev, WLC_SET_KEY, &key, sizeof(key));
-		if (error)
-			return error;
+		if ((pmkid_list.pmkids.npmkid > 0) && (i < pmkid_list.pmkids.npmkid)) {
+			bzero(&pmkid_list.pmkids.pmkid[i], sizeof(pmkid_t));
+			for (; i < (pmkid_list.pmkids.npmkid - 1); i++) {
+				bcopy(&pmkid_list.pmkids.pmkid[i+1].BSSID,
+					&pmkid_list.pmkids.pmkid[i].BSSID,
+					ETHER_ADDR_LEN);
+				bcopy(&pmkid_list.pmkids.pmkid[i+1].PMKID,
+					&pmkid_list.pmkids.pmkid[i].PMKID,
+					WPA2_PMKID_LEN);
+			}
+			pmkid_list.pmkids.npmkid--;
+		}
+		else
+			ret = -EINVAL;
 	}
-	return 0;
+
+	else if (iwpmksa->cmd == IW_PMKSA_ADD) {
+		for (i = 0; i < pmkid_list.pmkids.npmkid; i++)
+			if (!bcmp(&iwpmksa->bssid.sa_data[0], &pmkid_list.pmkids.pmkid[i].BSSID,
+				ETHER_ADDR_LEN))
+				break;
+		if (i < MAXPMKID) {
+			bcopy(&iwpmksa->bssid.sa_data[0],
+				&pmkid_list.pmkids.pmkid[i].BSSID,
+				ETHER_ADDR_LEN);
+			bcopy(&iwpmksa->pmkid[0], &pmkid_list.pmkids.pmkid[i].PMKID,
+				WPA2_PMKID_LEN);
+			if (i == pmkid_list.pmkids.npmkid)
+				pmkid_list.pmkids.npmkid++;
+		}
+		else
+			ret = -EINVAL;
+		{
+			uint j;
+			uint k;
+			k = pmkid_list.pmkids.npmkid;
+			WL_WSEC(("wl_iw_set_pmksa,IW_PMKSA_ADD - PMKID: %s = ",
+				bcm_ether_ntoa(&pmkid_list.pmkids.pmkid[k].BSSID,
+				eabuf)));
+			for (j = 0; j < WPA2_PMKID_LEN; j++)
+				WL_WSEC(("%02x ", pmkid_list.pmkids.pmkid[k].PMKID[j]));
+			WL_WSEC(("\n"));
+		}
+	}
+	WL_WSEC(("PRINTING pmkid LIST - No of elements %d\n", pmkid_list.pmkids.npmkid));
+	for (i = 0; i < pmkid_list.pmkids.npmkid; i++) {
+		uint j;
+		WL_WSEC(("PMKID[%d]: %s = ", i,
+			bcm_ether_ntoa(&pmkid_list.pmkids.pmkid[i].BSSID,
+			eabuf)));
+		for (j = 0; j < WPA2_PMKID_LEN; j++)
+			WL_WSEC(("%02x ", pmkid_list.pmkids.pmkid[i].PMKID[j]));
+		WL_WSEC(("\n"));
+	}
+	WL_WSEC(("\n"));
+
+	if (!ret)
+		ret = dev_wlc_bufvar_set(dev, "pmkid_info", (char *)&pmkid_list, \
+			sizeof(pmkid_list));
+	return ret;
 }
+#endif 
+#endif 
 
 static int
 wl_iw_get_encodeext(
@@ -4687,7 +5748,8 @@ wl_iw_get_encodeext(
 	char *extra
 )
 {
-	WL_TRACE(("%s: SIOCGIWENCODEEXT\n", dev->name));
+	WL_WSEC(("%s: dev:%s, got ioctl SIOCSIWENCODEEXT\n",
+		__FUNCTION__, dev->name));
 	return 0;
 }
 
@@ -4705,18 +5767,22 @@ wl_iw_set_wpaauth(
 	int val = 0;
 	wl_iw_t *iw = *(wl_iw_t **)netdev_priv(dev);
 
-	WL_TRACE(("%s: SIOCSIWAUTH\n", dev->name));
+	WL_WSEC(("%s: dev:%s got ioctl SIOCSIWAUTH\n",
+		__FUNCTION__,  dev->name));
 
 #if defined(SOFTAP)
 	if (ap_cfg_running) {
 		WL_TRACE(("%s: Not executed, reason -'SOFTAP is active'\n", __FUNCTION__));
 		return 0;
 	}
-#endif /* SOFTAP */
+#endif
 
 	paramid = vwrq->flags & IW_AUTH_INDEX;
 	paramval = vwrq->value;
 
+	WL_WSEC(("%s: SIOCSIWAUTH, paramid = 0x%0x, paramval = 0x%0x\n",
+		dev->name, paramid, paramval));
+
 	switch (paramid) {
 	case IW_AUTH_WPA_VERSION:
 		
@@ -4728,7 +5794,9 @@ wl_iw_set_wpaauth(
 		else if (paramval & IW_AUTH_WPA_VERSION_WPA2)
 			val = WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED;
 #endif 
-		WL_INFORM(("%s: %d: setting wpa_auth to 0x%0x\n", __FUNCTION__, __LINE__, val));
+		else if (paramval & IW_AUTH_WAPI_VERSION_1)
+			val = WPA_AUTH_WAPI;
+		WL_WSEC(("%s: %d: setting wpa_auth to 0x%0x\n", __FUNCTION__, __LINE__, val));
 		if ((error = dev_wlc_intvar_set(dev, "wpa_auth", val)))
 			return error;
 		break;
@@ -4742,6 +5810,8 @@ wl_iw_set_wpaauth(
 			val = TKIP_ENABLED;
 		if (paramval & IW_AUTH_CIPHER_CCMP)
 			val = AES_ENABLED;
+		if (paramval & IW_AUTH_CIPHER_SMS4)
+			val = SMS4_ENABLED;
 
 		if (paramid == IW_AUTH_CIPHER_PAIRWISE) {
 			iw->pwsec = val;
@@ -4752,14 +5822,32 @@ wl_iw_set_wpaauth(
 			val |= iw->pwsec;
 		}
 
-		if ((error = dev_wlc_intvar_set(dev, "wsec", val)))
+		if (iw->privacy_invoked && !val) {
+			WL_WSEC(("%s: %s: 'Privacy invoked' TRUE but clearing wsec, assuming "
+			         "we're a WPS enrollee\n", dev->name, __FUNCTION__));
+			if ((error = dev_wlc_intvar_set(dev, "is_WPS_enrollee", TRUE))) {
+				WL_ERROR(("Failed to set iovar is_WPS_enrollee\n"));
+				return error;
+			}
+		} else if (val) {
+			if ((error = dev_wlc_intvar_set(dev, "is_WPS_enrollee", FALSE))) {
+				WL_ERROR(("Failed to clear iovar is_WPS_enrollee\n"));
+			return error;
+			}
+		}
+
+		if ((error = dev_wlc_intvar_set(dev, "wsec", val))) {
+			WL_ERROR(("Failed to set 'wsec'iovar\n"));
 			return error;
+		}
 
 		break;
 
 	case IW_AUTH_KEY_MGMT:
-		if ((error = dev_wlc_intvar_get(dev, "wpa_auth", &val)))
+		if ((error = dev_wlc_intvar_get(dev, "wpa_auth", &val))) {
+			WL_ERROR(("Failed to get 'wpa_auth'iovar\n"));
 			return error;
+		}
 
 		if (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED)) {
 			if (paramval & IW_AUTH_KEY_MGMT_PSK)
@@ -4775,44 +5863,54 @@ wl_iw_set_wpaauth(
 				val = WPA2_AUTH_UNSPECIFIED;
 		}
 #endif 
-		WL_INFORM(("%s: %d: setting wpa_auth to %d\n", __FUNCTION__, __LINE__, val));
-		if ((error = dev_wlc_intvar_set(dev, "wpa_auth", val)))
+		if (paramval & (IW_AUTH_KEY_MGMT_WAPI_PSK | IW_AUTH_KEY_MGMT_WAPI_CERT))
+			val = WPA_AUTH_WAPI;
+		WL_WSEC(("%s: %d: setting wpa_auth to %d\n", __FUNCTION__, __LINE__, val));
+		if ((error = dev_wlc_intvar_set(dev, "wpa_auth", val))) {
+			WL_ERROR(("Failed to set 'wpa_auth'iovar\n"));
 			return error;
+		}
+
 		break;
 	case IW_AUTH_TKIP_COUNTERMEASURES:
-		dev_wlc_bufvar_set(dev, "tkip_countermeasures", (char *)&paramval, 1);
+		if ((error = dev_wlc_bufvar_set(dev, "tkip_countermeasures", \
+						(char *)&paramval, sizeof(paramval))))
+			WL_WSEC(("%s: tkip_countermeasures failed %d\n", __FUNCTION__, error));
 		break;
 
 	case IW_AUTH_80211_AUTH_ALG:
-		/* open shared */
-		WL_INFORM(("Setting the D11auth %d\n", paramval));
+		
+		WL_WSEC(("Setting the D11auth %d\n", paramval));
 		if (paramval == IW_AUTH_ALG_OPEN_SYSTEM)
-			val = DOT11_OPEN_SYSTEM;
+			val = 0;
 		else if (paramval == IW_AUTH_ALG_SHARED_KEY)
-			val = DOT11_SHARED_KEY;
+			val = 1;
 		else if (paramval == (IW_AUTH_ALG_OPEN_SYSTEM | IW_AUTH_ALG_SHARED_KEY))
-			val = DOT11_OPEN_SHARED;
+			val = 2;
 		else
 			error = 1;
-
 		if (!error && (error = dev_wlc_intvar_set(dev, "auth", val)))
 			return error;
-
 		break;
 
 	case IW_AUTH_WPA_ENABLED:
 		if (paramval == 0) {
 			iw->pwsec = 0;
 			iw->gwsec = 0;
-			if ((error = dev_wlc_intvar_get(dev, "wsec", &val)))
+			if ((error = dev_wlc_intvar_get(dev, "wsec", &val))) {
+				WL_ERROR(("Failed to get 'wsec'iovar\n"));
 				return error;
+			}
 			if (val & (TKIP_ENABLED | AES_ENABLED)) {
 				val &= ~(TKIP_ENABLED | AES_ENABLED);
 				dev_wlc_intvar_set(dev, "wsec", val);
 			}
 			val = 0;
-		WL_INFORM(("%s: %d: setting wpa_auth to %d\n", __FUNCTION__, __LINE__, val));
-			dev_wlc_intvar_set(dev, "wpa_auth", 0);
+
+			WL_INFORM(("%s: %d: setting wpa_auth to %d\n",
+				__FUNCTION__, __LINE__, val));
+			error = dev_wlc_intvar_set(dev, "wpa_auth", 0);
+			WL_ERROR(("Failed to set 'wpa_auth'iovar\n"));
 			return error;
 		}
 
@@ -4820,11 +5918,17 @@ wl_iw_set_wpaauth(
 		break;
 
 	case IW_AUTH_DROP_UNENCRYPTED:
-		dev_wlc_bufvar_set(dev, "wsec_restrict", (char *)&paramval, 1);
+		error = dev_wlc_bufvar_set(dev, "wsec_restrict", \
+				   (char *)&paramval, sizeof(paramval));
+		if (error)
+			WL_ERROR(("%s: wsec_restrict %d\n", __FUNCTION__, error));
 		break;
 
 	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
-		dev_wlc_bufvar_set(dev, "rx_unencrypted_eapol", (char *)&paramval, 1);
+		error = dev_wlc_bufvar_set(dev, "rx_unencrypted_eapol", \
+				   (char *)&paramval, sizeof(paramval));
+		if (error)
+			WL_WSEC(("%s: rx_unencrypted_eapol %d\n", __FUNCTION__, error));
 		break;
 
 #if WIRELESS_EXT > 17
@@ -4833,7 +5937,6 @@ wl_iw_set_wpaauth(
 		
 		break;
 	case IW_AUTH_PRIVACY_INVOKED: {
-		// louislee : modified for WPS {
 		int wsec;
 
 		if (paramval == 0) {
@@ -4846,8 +5949,10 @@ wl_iw_set_wpaauth(
 			iw->privacy_invoked = TRUE;
 			if ((error = dev_wlc_intvar_get(dev, "wsec", &wsec)))
 				return error;
+
 			if (!(IW_WSEC_ENABLED(wsec))) {
-				/* if privacy is true, but wsec is false, we are a WPS enrollee */
+				
+
 				if ((error = dev_wlc_intvar_set(dev, "is_WPS_enrollee", TRUE))) {
 					WL_WSEC(("Failed to set iovar is_WPS_enrollee\n"));
 					return error;
@@ -4859,11 +5964,27 @@ wl_iw_set_wpaauth(
 				}
 			}
 		}
-		// louislee : modified for WPS }
-
 		break;
 	}
 #endif 
+	case IW_AUTH_WAPI_ENABLED:
+		if ((error = dev_wlc_intvar_get(dev, "wsec", &val)))
+			return error;
+		if (paramval) {
+			val |= SMS4_ENABLED;
+			if ((error = dev_wlc_intvar_set(dev, "wsec", val))) {
+				WL_ERROR(("%s: setting wsec to 0x%0x returned error %d\n",
+					__FUNCTION__, val, error));
+				return error;
+			}
+			if ((error = dev_wlc_intvar_set(dev, "wpa_auth", WPA_AUTH_WAPI))) {
+				WL_ERROR(("%s: setting wpa_auth(WPA_AUTH_WAPI) returned %d\n",
+					__FUNCTION__, error));
+				return error;
+			}
+		}
+
+		break;
 	default:
 		break;
 	}
@@ -4909,46 +6030,22 @@ wl_iw_get_wpaauth(
 		break;
 	case IW_AUTH_CIPHER_PAIRWISE:
 	case IW_AUTH_CIPHER_GROUP:
-		val = 0; // louislee : added
-		/* none, wep40, tkip, ccmp, wep104 */
-		/* wsec: none, wep40, tkip, aes, wep104 */
-		if (paramval & (IW_AUTH_CIPHER_WEP40 | IW_AUTH_CIPHER_WEP104))
-			val =   WEP_ENABLED;
-		if (paramval & IW_AUTH_CIPHER_TKIP)
-			val = TKIP_ENABLED;
-		if (paramval & IW_AUTH_CIPHER_CCMP)
-			val = AES_ENABLED;
-#ifdef BCMWAPI_WPI
-		if (paramval & IW_AUTH_CIPHER_SMS4)
-			val = SMS4_ENABLED;
-#endif
-		// louislee : modified for WPS {
-		if (paramid == IW_AUTH_CIPHER_PAIRWISE) {
-			iw->pwsec = val;
-			val |= iw->gwsec;
-		} else {
-			iw->gwsec = val;
-			val |= iw->pwsec;
-		}
-
-		if (iw->privacy_invoked && !val) {
-			WL_WSEC(("%s: %s: 'Privacy invoked' TRUE but clearing wsec, assuming "
-						"we're a WPS enrollee\n", dev->name, __FUNCTION__));
-			if ((error = dev_wlc_intvar_set(dev, "is_WPS_enrollee", TRUE))) {
-				WL_WSEC(("Failed to set iovar is_WPS_enrollee\n"));
-				return error;
-		}
-		} else if (val) {
-			if ((error = dev_wlc_intvar_set(dev, "is_WPS_enrollee", FALSE))) {
-				WL_WSEC(("Failed to clear iovar is_WPS_enrollee\n"));
-				return error;
+		if (paramid == IW_AUTH_CIPHER_PAIRWISE)
+			val = iw->pwsec;
+		else
+			val = iw->gwsec;
+
+		paramval = 0;
+		if (val) {
+			if (val & WEP_ENABLED)
+				paramval |= (IW_AUTH_CIPHER_WEP40 | IW_AUTH_CIPHER_WEP104);
+			if (val & TKIP_ENABLED)
+				paramval |= (IW_AUTH_CIPHER_TKIP);
+			if (val & AES_ENABLED)
+				paramval |= (IW_AUTH_CIPHER_CCMP);
 			}
-		}
-		
-		if ((error = dev_wlc_intvar_set(dev, "wsec", val)))
-			return error;
-		// louislee : modified for WPS }
-		
+		else
+			paramval = IW_AUTH_CIPHER_NONE;
 		break;
 	case IW_AUTH_KEY_MGMT:
 		
@@ -4961,15 +6058,24 @@ wl_iw_get_wpaauth(
 
 		break;
 	case IW_AUTH_TKIP_COUNTERMEASURES:
-		dev_wlc_bufvar_get(dev, "tkip_countermeasures", (char *)&paramval, 1);
+		error = dev_wlc_bufvar_get(dev, "tkip_countermeasures", \
+							(char *)&paramval, sizeof(paramval));
+		if (error)
+			WL_ERROR(("%s get tkip_countermeasures %d\n", __FUNCTION__, error));
 		break;
 
 	case IW_AUTH_DROP_UNENCRYPTED:
-		dev_wlc_bufvar_get(dev, "wsec_restrict", (char *)&paramval, 1);
+		error = dev_wlc_bufvar_get(dev, "wsec_restrict", \
+					   (char *)&paramval, sizeof(paramval));
+		if (error)
+			WL_ERROR(("%s get wsec_restrict %d\n", __FUNCTION__, error));
 		break;
 
 	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
-		dev_wlc_bufvar_get(dev, "rx_unencrypted_eapol", (char *)&paramval, 1);
+		error = dev_wlc_bufvar_get(dev, "rx_unencrypted_eapol", \
+						   (char *)&paramval, sizeof(paramval));
+		if (error)
+			WL_ERROR(("%s get rx_unencrypted_eapol %d\n", __FUNCTION__, error));
 		break;
 
 	case IW_AUTH_80211_AUTH_ALG:
@@ -4992,197 +6098,19 @@ wl_iw_get_wpaauth(
 #if WIRELESS_EXT > 17
 	case IW_AUTH_ROAMING_CONTROL:
 		WL_ERROR(("%s: IW_AUTH_ROAMING_CONTROL\n", __FUNCTION__));
-		
+
 		break;
 	case IW_AUTH_PRIVACY_INVOKED:
-		WL_ERROR(("%s: IW_AUTH_PRIVACY_INVOKED\n", __FUNCTION__));
-		break;
-#endif 
-	}
-	vwrq->value = paramval;
-	return 0;
-}
-#endif 
-
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-05-14, support private command */
-#if defined(CONFIG_LGE_BCM432X_PATCH)
-static int
-wl_iw_set_powermode(
-	struct net_device *dev,
-	struct iw_request_info *info,
-	union iwreq_data *wrqu,
-	char *extra
-)
-{
-	int mode = -1;
-	int error;
-	char *p = extra;
-
-	if (sscanf(extra, "%*s %d", &mode) != 1)
-		return -EINVAL;
-
-	switch (mode) {
-	case 0: mode = 2; break; /* Fast PS mode */
-	case 1: mode = 0; break; /* No PS mode */
-	default: return -EINVAL;
-	}
-	error = dev_wlc_ioctl(dev, WLC_SET_PM, &mode, sizeof(mode));
-	p += snprintf(p, MAX_WX_STRING, error < 0 ? "FAIL\n" : "OK\n");
-	wrqu->data.length = p - extra + 1;
-	return error;
-}
-
-static int
-wl_iw_set_scan_channels(
-	struct net_device *dev,
-	struct iw_request_info *info,
-	union iwreq_data *wrqu,
-	char *extra
-)
-{
-	uint32 chan_buf[WL_NUMCHANNELS + 1];
-	wl_uint32_list_t *list;
-	int nchan;
-	char buf[WLC_CNTRY_BUF_SZ];
-	int error;
-	char *p = extra;
-
-	if (sscanf(extra, "%*s %d", &nchan) != 1) {
-		list = (wl_uint32_list_t *)(void *)chan_buf;
-		list->count = htod32(WL_NUMCHANNELS);
-		if ((error = dev_wlc_ioctl(dev, WLC_GET_VALID_CHANNELS,
-				chan_buf, sizeof(chan_buf))) < 0)
-			return error;
-		p += snprintf(p, MAX_WX_STRING,
-				"Scan-Channels = %d", dtoh32(list->count));
-		wrqu->data.length = p - extra + 1;
-		return error;
-	}
-
-	switch (nchan) {
-	//bill.jung TX power issue. In north america we use 'XW'
-	//case 11: strcpy(buf, "US"); break;
-	case 11: strcpy(buf, "XW"); break;	
-	case 13: strcpy(buf, "AU"); break;
-	case 14: strcpy(buf, "JP"); break;
-	default: return -EINVAL;
-	}
-	error = dev_wlc_ioctl(dev, WLC_SET_COUNTRY, buf, sizeof(buf));
-	p += snprintf(p, MAX_WX_STRING, error < 0 ? "FAIL\n" : "OK\n");
-	wrqu->data.length = p - extra + 1;
-	return error;
-}
-
-static int
-wl_iw_set_roam_off(
-	struct net_device *dev,
-	struct iw_request_info *info,
-	union iwreq_data *wrqu,
-	char *extra
-)
-{
-	uint roamvar;
-	int error;
-	char *p = extra;
-	char iovbuf[WLC_IOCTL_SMLEN];	/*  Room for "event_msgs" + '\0' + bitvec  */
-	int iolen;
-
-	if (sscanf(extra, "%*s %d", &roamvar) != 1)
-		return -EINVAL;
-
-	switch (roamvar) {
-		case 0: break; /* roam_off 0 */
-		case 1: break; /* roam_off 1 */
-		default: return -EINVAL;
-	}
-
-	iolen = bcm_mkiovar("roam_off", (char *)&roamvar, 4, iovbuf, sizeof(iovbuf));
-	ASSERT(iolen);	
-	error = dev_wlc_ioctl(dev, WLC_SET_VAR, iovbuf, iolen);
-	
-	p += snprintf(p, MAX_WX_STRING, error < 0 ? "FAIL\n" : "OK\n");
-	wrqu->data.length = p - extra + 1;
-	return error;
-}
-
-//PM=1, wme_apsd=1, wme_qosinfo=0x3, wme_apsd_trigger=1000, wme_auto_trigger=0
-static int wl_iw_voip_start(struct net_device *dev)
-{
-	int error = 0;
-	int val;
-
-	//by sjark 100818
-	val = 1;
-	error = dev_wlc_ioctl(dev, WLC_SET_PM, &val, sizeof(val));
-	if(error) WL_ERROR(("SET PM fail. error = %d",error));
-
-	val = 20;
-	error =dev_wlc_intvar_set(dev, "pspoll_prd", val);
-	if(error) WL_ERROR(("SET pspoll_prd fail. error = %d",error));
-
-#if 0
-	val = 1;
-	error =dev_wlc_intvar_set(dev, "wme_apsd", val);                //need wl down
-	if(error) WL_ERROR(("SET wme_apsd fail. error = %d",error));
-
-	val = 0x3;
-	error =dev_wlc_intvar_set(dev, "wme_qosinfo", val);             //need wl down
-	if(error) WL_ERROR(("SET wme_qosinfo fail. error = %d",error));
-
-	val = 1000;
-	error =dev_wlc_intvar_set(dev, "wme_apsd_trigger", val);
-	if(error) WL_ERROR(("SET wme_apsd_trigger fail. error = %d",error));
-
-	val = 0;
-	error =dev_wlc_intvar_set(dev, "wme_auto_trigger", val);
-	if(error) WL_ERROR(("SET wme_auto_trigger fail. error = %d",error));
-#endif
-
-	return error;
-}
-
-//PM=2, wme_apsd=0, wme_qosinfo=0x0, wme_apsd_trigger=0, wme_auto_trigger=1
-static int wl_iw_voip_stop(struct net_device *dev)
-{
-	int error = 0;
-	int val;
-
-	//by sjark 100818
-	val = 2;
-	error = dev_wlc_ioctl(dev, WLC_SET_PM, &val, sizeof(val));
-	if(error) WL_ERROR(("SET PM fail. error = %d",error));
-
-
-	val = 0;
-	error =dev_wlc_intvar_set(dev, "pspoll_prd", val);
-	if(error) WL_ERROR(("SET pspoll_prd fail. error = %d",error));
-
-#if 0
-	val = 0;
-	error =dev_wlc_intvar_set(dev, "wme_apsd", val);                //need wl down
-	if(error) WL_ERROR(("SET wme_apsd fail. error = %d",error));
-
-	val = 0x0;
-	error =dev_wlc_intvar_set(dev, "wme_qosinfo", val);             //need wl down
-	if(error) WL_ERROR(("SET wme_qosinfo fail. error = %d",error));
-
-	val = 0;
-	error =dev_wlc_intvar_set(dev, "wme_apsd_trigger", val);
-	if(error) WL_ERROR(("SET wme_apsd_trigger fail. error = %d",error));
-
-	val = 1;
-	error =dev_wlc_intvar_set(dev, "wme_auto_trigger", val);
-	if(error) WL_ERROR(("SET wme_auto_trigger fail. error = %d",error));
-#endif
-
-	return error;
-}
-
-
+		paramval = iw->privacy_invoked;
+		break;
 
+#endif
+	}
+	vwrq->value = paramval;
+	return 0;
+}
+#endif 
 
-#endif /* CONFIG_LGE_BCM432X_PATCH */
-/* LGE_CHANGE_E [yoohoo@lge.com] 2009-05-14, support private command */
 
 #ifdef SOFTAP
 
@@ -5344,7 +6272,10 @@ static int wl_bssiovar_mkbuf(
 	*perr = 0;
 	return iolen;
 }
-#endif /* AP_ONLY */
+#endif 
+
+
+
 
 int get_user_params(char *user_params, struct iw_point *dwrq)
 {
@@ -5361,52 +6292,496 @@ int get_user_params(char *user_params, struct iw_point *dwrq)
 	return ret;
 }
 
+
 #define strtoul(nptr, endptr, base) bcm_strtoul((nptr), (endptr), (base))
 
-#ifdef SOFTAP
 
+#if defined(CSCAN)
+
+static int
+wl_iw_combined_scan_set(struct net_device *dev, wlc_ssid_t* ssids_local, int nssid, int nchan)
+{
+	int params_size = WL_SCAN_PARAMS_FIXED_SIZE + WL_NUMCHANNELS * sizeof(uint16);
+	int err = 0;
+	char *p;
+	int i;
+	iscan_info_t *iscan = g_iscan;
+
+	WL_TRACE(("%s nssid=%d nchan=%d\n", __FUNCTION__, nssid, nchan));
+
+	if ((!dev) && (!g_iscan) && (!iscan->iscan_ex_params_p)) {
+		WL_ERROR(("%s error exit\n", __FUNCTION__));
+		err = -1;
+		goto exit;
+	}
+
+#ifdef PNO_SUPPORT
+	
+	if  (dhd_dev_get_pno_status(dev)) {
+		WL_ERROR(("%s: Scan called when PNO is active\n", __FUNCTION__));
+	}
+#endif 
+
+	params_size += WL_SCAN_PARAMS_SSID_MAX * sizeof(wlc_ssid_t);
+
+	
+	if (nssid > 0) {
+		i = OFFSETOF(wl_scan_params_t, channel_list) + nchan * sizeof(uint16);
+		i = ROUNDUP(i, sizeof(uint32));
+		if (i + nssid * sizeof(wlc_ssid_t) > params_size) {
+			printf("additional ssids exceed params_size\n");
+			err = -1;
+			goto exit;
+		}
+
+		p = ((char*)&iscan->iscan_ex_params_p->params) + i;
+		memcpy(p, ssids_local, nssid * sizeof(wlc_ssid_t));
+		p += nssid * sizeof(wlc_ssid_t);
+	} else {
+		p = (char*)iscan->iscan_ex_params_p->params.channel_list + nchan * sizeof(uint16);
+	}
+
+	
+	iscan->iscan_ex_params_p->params.channel_num = \
+		htod32((nssid << WL_SCAN_PARAMS_NSSID_SHIFT) | \
+					(nchan & WL_SCAN_PARAMS_COUNT_MASK));
+
+	nssid = \
+	(uint)((iscan->iscan_ex_params_p->params.channel_num >> WL_SCAN_PARAMS_NSSID_SHIFT) & \
+		               WL_SCAN_PARAMS_COUNT_MASK);
+
+	
+	params_size = (int) (p - (char*)iscan->iscan_ex_params_p + nssid * sizeof(wlc_ssid_t));
+	iscan->iscan_ex_param_size = params_size;
+
+	iscan->list_cur = iscan->list_hdr;
+	iscan->iscan_state = ISCAN_STATE_SCANING;
+	wl_iw_set_event_mask(dev);
+	mod_timer(&iscan->timer, jiffies + iscan->timer_ms*HZ/1000);
+
+	iscan->timer_on = 1;
+
+#ifdef SCAN_DUMP
+	{
+		int i;
+		WL_SCAN(("\n### List of SSIDs to scan ###\n"));
+		for (i = 0; i < nssid; i++) {
+			if (!ssids_local[i].SSID_len)
+				WL_SCAN(("%d: Broadcast scan\n", i));
+			else
+			WL_SCAN(("%d: scan  for  %s size =%d\n", i, \
+				ssids_local[i].SSID, ssids_local[i].SSID_len));
+		}
+		WL_SCAN(("### List of channels to scan ###\n"));
+		for (i = 0; i < nchan; i++)
+		{
+			WL_SCAN(("%d ", iscan->iscan_ex_params_p->params.channel_list[i]));
+		}
+		WL_SCAN(("\nnprobes=%d\n", iscan->iscan_ex_params_p->params.nprobes));
+		WL_SCAN(("active_time=%d\n", iscan->iscan_ex_params_p->params.active_time));
+		WL_SCAN(("passive_time=%d\n", iscan->iscan_ex_params_p->params.passive_time));
+		WL_SCAN(("home_time=%d\n", iscan->iscan_ex_params_p->params.home_time));
+		WL_SCAN(("scan_type=%d\n", iscan->iscan_ex_params_p->params.scan_type));
+		WL_SCAN(("\n###################\n"));
+	}
+#endif 
+
+	if (params_size > WLC_IOCTL_MEDLEN) {
+			WL_ERROR(("Set ISCAN for %s due to params_size=%d  \n", \
+				__FUNCTION__, params_size));
+			err = -1;
+	}
+
+	if ((err = dev_iw_iovar_setbuf(dev, "iscan", iscan->iscan_ex_params_p, \
+			iscan->iscan_ex_param_size, \
+			iscan->ioctlbuf, sizeof(iscan->ioctlbuf)))) {
+			WL_ERROR(("Set ISCAN for %s failed with %d\n", __FUNCTION__, err));
+			err = -1;
+	}
+
+exit:
+
+	return err;
+}
+
+
+static int iwpriv_set_cscan(struct net_device *dev, struct iw_request_info *info, \
+				union iwreq_data *wrqu, char *ext)
+{
+	int res = 0;
+	char  *extra = NULL;
+	iscan_info_t *iscan = g_iscan;
+	wlc_ssid_t ssids_local[WL_SCAN_PARAMS_SSID_MAX];
+	int nssid = 0;
+	int nchan = 0;
+
+	WL_TRACE(("\%s: info->cmd:%x, info->flags:%x, u.data=0x%p, u.len=%d\n",
+		__FUNCTION__, info->cmd, info->flags,
+		wrqu->data.pointer, wrqu->data.length));
+
+	if (g_onoff == G_WLAN_SET_OFF) {
+		WL_TRACE(("%s: driver is not up yet after START\n", __FUNCTION__));
+		return -1;
+	}
+
+	if (wrqu->data.length != 0) {
+
+		char *str_ptr;
+
+		if (!iscan->iscan_ex_params_p) {
+			return -EFAULT;
+		}
+
+		if (!(extra = kmalloc(wrqu->data.length+1, GFP_KERNEL)))
+			return -ENOMEM;
+
+		if (copy_from_user(extra, wrqu->data.pointer, wrqu->data.length)) {
+			kfree(extra);
+			return -EFAULT;
+		}
+
+		extra[wrqu->data.length] = 0;
+		WL_ERROR(("Got str param in iw_point:\n %s\n", extra));
+
+		str_ptr = extra;
+
+		
+		if (strncmp(str_ptr, GET_SSID, strlen(GET_SSID))) {
+			WL_ERROR(("%s Error: extracting SSID='' string\n", __FUNCTION__));
+			goto exit_proc;
+		}
+		str_ptr += strlen(GET_SSID);
+		nssid = wl_iw_parse_ssid_list(&str_ptr, ssids_local, nssid, \
+						WL_SCAN_PARAMS_SSID_MAX);
+		if (nssid == -1) {
+			WL_ERROR(("%s wrong ssid list", __FUNCTION__));
+			return -1;
+		}
+
+		if (iscan->iscan_ex_param_size > WLC_IOCTL_MAXLEN) {
+			WL_ERROR(("%s wrong ex_param_size %d", \
+				__FUNCTION__, iscan->iscan_ex_param_size));
+			return -1;
+		}
+		memset(iscan->iscan_ex_params_p, 0, iscan->iscan_ex_param_size);
+
+		
+		wl_iw_iscan_prep(&iscan->iscan_ex_params_p->params, NULL);
+		iscan->iscan_ex_params_p->version = htod32(ISCAN_REQ_VERSION);
+		iscan->iscan_ex_params_p->action = htod16(WL_SCAN_ACTION_START);
+		iscan->iscan_ex_params_p->scan_duration = htod16(0);
+
+		
+		if ((nchan = wl_iw_parse_channel_list(&str_ptr, \
+					&iscan->iscan_ex_params_p->params.channel_list[0], \
+					WL_NUMCHANNELS)) == -1) {
+			WL_ERROR(("%s missing channel list\n", __FUNCTION__));
+			return -1;
+		}
+
+		
+		get_parmeter_from_string(&str_ptr, \
+				GET_NPROBE, PTYPE_INTDEC, \
+				&iscan->iscan_ex_params_p->params.nprobes, 2);
+
+		get_parmeter_from_string(&str_ptr, GET_ACTIVE_ASSOC_DWELL, PTYPE_INTDEC, \
+						&iscan->iscan_ex_params_p->params.active_time, 4);
+
+		get_parmeter_from_string(&str_ptr, GET_PASSIVE_ASSOC_DWELL, PTYPE_INTDEC, \
+						&iscan->iscan_ex_params_p->params.passive_time, 4);
+
+		get_parmeter_from_string(&str_ptr, GET_HOME_DWELL, PTYPE_INTDEC, \
+					&iscan->iscan_ex_params_p->params.home_time, 4);
+
+		get_parmeter_from_string(&str_ptr, GET_SCAN_TYPE, PTYPE_INTDEC, \
+					&iscan->iscan_ex_params_p->params.scan_type, 1);
+
+		
+		res = wl_iw_combined_scan_set(dev, ssids_local, nssid, nchan);
+
+	} else {
+		 
+		  WL_ERROR(("IWPRIV argument len = 0 \n"));
+		  return -1;
+	}
+
+exit_proc:
+
+	kfree(extra);
+
+	return res;
+}
+
+
+static int
+wl_iw_set_cscan(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+)
+{
+	int res = -1;
+	iscan_info_t *iscan = g_iscan;
+	wlc_ssid_t ssids_local[WL_SCAN_PARAMS_SSID_MAX];
+	int nssid = 0;
+	int nchan = 0;
+	cscan_tlv_t *cscan_tlv_temp;
+	char type;
+	char *str_ptr;
+	int tlv_size_left;
+#ifdef TLV_DEBUG
+	int i;
+	char tlv_in_example[] = {			'C', 'S', 'C', 'A', 'N', ' ', \
+							0x53, 0x01, 0x00, 0x00,
+							'S',	  
+							0x00, 
+							'S',    
+							0x04, 
+							'B', 'R', 'C', 'M',
+							'C',
+							0x06, 
+							'P', 
+							0x94,
+							0x11,
+							'T',     
+							0x01  
+							};
+#endif 
+
+	WL_TRACE(("\n### %s: info->cmd:%x, info->flags:%x, u.data=0x%p, u.len=%d\n",
+		__FUNCTION__, info->cmd, info->flags,
+		wrqu->data.pointer, wrqu->data.length));
+
+	if (g_onoff == G_WLAN_SET_OFF) {
+		WL_TRACE(("%s: driver is not up yet after START\n", __FUNCTION__));
+		return -1;
+	}
+
+	if (wrqu->data.length < (strlen(CSCAN_COMMAND) + sizeof(cscan_tlv_t))) {
+		WL_ERROR(("%s aggument=%d  less %d\n", __FUNCTION__, \
+			wrqu->data.length, strlen(CSCAN_COMMAND) + sizeof(cscan_tlv_t)));
+		return -1;
+	}
+
+#ifdef TLV_DEBUG
+	memcpy(extra, tlv_in_example, sizeof(tlv_in_example));
+	wrqu->data.length = sizeof(tlv_in_example);
+	for (i = 0; i < wrqu->data.length; i++)
+		printf("%02X ", extra[i]);
+	printf("\n");
+#endif 
+
+	str_ptr = extra;
+	str_ptr +=  strlen(CSCAN_COMMAND);
+	tlv_size_left = wrqu->data.length - strlen(CSCAN_COMMAND);
+
+	cscan_tlv_temp = (cscan_tlv_t *)str_ptr;
+	memset(ssids_local, 0, sizeof(ssids_local));
+	
+	if ((cscan_tlv_temp->prefix == CSCAN_TLV_PREFIX) && \
+		(cscan_tlv_temp->version == CSCAN_TLV_VERSION) && \
+		(cscan_tlv_temp->subver == CSCAN_TLV_SUBVERSION))
+	{
+		str_ptr += sizeof(cscan_tlv_t);
+		tlv_size_left  -= sizeof(cscan_tlv_t);
+
+		
+		if ((nssid = wl_iw_parse_ssid_list_tlv(&str_ptr, ssids_local, \
+				WL_SCAN_PARAMS_SSID_MAX, &tlv_size_left)) <= 0) {
+			WL_ERROR(("SSID is not presented or corrupted ret=%d\n", nssid));
+			goto exit_proc;
+		}
+		else {
+			
+			memset(iscan->iscan_ex_params_p, 0, iscan->iscan_ex_param_size);
+
+			
+			wl_iw_iscan_prep(&iscan->iscan_ex_params_p->params, NULL);
+			iscan->iscan_ex_params_p->version = htod32(ISCAN_REQ_VERSION);
+			iscan->iscan_ex_params_p->action = htod16(WL_SCAN_ACTION_START);
+			iscan->iscan_ex_params_p->scan_duration = htod16(0);
+
+			
+			while (tlv_size_left > 0)
+			{
+			type = str_ptr[0];
+			switch (type) {
+				case CSCAN_TLV_TYPE_CHANNEL_IE:
+					
+					if ((nchan = wl_iw_parse_channel_list_tlv(&str_ptr, \
+					&iscan->iscan_ex_params_p->params.channel_list[0], \
+					WL_NUMCHANNELS, &tlv_size_left)) == -1) {
+					WL_ERROR(("%s missing channel list\n", \
+						 __FUNCTION__));
+						goto exit_proc;
+					}
+				break;
+				case CSCAN_TLV_TYPE_NPROBE_IE:
+					if ((res = wl_iw_parse_data_tlv(&str_ptr, \
+						&iscan->iscan_ex_params_p->params.nprobes, \
+						sizeof(iscan->iscan_ex_params_p->params.nprobes), \
+						type, sizeof(char), &tlv_size_left)) == -1) {
+						WL_ERROR(("%s return %d\n", \
+							__FUNCTION__, res));
+							goto exit_proc;
+					}
+				break;
+				case CSCAN_TLV_TYPE_ACTIVE_IE:
+					if ((res = wl_iw_parse_data_tlv(&str_ptr, \
+					&iscan->iscan_ex_params_p->params.active_time, \
+					sizeof(iscan->iscan_ex_params_p->params.active_time), \
+					type, sizeof(short), &tlv_size_left)) == -1) {
+						WL_ERROR(("%s return %d\n", \
+						__FUNCTION__, res));
+						goto exit_proc;
+					}
+				break;
+				case CSCAN_TLV_TYPE_PASSIVE_IE:
+					if ((res = wl_iw_parse_data_tlv(&str_ptr, \
+					&iscan->iscan_ex_params_p->params.passive_time, \
+					sizeof(iscan->iscan_ex_params_p->params.passive_time), \
+					type, sizeof(short), &tlv_size_left)) == -1) {
+						WL_ERROR(("%s return %d\n", \
+						__FUNCTION__, res));
+						goto exit_proc;
+					}
+				break;
+				case CSCAN_TLV_TYPE_HOME_IE:
+					if ((res = wl_iw_parse_data_tlv(&str_ptr, \
+					&iscan->iscan_ex_params_p->params.home_time, \
+					sizeof(iscan->iscan_ex_params_p->params.home_time), \
+					type, sizeof(short), &tlv_size_left)) == -1) {
+						WL_ERROR(("%s return %d\n", \
+						__FUNCTION__, res));
+						goto exit_proc;
+					}
+				break;
+				case CSCAN_TLV_TYPE_STYPE_IE:
+					if ((res = wl_iw_parse_data_tlv(&str_ptr, \
+					&iscan->iscan_ex_params_p->params.scan_type, \
+					sizeof(iscan->iscan_ex_params_p->params.scan_type), \
+					type, sizeof(char), &tlv_size_left)) == -1) {
+					WL_ERROR(("%s return %d\n", \
+						__FUNCTION__, res));
+						goto exit_proc;
+					}
+				break;
+
+				default :
+					WL_ERROR(("%s get unkwown type %X\n", \
+						__FUNCTION__, type));
+					goto exit_proc;
+				break;
+				}
+			} 
+			}
+		}
+		else {
+			WL_ERROR(("%s get wrong TLV command\n", __FUNCTION__));
+			goto exit_proc;
+		}
+
+#if defined(CONFIG_FIRST_SCAN)
+		if (g_first_broadcast_scan < BROADCAST_SCAN_FIRST_RESULT_CONSUMED) {
+			if (++g_first_counter_scans == MAX_ALLOWED_BLOCK_SCAN_FROM_FIRST_SCAN) {
+				
+				WL_ERROR(("%s Clean up First scan flag which is %d\n", \
+						 __FUNCTION__, g_first_broadcast_scan));
+				g_first_broadcast_scan = BROADCAST_SCAN_FIRST_RESULT_CONSUMED;
+			}
+			else {
+				WL_ERROR(("%s Ignoring CSCAN : First Scan is not done yet %d\n", \
+						__FUNCTION__, g_first_counter_scans));
+				return -EBUSY;
+			}
+		}
+#endif 
+
+		
+		res = wl_iw_combined_scan_set(dev, ssids_local, nssid, nchan);
+
+exit_proc:
+	return res;
+}
+
+#endif 
+
+
+
+#ifdef SOFTAP
 #ifndef AP_ONLY
+
+
 static int thr_wait_for_2nd_eth_dev(void *data)
 {
+//	struct net_device *dev = (struct net_device *)data;
+	wl_iw_t *iw;
 	int ret = 0;
+	unsigned long flags;
+
+	tsk_ctl_t *tsk_ctl = (tsk_ctl_t *)data;
+	struct net_device *dev = (struct net_device *)tsk_ctl->parent;
+	iw = *(wl_iw_t **)netdev_priv(dev);
 
 	DAEMONIZE("wl0_eth_wthread");
 
-	WL_TRACE(("\n>%s threda started:, PID:%x\n", __FUNCTION__, current->pid));
+	WL_SOFTAP(("\n>%s threda started:, PID:%x\n", __FUNCTION__, current->pid));
+
+//	iw = *(wl_iw_t **)netdev_priv(dev);
+	if (!iw) {
+		WL_ERROR(("%s: dev is null\n", __FUNCTION__));
+		tsk_ctl->thr_pid = -1;
+		complete(&tsk_ctl->completed);
+		return -1;
+	}
+
+	WAKE_LOCK_INIT(iw->pub, WAKE_LOCK_SOFTAP_THREAD, "SoftAP_WT_THREAD");
+	WAKE_LOCK(iw->pub, WAKE_LOCK_SOFTAP_THREAD);
 
-	if (down_timeout(&ap_eth_sema,  msecs_to_jiffies(5000)) != 0) {
+	complete(&tsk_ctl->completed);
+
+#ifndef BCMSDIOH_STD
+//	if (down_timeout(&ap_eth_sema,  msecs_to_jiffies(5000)) != 0) {
+	if (down_timeout(&tsk_ctl->sema,  msecs_to_jiffies(5000)) != 0) {
 		WL_ERROR(("\n%s: sap_eth_sema timeout \n", __FUNCTION__));
 		ret = -1;
 		goto fail;
 	}
+#endif 
 
+	flags = dhd_os_spin_lock(iw->pub);
 	if (!ap_net_dev) {
 		WL_ERROR((" ap_net_dev is null !!!"));
 		ret = -1;
+		dhd_os_spin_unlock(iw->pub, flags);
 		goto fail;
 	}
 
-	WL_TRACE(("\n>%s: Thread:'softap ethdev IF:%s is detected !!!'\n\n",
+	WL_SOFTAP(("\n>%s: Thread:'softap ethdev IF:%s is detected !!!'\n\n",
 		__FUNCTION__, ap_net_dev->name));
 
 	ap_cfg_running = TRUE;
 
+	dhd_os_spin_unlock(iw->pub, flags);
 	bcm_mdelay(500); 
 
+	
 	wl_iw_send_priv_event(priv_dev, "AP_SET_CFG_OK");
 
 fail:
+	WAKE_UNLOCK(iw->pub, WAKE_LOCK_SOFTAP_THREAD);
+	WAKE_LOCK_DESTROY(iw->pub, WAKE_LOCK_SOFTAP_THREAD);
+	WL_SOFTAP(("\n>%s, thread completed\n", __FUNCTION__));
 
-	WL_TRACE(("\n>%s, thread completed\n", __FUNCTION__));
-
+//	complete_and_exit(&ap_cfg_exited, 0);
+	complete_and_exit(&tsk_ctl->completed, 0);
 	return ret;
 }
-#endif /* AP_ONLY */
-
-#if 1
+#endif 
 #ifndef AP_ONLY
 static int last_auto_channel = 6;
-#endif /* AP_ONLY */
+#endif
 static int get_softap_auto_channel(struct net_device *dev, struct ap_profile *ap)
 {
 	int chosen = 0;
@@ -5446,7 +6821,9 @@ static int get_softap_auto_channel(struct net_device *dev, struct ap_profile *ap
 			ret = dev_wlc_ioctl(dev, WLC_START_CHANNEL_SEL, &request, sizeof(request));
 			if (ret < 0) {
 				WL_ERROR(("can't start auto channel scan\n"));
+#if defined(CONFIG_LGE_BCM432X_PATCH)
 				res = -1;
+#endif
 				goto fail;
 			}
 
@@ -5455,12 +6832,14 @@ static int get_softap_auto_channel(struct net_device *dev, struct ap_profile *ap
 
 			ret = dev_wlc_ioctl(dev, WLC_GET_CHANNEL_SEL, &chosen, sizeof(chosen));
 			if (ret < 0 || dtoh32(chosen) == 0) {
-				if (retry++ < 5)
+				if (retry++ < 3)
 					goto get_channel_retry;
 				else {
 					WL_ERROR(("can't get auto channel sel, err = %d, \
 						chosen = %d\n", ret, chosen));
+#if defined(CONFIG_LGE_BCM432X_PATCH)
 					res = -1;
+#endif
 					goto fail;
 				}
 			}
@@ -5480,7 +6859,7 @@ static int get_softap_auto_channel(struct net_device *dev, struct ap_profile *ap
 fail :
 	return res;
 } 
-#endif
+
 
 static int set_ap_cfg(struct net_device *dev, struct ap_profile *ap)
 {
@@ -5516,20 +6895,29 @@ static int set_ap_cfg(struct net_device *dev, struct ap_profile *ap)
 
 	iw = *(wl_iw_t **)netdev_priv(dev);
 	MUTEX_LOCK_SOFTAP_SET(iw->pub);
-	//WAKE_LOCK_INIT(iw->pub, WAKE_LOCK_SOFTAP_SET, "SoftAP_SET"); // louislee
-	//WAKE_LOCK(iw->pub, WAKE_LOCK_SOFTAP_SET); // louislee
-	DHD_OS_WAKE_LOCK(iw->pub); // louislee
+	WAKE_LOCK_INIT(iw->pub, WAKE_LOCK_SOFTAP_SET, "SoftAP_SET");
+	WAKE_LOCK(iw->pub, WAKE_LOCK_SOFTAP_SET);
 
 #ifdef AP_ONLY
 	if (ap_cfg_running) {
-		wl_iw_softap_deassoc_stations(dev);
+		wl_iw_softap_deassoc_stations(dev, NULL); 
 		ap_cfg_running = FALSE;
 	}
 #endif	
 
+	
 	if (ap_cfg_running == FALSE) {
+
 #ifndef AP_ONLY
-		sema_init(&ap_eth_sema, 0);
+
+		
+	//	sema_init(&ap_eth_sema, 0);
+                sema_init(&ap_eth_ctl.sema, 0);
+
+#if defined(CONFIG_LGE_BCM432X_PATCH)	//20110121
+                ap_priv_running = TRUE;
+#endif
+
 		mpc = 0;
 		if ((res = dev_wlc_intvar_set(dev, "mpc", mpc))) {
 			WL_ERROR(("%s fail to set mpc\n", __FUNCTION__));
@@ -5560,7 +6948,10 @@ static int set_ap_cfg(struct net_device *dev, struct ap_profile *ap)
 		iolen = wl_bssiovar_mkbuf("apsta",
 			bsscfg_index,  &apsta_var, sizeof(apsta_var)+4,
 			buf, sizeof(buf), &mkvar_err);
-		ASSERT(iolen);
+
+		if (iolen <= 0) 
+			goto fail;
+
 		if ((res = dev_wlc_ioctl(dev, WLC_SET_VAR, buf, iolen)) < 0) {
 			WL_ERROR(("%s fail to set apsta \n", __FUNCTION__));
 			goto fail;
@@ -5579,7 +6970,8 @@ static int set_ap_cfg(struct net_device *dev, struct ap_profile *ap)
 			goto fail;
 		}
 
-		res = wl_iw_softap_deassoc_stations(ap_net_dev);
+		res = wl_iw_softap_deassoc_stations(ap_net_dev, NULL);
+
 
 		if ((res = dev_iw_write_cfg1_bss_var(dev, 0)) < 0) {
 			WL_ERROR(("%s fail to set bss down\n", __FUNCTION__));
@@ -5587,6 +6979,26 @@ static int set_ap_cfg(struct net_device *dev, struct ap_profile *ap)
 		}
 	}
 
+
+	if (strlen(ap->country_code)) {
+		WL_ERROR(("%s: Igonored: Country MUST be specified \
+				  COUNTRY command with \n",	__FUNCTION__));
+	} else {
+		WL_SOFTAP(("%s: Country code is not specified,"
+			" will use Radio's default\n",
+			__FUNCTION__));
+
+	}
+	iolen = wl_bssiovar_mkbuf("closednet",
+		bsscfg_index,  &ap->closednet, sizeof(ap->closednet)+4,
+		buf, sizeof(buf), &mkvar_err);
+	ASSERT(iolen);
+	if ((res = dev_wlc_ioctl(dev, WLC_SET_VAR, buf, iolen)) < 0) {
+		WL_ERROR(("%s failed to set 'closednet'for apsta \n", __FUNCTION__));
+		goto fail;
+	}
+
+	
 	if ((ap->channel == 0) && (get_softap_auto_channel(dev, ap) < 0)) {
 		ap->channel = 1;
 		WL_ERROR(("%s auto channel failed, pick up channel=%d\n", \
@@ -5632,9 +7044,22 @@ static int set_ap_cfg(struct net_device *dev, struct ap_profile *ap)
 		res, __FUNCTION__));
 		goto fail;
 	}
+#if 0
+	if (ap_cfg_running == FALSE) {
+		 init_completion(&ap_cfg_exited);
+		 
+		ap_cfg_pid = kernel_thread(thr_wait_for_2nd_eth_dev, dev, 0);
+	} else {
+		ap_cfg_pid = -1;
+#else
+
 	if (ap_cfg_running == FALSE) {
-		kernel_thread(thr_wait_for_2nd_eth_dev, 0, 0);
+
+		PROC_START(thr_wait_for_2nd_eth_dev, dev, &ap_eth_ctl, 0);
 	} else {
+		ap_eth_ctl.thr_pid = -1;
+
+#endif	
 		if (ap_net_dev == NULL) {
 			WL_ERROR(("%s ERROR: ap_net_dev is NULL !!!\n", __FUNCTION__));
 			goto fail;
@@ -5655,8 +7080,10 @@ static int set_ap_cfg(struct net_device *dev, struct ap_profile *ap)
 	}
 #endif 
 fail:
-	DHD_OS_WAKE_UNLOCK(iw->pub);
+	WAKE_UNLOCK(iw->pub, WAKE_LOCK_SOFTAP_SET);
+	WAKE_LOCK_DESTROY(iw->pub, WAKE_LOCK_SOFTAP_SET);
 	MUTEX_UNLOCK_SOFTAP_SET(iw->pub);
+
 	WL_SOFTAP(("%s exit with %d\n", __FUNCTION__, res));
 	return res;
 }
@@ -5679,8 +7106,9 @@ static int wl_iw_set_ap_security(struct net_device *dev, struct ap_profile *ap)
 	WL_SOFTAP(("wl_iw: set ap profile:\n"));
 	WL_SOFTAP(("	ssid = '%s'\n", ap->ssid));
 	WL_SOFTAP(("	security = '%s'\n", ap->sec));
-	if (ap->key[0] != '\0')
+	if (ap->key[0] != '\0') {
 		WL_SOFTAP(("	key = '%s'\n", ap->key));
+	}
 	WL_SOFTAP(("	channel = %d\n", ap->channel));
 	WL_SOFTAP(("	max scb = %d\n", ap->max_scb));
 
@@ -5779,6 +7207,7 @@ static int wl_iw_set_ap_security(struct net_device *dev, struct ap_profile *ap)
 		if (key_len < WSEC_MAX_PSK_LEN) {
 			unsigned char output[2*SHA1HashSize];
 			char key_str_buf[WSEC_MAX_PSK_LEN+1];
+			bzero(output, 2*SHA1HashSize);
 
 			WL_SOFTAP(("%s: do passhash...\n", __FUNCTION__));
 			
@@ -5793,7 +7222,7 @@ static int wl_iw_set_ap_security(struct net_device *dev, struct ap_profile *ap)
 					 (uint)output[i*4+3]);
 				ptr += 8;
 			}
-			printk("%s: passphase = %s\n", __FUNCTION__, key_str_buf);
+			WL_SOFTAP(("%s: passphase = %s\n", __FUNCTION__, key_str_buf));
 
 			psk.key_len = htod16((ushort)WSEC_MAX_PSK_LEN);
 			memcpy(psk.key, key_str_buf, psk.key_len);
@@ -5832,7 +7261,6 @@ int get_parmeter_from_string(
 	int parm_str_len;
 	char  *param_str_begin;
 	char  *param_str_end;
-	char  *orig_str = *str_ptr;
 
 	if ((*str_ptr) && !strncmp(*str_ptr, token, strlen(token))) {
 
@@ -5892,69 +7320,37 @@ int get_parmeter_from_string(
 
 		return 0;
 	} else {
-		WL_ERROR(("\n %s: ERROR: can't find token:%s in str:%s \n",
-			__FUNCTION__, token, orig_str));
-
-	 return -1;
-	}
-}
-
-#if CONFIG_LGE_BCM432X_PATCH
-static int
-get_SSID_from_string(
-			char **str_ptr, const char *token,
-			int param_type, void  *dst, int ssid_len)
-{
-	int parm_str_len= 0;
-	char  *param_str_begin;
-	char  *orig_str = *str_ptr;
-
-	if ((*str_ptr) && !strncmp(*str_ptr, token, strlen(token))) {
-
-		strsep(str_ptr, "="); /* find the 1st delimiter */
-		param_str_begin = *str_ptr;
-		//strsep(str_ptr, "=,"); /* find the 2nd delimiter */
-
-		if(ssid_len > SSID_LEN)
-			ssid_len = SSID_LEN;
-		
-		parm_str_len = ssid_len;
-
-		WL_TRACE((" 'token:%s', len:%d, ", token, parm_str_len));
-
-		/* param is array of ASCII chars, no convertion needed */
-		memcpy(dst, param_str_begin, parm_str_len);
-		*((char *)dst + parm_str_len) = 0; /* Z term */
-		WL_ERROR((" written as a string:%s\n", (char *)dst));
-
-		parm_str_len++;
-		*str_ptr += parm_str_len;
-		
-		return 0;
-	} else {
-		WL_ERROR(("\n %s: ERROR: can't find token:%s in str:%s \n",
-			__FUNCTION__, token, orig_str));
+		WL_ERROR(("\n %s: No token:%s in str:%s\n",
+			__FUNCTION__, token, *str_ptr));
 
 	 return -1;
 	}
 }
-#endif /*CONFIG_LGE_BCM432X_PATCH*/
 
-static int wl_iw_softap_deassoc_stations(struct net_device *dev)
+static int wl_iw_softap_deassoc_stations(struct net_device *dev, u8 *mac)
 {
 	int i;
 	int res = 0;
-
 	char mac_buf[128] = {0};
+	char z_mac[6] = {0, 0, 0, 0, 0, 0};
+	char *sta_mac;
 	struct maclist *assoc_maclist = (struct maclist *) mac_buf;
+	bool deauth_all = false;
+
+	
+	if (mac == NULL) {
+		deauth_all = true;
+		sta_mac = z_mac;  
+	} else {
+		sta_mac = mac;  
+	}
 
 	memset(assoc_maclist, 0, sizeof(mac_buf));
 	assoc_maclist->count = 8; 
 
 	res = dev_wlc_ioctl(dev, WLC_GET_ASSOCLIST, assoc_maclist, 128);
 	if (res != 0) {
-
-		WL_SOFTAP((" Error:%d in :%s, Couldn't get ASSOC List\n", res, __FUNCTION__));
+		WL_SOFTAP(("%s: Error:%d Couldn't get ASSOC List\n", __FUNCTION__, res));
 		return res;
 	}
 
@@ -5965,21 +7361,25 @@ static int wl_iw_softap_deassoc_stations(struct net_device *dev)
 			
 			bcopy(&assoc_maclist->ea[i], &scbval.ea, ETHER_ADDR_LEN);
 
-			WL_SOFTAP(("deauth STA:%d \n", i));
+		if (deauth_all || (memcmp(&scbval.ea, sta_mac, ETHER_ADDR_LEN) == 0))  {
+			
+			WL_SOFTAP(("%s, deauth STA:%d \n", __FUNCTION__, i));
 			res |= dev_wlc_ioctl(dev, WLC_SCB_DEAUTHENTICATE_FOR_REASON,
 				&scbval, sizeof(scb_val_t));
+		}
+	} else WL_SOFTAP(("%s: No Stations \n", __FUNCTION__));
 
-		} else WL_SOFTAP((" STA ASSOC list is empty\n"));
-
-	if (res != 0)
-		WL_SOFTAP((" Error:%d in :%s\n", res, __FUNCTION__));
-	else if (assoc_maclist->count) {
+	if (res != 0) {
+		WL_ERROR(("%s: Error:%d\n", __FUNCTION__, res));
+	} else if (assoc_maclist->count) {
 		
 		bcm_mdelay(200);
 	}
 	return res;
 }
-
+#if 1	//reset work around 11-01-26
+extern void dhd_del_softap_if(struct net_device *dev);		//reset work around 11-01-26
+#endif
 static int iwpriv_softap_stop(struct net_device *dev,
 	struct iw_request_info *info,
 	union iwreq_data *wrqu,
@@ -5988,7 +7388,7 @@ static int iwpriv_softap_stop(struct net_device *dev,
 	int res = 0;
 	wl_iw_t *iw;
 
-	WL_SOFTAP(("got iwpriv AP_BSS_STOP \n"));
+	WL_SOFTAP(("%s got iwpriv AP_BSS_STOP \n", __FUNCTION__));
 
 	if ((!dev) && (!ap_net_dev)) {
 		WL_ERROR(("%s: dev is null\n", __FUNCTION__));
@@ -5997,19 +7397,22 @@ static int iwpriv_softap_stop(struct net_device *dev,
 
 	iw = *(wl_iw_t **)netdev_priv(dev);
 	MUTEX_LOCK_SOFTAP_SET(iw->pub);
-	//WAKE_LOCK_INIT(iw->pub, WAKE_LOCK_SOFTAP_STOP, "SoftAP_STOP");
-	DHD_OS_WAKE_LOCK(iw->pub);
+	WAKE_LOCK_INIT(iw->pub, WAKE_LOCK_SOFTAP_STOP, "SoftAP_STOP");
+	WAKE_LOCK(iw->pub, WAKE_LOCK_SOFTAP_STOP);
 
 	if  ((ap_cfg_running == TRUE)) {
 #ifdef AP_ONLY
-		 wl_iw_softap_deassoc_stations(dev);
+		 wl_iw_softap_deassoc_stations(dev, NULL);
 #else
-		 wl_iw_softap_deassoc_stations(ap_net_dev);
-
+		 wl_iw_softap_deassoc_stations(ap_net_dev, NULL);
 		if ((res = dev_iw_write_cfg1_bss_var(dev, 2)) < 0)
+		{
 			WL_ERROR(("%s failed to del BSS err = %d", __FUNCTION__, res));
+			dhd_del_softap_if(dev);		//reset work around 11-01-26
+		}
 #endif
 
+		
 		bcm_mdelay(100);
 
 		wrqu->data.length = 0;
@@ -6018,7 +7421,8 @@ static int iwpriv_softap_stop(struct net_device *dev,
 	else
 		WL_ERROR(("%s: was called when SoftAP is OFF : move on\n", __FUNCTION__));
 
-	DHD_OS_WAKE_UNLOCK(iw->pub);
+	WAKE_UNLOCK(iw->pub, WAKE_LOCK_SOFTAP_STOP);
+	WAKE_LOCK_DESTROY(iw->pub, WAKE_LOCK_SOFTAP_STOP);
 	MUTEX_UNLOCK_SOFTAP_SET(iw->pub);
 
 	WL_SOFTAP(("%s Done with %d\n", __FUNCTION__, res));
@@ -6030,14 +7434,13 @@ static int iwpriv_fw_reload(struct net_device *dev,
 	union iwreq_data *wrqu,
 	char *ext)
 {
-#if 1
+
 	int ret = -1;
 	char extra[256];
-#endif
 	char *fwstr = fw_path ; 
 
 	WL_SOFTAP(("current firmware_path[]=%s\n", fwstr));
-#if 1
+
 	WL_TRACE((">Got FW_RELOAD cmd:"
 				"info->cmd:%x, info->flags:%x, u.data:%p, u.len:%d, \
 				fw_path:%p, len:%d \n",
@@ -6070,20 +7473,24 @@ static int iwpriv_fw_reload(struct net_device *dev,
 		}
 
 		WL_SOFTAP(("SET firmware_path[]=%s , str_p:%p\n", fwstr, fwstr));
+
+		if (ap_fw_loaded) {
+			dhd_dev_reset(dev, 1);
+
+			bcm_mdelay(200);
+
+
+			dhd_dev_reset(dev, 0);
+		}
+
 		ret = 0;
 	} else {
 		WL_ERROR(("Error: ivalid param len:%d\n", wrqu->data.length));
 	}
+
 exit_proc:
 	return ret;
-
-#else
-	/* We used apsta firmware. */
-	ap_fw_loaded = TRUE;
-	return 0;
-#endif
 }
-
 #ifdef SOFTAP
 
 static int iwpriv_wpasupp_loop_tst(struct net_device *dev,
@@ -6138,14 +7545,25 @@ static int
 		return -1;
 	}
 
-	WL_TRACE(("%s: rcvd IWPRIV IOCTL:  for dev:%s\n", __FUNCTION__, dev->name));
+	WL_SOFTAP(("%s: rcvd IWPRIV IOCTL:  for dev:%s\n", __FUNCTION__, dev->name));
 
 	iw = *(wl_iw_t **)netdev_priv(dev);
 	MUTEX_LOCK_SOFTAP_SET(iw->pub);
-	//WAKE_LOCK_INIT(iw->pub, WAKE_LOCK_SOFTAP_START, "SoftAP_START");
-	DHD_OS_WAKE_LOCK(iw->pub);
+	WAKE_LOCK_INIT(iw->pub, WAKE_LOCK_SOFTAP_START, "SoftAP_START");
+	WAKE_LOCK(iw->pub, WAKE_LOCK_SOFTAP_START);
+
 
 #ifndef AP_ONLY
+#if 0
+	if (ap_cfg_pid >= 0) {
+		wait_for_completion(&ap_cfg_exited);
+		ap_cfg_pid = -1;
+	}
+#else
+	if (ap_eth_ctl.thr_pid >= 0) {
+		wait_for_completion(&ap_eth_ctl.completed);
+	}
+#endif
 	if ((res = wl_iw_set_ap_security(dev, &my_ap)) != 0) {
 		WL_ERROR((" %s ERROR setting SOFTAP security in :%d\n", __FUNCTION__, res));
 	}
@@ -6158,8 +7576,8 @@ static int
 #endif 
 
 	WL_SOFTAP(("%s done with res %d \n", __FUNCTION__, res));
-	DHD_OS_WAKE_UNLOCK(iw->pub);
-	//WAKE_LOCK_DESTROY(iw->pub, WAKE_LOCK_SOFTAP_START);
+	WAKE_UNLOCK(iw->pub, WAKE_LOCK_SOFTAP_START);
+	WAKE_LOCK_DESTROY(iw->pub, WAKE_LOCK_SOFTAP_START);
 	MUTEX_UNLOCK_SOFTAP_SET(iw->pub);
 	return res;
 }
@@ -6167,79 +7585,118 @@ static int
 static int
 get_assoc_sta_list(struct net_device *dev, char *buf, int len)
 {
-	WL_TRACE(("calling dev_wlc_ioctl(dev:%p, cmd:%d, buf:%p, len:%d)\n",
-		dev, WLC_GET_ASSOCLIST, buf, len));
-	dev_wlc_ioctl(dev, WLC_GET_ASSOCLIST, buf, len);
-	return 0;
+	
+	WL_TRACE(("%s: dev_wlc_ioctl(dev:%p, cmd:%d, buf:%p, len:%d)\n",
+		__FUNCTION__, dev, WLC_GET_ASSOCLIST, buf, len));
+
+	return dev_wlc_ioctl(dev, WLC_GET_ASSOCLIST, buf, len);
+
+}
+
+
+void check_error(int res, const char *msg, const char *func, int line)
+{
+	if (res != 0)
+		WL_ERROR(("%s, %d function:%s, line:%d\n", msg, res, func, line));
 }
 
 static int
-set_ap_mac_list(struct net_device *dev, char *buf)
+set_ap_mac_list(struct net_device *dev, void *buf)
 {
 	struct mac_list_set *mac_list_set = (struct mac_list_set *)buf;
-	struct maclist *white_maclist = (struct maclist *)&mac_list_set->white_list;
-	struct maclist *black_maclist = (struct maclist *)&mac_list_set->black_list;
-	int mac_mode = mac_list_set->mode;
+	struct maclist *maclist = (struct maclist *)&mac_list_set->mac_list;
 	int length;
 	int i;
+	int mac_mode = mac_list_set->mode;
+	int ioc_res = 0;
+	ap_macmode = mac_list_set->mode;  
+
 
-	ap_macmode = mac_mode;
-	if (mac_mode == MACLIST_MODE_DISABLED) {
 		bzero(&ap_black_list, sizeof(struct mflist));
-		dev_wlc_ioctl(dev, WLC_SET_MACMODE, &mac_mode, sizeof(mac_mode));
+
+	if (mac_mode == MACLIST_MODE_DISABLED) {
+		
+		ioc_res = dev_wlc_ioctl(dev, WLC_SET_MACMODE, &mac_mode, sizeof(mac_mode));
+		check_error(ioc_res, "ioctl ERROR:", __FUNCTION__, __LINE__);
+		WL_SOFTAP(("%s: MAC filtering disabled\n", __FUNCTION__));
 	} else {
+		
 		scb_val_t scbval;
 		char mac_buf[256] = {0};
 		struct maclist *assoc_maclist = (struct maclist *) mac_buf;
 
-		mac_mode = MACLIST_MODE_ALLOW;
 		
-		dev_wlc_ioctl(dev, WLC_SET_MACMODE, &mac_mode, sizeof(mac_mode));
+		bcopy(maclist, &ap_black_list, sizeof(ap_black_list));
 
-		length = sizeof(white_maclist->count)+white_maclist->count*ETHER_ADDR_LEN;
-		dev_wlc_ioctl(dev, WLC_SET_MACLIST, white_maclist, length);
-		WL_SOFTAP(("White List, length %d:\n", length));
-		for (i = 0; i < white_maclist->count; i++)
-			WL_SOFTAP(("mac %d: %02X:%02X:%02X:%02X:%02X:%02X\n",
-				i, white_maclist->ea[i].octet[0], white_maclist->ea[i].octet[1], \
-				white_maclist->ea[i].octet[2], \
-				white_maclist->ea[i].octet[3], white_maclist->ea[i].octet[4], \
-				white_maclist->ea[i].octet[5]));
 
-		bcopy(black_maclist, &ap_black_list, sizeof(ap_black_list));
+		ioc_res = dev_wlc_ioctl(dev, WLC_SET_MACMODE, &mac_mode, sizeof(mac_mode));
+		check_error(ioc_res, "ioctl ERROR:", __FUNCTION__, __LINE__);
 
-		WL_SOFTAP(("Black List, size %d:\n", sizeof(ap_black_list)));
-		for (i = 0; i < ap_black_list.count; i++)
+		
+		length = sizeof(maclist->count) + maclist->count*ETHER_ADDR_LEN;
+		dev_wlc_ioctl(dev, WLC_SET_MACLIST, maclist, length);
+
+		WL_SOFTAP(("%s: applied MAC List, mode:%d, length %d:\n",
+			__FUNCTION__, mac_mode, length));
+
+		for (i = 0; i < maclist->count; i++)
 			WL_SOFTAP(("mac %d: %02X:%02X:%02X:%02X:%02X:%02X\n",
-				i, ap_black_list.ea[i].octet[0], ap_black_list.ea[i].octet[1], \
-				ap_black_list.ea[i].octet[2], \
-				ap_black_list.ea[i].octet[3], \
-				ap_black_list.ea[i].octet[4], ap_black_list.ea[i].octet[5]));
-
-		dev_wlc_ioctl(dev, WLC_GET_ASSOCLIST, assoc_maclist, 256);
-		if (assoc_maclist->count) {
-			int j;
+				i, maclist->ea[i].octet[0], maclist->ea[i].octet[1], \
+				maclist->ea[i].octet[2], \
+				maclist->ea[i].octet[3], maclist->ea[i].octet[4], \
+				maclist->ea[i].octet[5]));
+
+		
+		assoc_maclist->count = 8;
+		ioc_res = dev_wlc_ioctl(dev, WLC_GET_ASSOCLIST, assoc_maclist, 256);
+		check_error(ioc_res, "ioctl ERROR:", __FUNCTION__, __LINE__);
+		WL_SOFTAP((" Cur assoc clients:%d\n", assoc_maclist->count));
+
+		
+		if (assoc_maclist->count)
 			for (i = 0; i < assoc_maclist->count; i++) {
-				for (j = 0; j < white_maclist->count; j++) {
-					if (!bcmp(&assoc_maclist->ea[i], &white_maclist->ea[j], \
+				int j;
+				bool assoc_mac_matched = false;
+				
+				WL_SOFTAP(("\n Cheking assoc STA: "));
+				print_buf(&assoc_maclist->ea[i], 6, 7);
+				WL_SOFTAP(("with the b/w list:"));
+
+				for (j = 0; j < maclist->count; j++)
+					if (!bcmp(&assoc_maclist->ea[i], &maclist->ea[j],
 						ETHER_ADDR_LEN)) {
-						WL_SOFTAP(("match allow, let it be\n"));
+						
+						assoc_mac_matched = true;
 						break;
 					}
-				}
-				if (j == white_maclist->count) {
-						WL_SOFTAP(("match black, deauth it\n"));
+
+				
+				if (((mac_mode == MACLIST_MODE_ALLOW) && !assoc_mac_matched) ||
+					((mac_mode == MACLIST_MODE_DENY) && assoc_mac_matched)) {
+
+					WL_SOFTAP(("b-match or w-mismatch,"
+								" do deauth/disassoc \n"));
 						scbval.val = htod32(1);
 						bcopy(&assoc_maclist->ea[i], &scbval.ea, \
 						ETHER_ADDR_LEN);
-						dev_wlc_ioctl(dev, \
-							WLC_SCB_DEAUTHENTICATE_FOR_REASON, &scbval,
-							sizeof(scb_val_t));
-				}
+							ioc_res = dev_wlc_ioctl(dev,
+								WLC_SCB_DEAUTHENTICATE_FOR_REASON,
+								&scbval, sizeof(scb_val_t));
+							check_error(ioc_res,
+								"ioctl ERROR:",
+								__FUNCTION__, __LINE__);
+
+				} else {
+					WL_SOFTAP((" no b/w list hits, let it be\n"));
 			}
+		} else {
+			WL_SOFTAP(("No ASSOC CLIENTS\n"));
 		}
+
 	}
-	return 0;
+
+	WL_SOFTAP(("%s iocres:%d\n", __FUNCTION__, ioc_res));
+	return ioc_res;
 }
 #endif 
 
@@ -6283,270 +7740,211 @@ int wl_iw_process_private_ascii_cmd(
 		if (ap_net_dev == NULL) {
 				 printf("\n ERROR: SOFTAP net_dev* is NULL !!!\n");
 		} else {
-			if ((ret = iwpriv_en_ap_bss(ap_net_dev, info, dwrq, cmd_str)) < 0) {
+			  
+			if ((ret = iwpriv_en_ap_bss(ap_net_dev, info, dwrq, cmd_str)) < 0)
 				WL_ERROR(("%s line %d fail to set bss up\n", \
 					__FUNCTION__, __LINE__));
 			}
-		}
 #else
-		if ((ret = iwpriv_en_ap_bss(dev, info, dwrq, cmd_str)) < 0) {
+		if ((ret = iwpriv_en_ap_bss(dev, info, dwrq, cmd_str)) < 0)
 				WL_ERROR(("%s line %d fail to set bss up\n", \
 					__FUNCTION__, __LINE__));
-		}
 #endif
 	} else if (strnicmp(sub_cmd, "ASSOC_LST", strlen("ASSOC_LST")) == 0) {
 
+
+
 	} else if (strnicmp(sub_cmd, "AP_BSS_STOP", strlen("AP_BSS_STOP")) == 0) {
+
 		WL_SOFTAP((" \n temp DOWN SOFTAP\n"));
 #ifndef AP_ONLY
-			if ((ret = dev_iw_write_cfg1_bss_var(dev, 0)) < 0) {
+		if ((ret = dev_iw_write_cfg1_bss_var(dev, 0)) < 0) {
 				WL_ERROR(("%s line %d fail to set bss down\n", \
 					__FUNCTION__, __LINE__));
-			}
-#endif
-	}
-
-	return ret;
-}
-#endif /* SOFTAP */
-/* LGE_UPDATE_S 20110708 BRCM patch */
-#ifdef LGE_ROAM_PARAMETER
-static int
-wl_iw_process_private_roam_cmd(
-			struct net_device *dev,
-			struct iw_request_info *info,
-			union iwreq_data *dwrq,
-			char *extra)
-{
-	int ret = -1;
-    unsigned int value = 0;
-    unsigned int iocmd = 0;
-	char *sub_cmd = extra + strlen("ROAM_CMD=");
-
-	WL_TRACE(("\n%s: ROAM_CMD: offs_0:%s, offset_32:\n'%s'\n",
-		__FUNCTION__, extra, extra + strlen("ROAM_CMD=")));
-
-	if( strnicmp(sub_cmd, "GET_ROAM_TRIGGER", strlen("GET_ROAM_TRIGGER")) == 0 ) 
-        iocmd = WLC_GET_ROAM_TRIGGER;
-    else if( strnicmp(sub_cmd, "SET_ROAM_TRIGGER", strlen("SET_ROAM_TRIGGER")) == 0 )
-        iocmd = WLC_SET_ROAM_TRIGGER;
-    else if( strnicmp(sub_cmd, "GET_ROAM_DELTA", strlen("GET_ROAM_DELTA")) == 0 )
-        iocmd = WLC_GET_ROAM_DELTA;
-    else if( strnicmp(sub_cmd, "SET_ROAM_DELTA", strlen("SET_ROAM_DELTA")) == 0 )
-        iocmd = WLC_SET_ROAM_DELTA;
-    else if( strnicmp(sub_cmd, "GET_ROAM_SCAN_PERIOD", strlen("GET_ROAM_SCAN_PERIOD")) == 0 ) 
-        iocmd = WLC_GET_ROAM_SCAN_PERIOD;
-    else if( strnicmp(sub_cmd, "SET_ROAM_SCAN_PERIOD", strlen("SET_ROAM_SCAN_PERIOD")) == 0 ) 
-        iocmd = WLC_SET_ROAM_SCAN_PERIOD;
-    else
-    {
-        WL_ERROR(("%s: command parsing error %s\n",__FUNCTION__, extra));
-        return ret;
-    }
-
-    if( strnicmp( sub_cmd, "GET", strlen("GET") ) == 0 )
-    {
-        char* p = extra;
-		WL_TRACE(("%s: iocmd = %d\n", __FUNCTION__, iocmd));
-
-        if ((ret = dev_wlc_ioctl(dev, iocmd, &value, sizeof(value) )))
-        {
-            WL_ERROR(("%s: dev_wlc_ioctl returned error %d\n",__FUNCTION__, ret));
-            WL_TRACE(("%d, %d\n", value, dtoh32(value)));
-            return ret;
-        }
-
-		WL_TRACE(("%d\n", dtoh32(value)));
-
-        p += snprintf(p, MAX_WX_STRING, "%d", dtoh32(value) );
-        dwrq->data.length = p - extra + 1;
     }
-    else if( strnicmp( sub_cmd, "SET", strlen("SET") ) == 0 )
-    {
-		WL_TRACE(("%s: %s ", __FUNCTION__, sub_cmd));
-        if( sscanf(sub_cmd, "%*s %d", &value) != 1 ) 
-        {
-            WL_ERROR(("%s: sscanf parsing error %s\n",__FUNCTION__, sub_cmd));
-            return -1;
+#endif
         }
 
-        if ((ret = dev_wlc_ioctl(dev, iocmd, &value, sizeof(value) )))
-        {
-            WL_ERROR(("%s: dev_wlc_ioctl returned error %d, value = %d\n",__FUNCTION__, ret, value ));
             return ret;
-        }
 
-		WL_TRACE(("%d has been set\n", value));
-    }
-
-	return ret;
 }
-#endif //LGE_ROAM_PARAMETER
-/* LGE_UPDATE_E 20110708 BRCM patch */
-
+#endif 
 
-static s32
-wl_iw_vndr_ie(struct net_device *ndev, s32 pktflag,
-            s8 *oui, s32 ie_id, s8 *data, s32 data_len, s32 delete)
+/* LGE_CHANGE_S [yoohoo@lge.com] 2009-05-14, support private command */
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+static int
+wl_iw_set_powermode(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+)
 {
-	s32 err = BCME_OK;
-	s32 buf_len;
-	s32 iecount;
-
-	vndr_ie_setbuf_t *ie_setbuf;
-	char iovbuf[512];
+	int mode = -1;
+	int error;
+	char *p = extra;
 
-	memset(iovbuf, 0, sizeof(iovbuf));
+	if (sscanf(extra, "%*s %d", &mode) != 1)
+		return -EINVAL;
 
-	/* Validate the pktflag parameter */
-	if ((pktflag & ~(VNDR_IE_BEACON_FLAG | VNDR_IE_PRBRSP_FLAG |
-	            VNDR_IE_ASSOCRSP_FLAG | VNDR_IE_AUTHRSP_FLAG |
-	            VNDR_IE_PRBREQ_FLAG | VNDR_IE_ASSOCREQ_FLAG))) {
-		WL_ERROR(("p2pwl_vndr_ie: Invalid packet flag 0x%x\n", pktflag));
-		return -1;
+	switch (mode) {
+	case 0: mode = 2; break; /* Fast PS mode */
+	case 1: mode = 0; break; /* No PS mode */
+	default: return -EINVAL;
 	}
+	error = dev_wlc_ioctl(dev, WLC_SET_PM, &mode, sizeof(mode));
+	p += snprintf(p, MAX_WX_STRING, error < 0 ? "FAIL\n" : "OK\n");
+	wrqu->data.length = p - extra + 1;
+	return error;
+}
 
-	buf_len = sizeof(vndr_ie_setbuf_t) + data_len - 1;
-	ie_setbuf = (vndr_ie_setbuf_t *) kzalloc(buf_len, GFP_KERNEL);
+static int
+wl_iw_set_scan_channels(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+)
+{
+	uint32 chan_buf[WL_NUMCHANNELS + 1];
+	wl_uint32_list_t *list;
+	int nchan;
+	char buf[WLC_CNTRY_BUF_SZ];
+	int error;
+	char *p = extra;
 
-	WL_ERROR((" ie_id : %02x, data length : %d\n", ie_id, data_len));
-	if (!ie_setbuf) {
+	if (sscanf(extra, "%*s %d", &nchan) != 1) {
+		list = (wl_uint32_list_t *)(void *)chan_buf;
+		list->count = htod32(WL_NUMCHANNELS);
+		if ((error = dev_wlc_ioctl(dev, WLC_GET_VALID_CHANNELS,
+				chan_buf, sizeof(chan_buf))) < 0)
+			return error;
+		p += snprintf(p, MAX_WX_STRING,
+				"Scan-Channels = %d", dtoh32(list->count));
+		wrqu->data.length = p - extra + 1;
+		return error;
+	}
 
-		WL_ERROR(("Error allocating buffer for IE\n"));
-		return -ENOMEM;
+	switch (nchan) {
+	case 11: strcpy(buf, "US"); break;
+	case 13: strcpy(buf, "AU"); break;
+	case 14: strcpy(buf, "JP"); break;
+	default: return -EINVAL;
 	}
-	if (delete)
-		strcpy(ie_setbuf->cmd, "del");
-	else
-		strcpy(ie_setbuf->cmd, "add");
-	/* Buffer contains only 1 IE */
-	iecount = htod32(1);
-	memcpy((void *)&ie_setbuf->vndr_ie_buffer.iecount, &iecount, sizeof(int));
-	pktflag = htod32(pktflag);
-	memcpy((void *)&ie_setbuf->vndr_ie_buffer.vndr_ie_list[0].pktflag,
-	    &pktflag, sizeof(uint32));
-	ie_setbuf->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.id = ie_id;
-	ie_setbuf->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.len
-	        = (uchar)(data_len + VNDR_IE_MIN_LEN);
-	memcpy(ie_setbuf->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.oui, oui, 3);
-	memcpy(ie_setbuf->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.data, data, data_len);
-	err = dev_iw_iovar_setbuf(ndev, "vndr_ie", ie_setbuf, buf_len,iovbuf, 512);
-	WL_ERROR(("vndr_ie iovar returns %d\n", err));
-	kfree(ie_setbuf);
-	return err;
+	error = dev_wlc_ioctl(dev, WLC_SET_COUNTRY, buf, sizeof(buf));
+	p += snprintf(p, MAX_WX_STRING, error < 0 ? "FAIL\n" : "OK\n");
+	wrqu->data.length = p - extra + 1;
+	return error;
 }
 
-static bool
-wl_iw_has_ie(u8 *ie, u8 **tlvs, u32 *tlvs_len, const u8 *oui, u32 oui_len, u8 type)
+static int
+wl_iw_set_roam_off(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu,
+	char *extra
+)
 {
-    /* If the contents match the OUI and the type */
-    if (ie[TLV_LEN_OFF] >= oui_len + 1 &&
-            !bcmp(&ie[TLV_BODY_OFF], oui, oui_len) &&
-            type == ie[TLV_BODY_OFF + oui_len]) {
-        return TRUE;
-    }
+	uint roamvar;
+	int error;
+	char *p = extra;
+	char iovbuf[WLC_IOCTL_SMLEN];	/*  Room for "event_msgs" + '\0' + bitvec  */
+	int iolen;
 
-    if (tlvs == NULL)
-        return FALSE;
-    /* point to the next ie */
-    ie += ie[TLV_LEN_OFF] + TLV_HDR_LEN;
-    /* calculate the length of the rest of the buffer */
-    *tlvs_len -= (int)(ie - *tlvs);
-    /* update the pointer to the start of the buffer */
-    *tlvs = ie;
+	if (sscanf(extra, "%*s %d", &roamvar) != 1)
+		return -EINVAL;
 
-    return FALSE;
-}
+	switch (roamvar) {
+		case 0: break; /* roam_off 0 */
+		case 1: break; /* roam_off 1 */
+		default: return -EINVAL;
+    }
 
+	iolen = bcm_mkiovar("roam_off", (char *)&roamvar, 4, iovbuf, sizeof(iovbuf));
+	ASSERT(iolen);	
+	error = dev_wlc_ioctl(dev, WLC_SET_VAR, iovbuf, iolen);
 
-/* Check whether pointed-to IE looks like WPA. */
-#define wl_iw_is_wpa_ie(ie, tlvs, len)  wl_iw_has_ie(ie, tlvs, len, \
-		(const uint8 *)WPS_OUI, WPS_OUI_LEN, WPA_OUI_TYPE)
+	p += snprintf(p, MAX_WX_STRING, error < 0 ? "FAIL\n" : "OK\n");
+	wrqu->data.length = p - extra + 1;
+	return error;
+}
+#if 1   /* Set VOIP */
+//PM=1, wme_apsd=1, wme_qosinfo=0x3, wme_apsd_trigger=1000, wme_auto_trigger=0
+static int wl_iw_voip_start(struct net_device *dev)
+{
+    int error = 0;
+    int val;
 
-/* Check whether pointed-to IE looks like WPS. */
-#define wl_iw_is_wps_ie(ie, tlvs, len)  wl_iw_has_ie(ie, tlvs, len,      \
-		(const uint8 *)WPS_OUI, WPS_OUI_LEN, WPS_OUI_TYPE)
-/* Check whether the given IE looks like WFA P2P IE. */
-#define wl_iw_is_p2p_ie(ie, tlvs, len)  wl_iw_has_ie(ie, tlvs, len, \
-		(const uint8 *)WFA_OUI, WFA_OUI_LEN, WFA_OUI_TYPE_P2P)
-/* Check whether the given IE looks like WFA WFDisplay IE. */
-#define WFA_OUI_TYPE_WFD    0x0a            /* WiFi Display OUI TYPE */
-#define wl_iw_is_wfd_ie(ie, tlvs, len)  wl_iw_has_ie(ie, tlvs, len, \
-		(const uint8 *)WFA_OUI, WFA_OUI_LEN, WFA_OUI_TYPE_WFD)
+    //by sjark 100818
+    val = 1;
+    error = dev_wlc_ioctl(dev, WLC_SET_PM, &val, sizeof(val));
+    if(error) WL_ERROR(("SET PM fail. error = %d",error));
 
+    val = 20;
+    error =dev_wlc_intvar_set(dev, "pspoll_prd", val);
+    if(error) WL_ERROR(("SET pspoll_prd fail. error = %d",error));
 
-int wl_iw_add_vndr_ie(
-			struct net_device *dev,
-			struct iw_request_info *info,
-			union iwreq_data *wrqu,
-			char *extra)
-{
+    #if 0
+    val = 1;
+    error =dev_wlc_intvar_set(dev, "wme_apsd", val);        //need wl down
+    if(error) WL_ERROR(("SET wme_apsd fail. error = %d",error));
 
-#define VNDR_SPEC_ELEMENT_ID 0xdd
+    val = 0x3;
+    error =dev_wlc_intvar_set(dev, "wme_qosinfo", val);     //need wl down
+    if(error) WL_ERROR(("SET wme_qosinfo fail. error = %d",error));
 
-	int err=0;
-	u32 pos;
-	u8 * ie_buf;
-	u32 ie_id, ie_len, data_len; 
-	u8  vndr_ie[512] = {0,};
-	u8 delete;
+    val = 1000;
+    error =dev_wlc_intvar_set(dev, "wme_apsd_trigger", val);
+    if(error) WL_ERROR(("SET wme_apsd_trigger fail. error = %d",error));
 	
+    val = 0;
+    error =dev_wlc_intvar_set(dev, "wme_auto_trigger", val);
+    if(error) WL_ERROR(("SET wme_auto_trigger fail. error = %d",error));
+    #endif
 	
-	WL_TRACE(("wl_iw_add_vndr_ie info->cmd:%x, info->flags:%x, u.data:%p, u.len:%d\n",
-		info->cmd, info->flags,
-		wrqu->data.pointer, wrqu->data.length));
+    return error;
+}
+//PM=2, wme_apsd=0, wme_qosinfo=0x0, wme_apsd_trigger=0, wme_auto_trigger=1
+static int wl_iw_voip_stop(struct net_device *dev)
+{
+    int error = 0;
+    int val;
 
-	data_len = wrqu->data.length - strlen("add_vndrie");
+    //by sjark 100818
+    val = 2;
+    error = dev_wlc_ioctl(dev, WLC_SET_PM, &val, sizeof(val));
+    if(error) WL_ERROR(("SET PM fail. error = %d",error));
 
-	/* we assume that extra_ie come from wpa_supplicant by this private cmd is always wps_ie. */
 	
-	if (data_len != 0) {
+    val = 0;
+    error =dev_wlc_intvar_set(dev, "pspoll_prd", val);
+    if(error) WL_ERROR(("SET pspoll_prd fail. error = %d",error));
 		
-		memcpy(vndr_ie, extra+strlen("add_vndrie")+1,data_len);
-		pos = 0;		
-		ie_buf = (u8 *) vndr_ie;
-		ie_id = ie_buf[pos++];
-		ie_len = ie_buf[pos++];
-
-		if( wl_iw_is_wps_ie(ie_buf, NULL, 0) == FALSE )
-		{
-			WL_ERROR(("%s: no wps_ie. return\n", __FUNCTION__ ));
-			return 0;
-		}
-
-		/* delete wps_ie */
-		delete = 1;
-		if (ie_id == DOT11_MNG_VS_ID) {
-			WL_TRACE(("WPS:  DELETE_IE : %d, Len : %d , OUI :"
-					"%02x:%02x:%02x\n", ie_id, ie_len, ie_buf[pos],
-					ie_buf[pos+1], ie_buf[pos+2]));
-			err = wl_iw_vndr_ie(dev,VNDR_IE_PRBREQ_FLAG,
-				ie_buf+pos, VNDR_SPEC_ELEMENT_ID, ie_buf+pos+3,ie_len-3, delete);
-			if ( err != 0 ) {
-				WL_ERROR(("WPS:  wl_iw_vndr_ie delete result=%d\n",err));
-			}
-		}
+    #if 0
+    val = 0;
+    error =dev_wlc_intvar_set(dev, "wme_apsd", val);        //need wl down
+    if(error) WL_ERROR(("SET wme_apsd fail. error = %d",error));
+
+    val = 0x0;
+    error =dev_wlc_intvar_set(dev, "wme_qosinfo", val);     //need wl down
+    if(error) WL_ERROR(("SET wme_qosinfo fail. error = %d",error));
+
+    val = 0;
+    error =dev_wlc_intvar_set(dev, "wme_apsd_trigger", val);
+    if(error) WL_ERROR(("SET wme_apsd_trigger fail. error = %d",error));
 		
-		pos =0;
-		ie_buf = (u8 *) vndr_ie;
-		ie_id = ie_buf[pos++];
-		ie_len = ie_buf[pos++];
-		/* add wps_ie */
-		delete = 0;
-		WL_TRACE(("WPS:  ADD_IE : %d, Len : %d , OUI :"
-				"%02x:%02x:%02x\n", ie_id, ie_len, ie_buf[pos],
-				ie_buf[pos+1], ie_buf[pos+2]));
-		err = wl_iw_vndr_ie(dev,VNDR_IE_PRBREQ_FLAG ,ie_buf+pos, VNDR_SPEC_ELEMENT_ID, ie_buf+pos+3,ie_len-3, delete);
-		if ( err != 0 ) {
-			WL_ERROR(("WPS:  wl_iw_vndr_ie add result=%d\n",err));
-		}
-	}
+    val = 1;
+    error =dev_wlc_intvar_set(dev, "wme_auto_trigger", val);
+    if(error) WL_ERROR(("SET wme_auto_trigger fail. error = %d",error));
+    #endif
 	
-	return err;
+    return error;
 }
+#endif	/* Set VOIP */
+#endif /* CONFIG_LGE_BCM432X_PATCH */
+/* LGE_CHANGE_E [yoohoo@lge.com] 2009-05-14, support private command */
 
-static int
-wl_iw_set_priv(
+static int wl_iw_set_priv(
 	struct net_device *dev,
 	struct iw_request_info *info,
 	struct iw_point *dwrq,
@@ -6555,9 +7953,9 @@ wl_iw_set_priv(
 {
 	int ret = 0;
 	char * extra;
+#if defined(CONFIG_LGE_BCM432X_PATCH)
 /* LGE_CHANGE_S, [dongp.kim@lge.com] 2010-04-02 */
 /* [WLAN] Fixing wl_iw_set_priv function */
-#if defined(CONFIG_LGE_BCM432X_PATCH)
 	wl_iw_t *iw;
 
 	if (!dev) {
@@ -6565,12 +7963,10 @@ wl_iw_set_priv(
 		return -EFAULT;
 	}
 	iw = *(wl_iw_t **)netdev_priv(dev);
+/* LGE_CHANGE_E, [dongp.kim@lge.com] 2010-04-02 */
 #else
-#if defined(BCMDONGLEHOST)
 	wl_iw_t *iw = *(wl_iw_t **)netdev_priv(dev);
-#endif /* defined(BCMDONGLEHOST) */
 #endif	/* defined(CONFIG_LGE_BCM432X_PATCH) */
-/* LGE_CHANGE_E, [dongp.kim@lge.com] 2010-04-02 */
 
 	if (!(extra = kmalloc(dwrq->length, GFP_KERNEL)))
 	    return -ENOMEM;
@@ -6580,50 +7976,52 @@ wl_iw_set_priv(
 	    return -EFAULT;
 	}
 
-	WL_TRACE(("%s: SIOCSIWPRIV requst = %s\n",
-		dev->name, extra));
+	WL_TRACE(("%s: SIOCSIWPRIV request %s, info->cmd:%x, info->flags:%d\n dwrq->length:%d\n",
+		dev->name, extra, info->cmd, info->flags, dwrq->length));
 
 	
 	if (dwrq->length && extra) {
-#if defined(BCMDONGLEHOST)
-		//WAKE_LOCK_INIT(iw->pub, WAKE_LOCK_PRIV, "wl_iw_set_priv");
-		DHD_OS_WAKE_LOCK(iw->pub);
-#endif 
+		WAKE_LOCK_INIT(iw->pub, WAKE_LOCK_PRIV, "wl_iw_set_priv");
+		WAKE_LOCK(iw->pub, WAKE_LOCK_PRIV);
 
 /* LGE_CHANGE_S [yoohoo@lge.com] 2009-07-09, send wl_iw_send_priv_event  */
 /* only if receiving regular START command */
 #if defined(CONFIG_LGE_BCM432X_PATCH)
 		if (g_onoff == G_WLAN_SET_OFF) {
-			if (strnicmp(extra, "START", strlen("START")) != 0) {
-				WL_ERROR(("%s First IOCTL after stop is NOT START \n",
-				__FUNCTION__));
-				DHD_OS_WAKE_UNLOCK(iw->pub);
-				//WAKE_LOCK_DESTROY(iw->pub, WAKE_LOCK_PRIV);
+//		ret = wl_iw_control_wl_on(dev, info);		//hyeok
+		if (strnicmp(extra, "START", strlen("START")) != 0){
+			WL_TRACE(("%s, missing START, simulate START\n", __FUNCTION__));
+#if 1		//hyeok
+			if(extra)
 				kfree(extra);
+			WAKE_UNLOCK(iw->pub, WAKE_LOCK_PRIV);
+			WAKE_LOCK_DESTROY(iw->pub, WAKE_LOCK_PRIV);
 				return -EFAULT;
-			} else {
-				wl_iw_control_wl_on(dev, info);
+#endif
+		}
+		else {
+			ret = wl_iw_control_wl_on(dev, info);	//hyeok
+//			if(ret == 0)  //hyeok
+//				wl_iw_send_priv_event(dev, "START"); //hyeok
 				WL_TRACE(("%s, Received regular START command\n", __FUNCTION__));
 			}
-
 		} else if(strnicmp(extra, "START", strlen("START")) == 0) {
 			/* if g_onoff is G_WLAN_SET_ON, then notify wl_iw_send_priv_event unconditionly */	
-// LGE_CHANGE_S, [WiFi][ella.hwang@lge.com, moon-wifi@lge.com], 20120417, Wi-Fi driver skip start/stop cmd on ICS
+//                                                                                                               
 	#if !defined(CONFIG_LGE_BCM432X_PATCH)
 			wl_iw_send_priv_event(dev, "START");
 	#endif
-// LGE_CHANGE_E, [WiFi][ella.hwang@lge.com, moon-wifi@lge.com], 20120417, Wi-Fi driver skip start/stop cmd on ICS
+//                                                                                                               
 			WL_TRACE(("wl_iw_send_priv_event response to START PRIVATE command\n"));
 		}
-#else /* CONFIG_LGE_BCM432X_PATCH */
+#else /*                          */
 		if (g_onoff == G_WLAN_SET_OFF) {
 			if (strnicmp(extra, "START", strlen("START")) != 0) {
-				WL_ERROR(("%s First IOCTL after stop is NOT START \n",
+					WL_ERROR(("%s First IOCTL after stop is NOT START \n", \
 				__FUNCTION__));
-#if defined(BCMDONGLEHOST)
-				DHD_OS_WAKE_UNLOCK(iw->pub);
-				//WAKE_LOCK_DESTROY(iw->pub, WAKE_LOCK_PRIV);
-#endif
+
+				WAKE_UNLOCK(iw->pub, WAKE_LOCK_PRIV);
+				WAKE_LOCK_DESTROY(iw->pub, WAKE_LOCK_PRIV);
 				kfree(extra);
 				return -EFAULT;
 			} else {
@@ -6632,18 +8030,18 @@ wl_iw_set_priv(
 			}
 		}
 #endif /* CONFIG_LGE_BCM432X_PATCH */
-		/* LGE_CHANGE_E [yoohoo@lge.com] 2009-07-09, send wl_iw_send_priv_event only if receiving regular START command */		
+/* LGE_CHANGE_E [yoohoo@lge.com] 2009-07-09, send wl_iw_send_priv_event only if receiving regular START command */		
 
 	    if (strnicmp(extra, "SCAN-ACTIVE", strlen("SCAN-ACTIVE")) == 0) {
 #ifdef ENABLE_ACTIVE_PASSIVE_SCAN_SUPPRESS
-			WL_TRACE(("%s: active scan setting supppressed\n", dev->name));
+			WL_TRACE(("%s: active scan setting suppressed\n", dev->name));
 #else
 			ret = wl_iw_set_active_scan(dev, info, (union iwreq_data *)dwrq, extra);
 #endif 
 	    }
 	    else if (strnicmp(extra, "SCAN-PASSIVE", strlen("SCAN-PASSIVE")) == 0)
 #ifdef ENABLE_ACTIVE_PASSIVE_SCAN_SUPPRESS
-			WL_TRACE(("%s: passive scan setting supppressed\n", dev->name));
+			WL_TRACE(("%s: passive scan setting suppressed\n", dev->name));
 #else
 			ret = wl_iw_set_passive_scan(dev, info, (union iwreq_data *)dwrq, extra);
 #endif 
@@ -6655,18 +8053,48 @@ wl_iw_set_priv(
 			ret = wl_iw_get_macaddr(dev, info, (union iwreq_data *)dwrq, extra);
 	    else if (strnicmp(extra, "COUNTRY", strlen("COUNTRY")) == 0)
 			ret = wl_iw_set_country(dev, info, (union iwreq_data *)dwrq, extra);
-#if defined(CONFIG_BRCM_LGE_WL_HOSTWAKEUP) && defined(CONFIG_BRCM_LGE_WL_ARPOFFLOAD)
-	    else if (strnicmp(extra, "IPADDR", strlen("IPADDR")) == 0)
-			ret = wl_iw_set_hostip(dev, info, (union iwreq_data *)dwrq, extra);
-#endif	/* defined(CONFIG_BRCM_LGE_WL_HOSTWAKEUP) && defined(CONFIG_BRCM_LGE_WL_ARPOFFLOAD) */
+#if defined(CONFIG_BRCM_LGE_WL_ARPOFFLOAD)
+/*	    else if (strnicmp(extra, "IPADDR", strlen("IPADDR")) == 0)
+			ret = wl_iw_set_hostip(dev, info, (union iwreq_data *)dwrq, extra); */
+#endif	/* defined(CONFIG_BRCM_LGE_WL_ARPOFFLOAD) */
 	    else if (strnicmp(extra, "STOP", strlen("STOP")) == 0)
 			ret = wl_iw_control_wl_off(dev, info);
-#if !defined(CONFIG_LGE_BCM432X_PATCH)
+	    else if (strnicmp(extra, BAND_GET_CMD, strlen(BAND_GET_CMD)) == 0)
+			ret = wl_iw_get_band(dev, info, (union iwreq_data *)dwrq, extra);
+	    else if (strnicmp(extra, BAND_SET_CMD, strlen(BAND_SET_CMD)) == 0)
+			ret = wl_iw_set_band(dev, info, (union iwreq_data *)dwrq, extra);
+	    else if (strnicmp(extra, DTIM_SKIP_GET_CMD, strlen(DTIM_SKIP_GET_CMD)) == 0)
+			ret = wl_iw_get_dtim_skip(dev, info, (union iwreq_data *)dwrq, extra);
+	    else if (strnicmp(extra, DTIM_SKIP_SET_CMD, strlen(DTIM_SKIP_SET_CMD)) == 0)
+			ret = wl_iw_set_dtim_skip(dev, info, (union iwreq_data *)dwrq, extra);
+	    else if (strnicmp(extra, SETSUSPEND_CMD, strlen(SETSUSPEND_CMD)) == 0)
+			ret = wl_iw_set_suspend(dev, info, (union iwreq_data *)dwrq, extra);
+#if defined(PNO_SUPPORT)
+	    else if (strnicmp(extra, PNOSSIDCLR_SET_CMD, strlen(PNOSSIDCLR_SET_CMD)) == 0)
+			ret = wl_iw_set_pno_reset(dev, info, (union iwreq_data *)dwrq, extra);
+	    else if (strnicmp(extra, PNOSETUP_SET_CMD, strlen(PNOSETUP_SET_CMD)) == 0)
+			ret = wl_iw_set_pno_set(dev, info, (union iwreq_data *)dwrq, extra);
+	    else if (strnicmp(extra, PNOENABLE_SET_CMD, strlen(PNOENABLE_SET_CMD)) == 0)
+			ret = wl_iw_set_pno_enable(dev, info, (union iwreq_data *)dwrq, extra);
+#endif 
+#if defined(CSCAN)
+	    
+	    else if (strnicmp(extra, CSCAN_COMMAND, strlen(CSCAN_COMMAND)) == 0)
+			ret = wl_iw_set_cscan(dev, info, (union iwreq_data *)dwrq, extra);
+#endif 
+#ifdef CUSTOMER_HW2
 	    else if (strnicmp(extra, "POWERMODE", strlen("POWERMODE")) == 0)
+			ret = wl_iw_set_power_mode(dev, info, (union iwreq_data *)dwrq, extra);
+	    else if (strnicmp(extra, "BTCOEXMODE", strlen("BTCOEXMODE")) == 0) {
+			WL_TRACE_COEX(("%s:got Framwrork cmd: 'BTCOEXMODE'\n", __FUNCTION__));
 			ret = wl_iw_set_btcoex_dhcp(dev, info, (union iwreq_data *)dwrq, extra);
-#endif	/* defined(CONFIG_LGE_BCM432X_PATCH) */
+	    }
+#else
 /* LGE_CHANGE_S [yoohoo@lge.com] 2009-05-14, support private command */
-#if defined(CONFIG_LGE_BCM432X_PATCH)
+#if !defined(CONFIG_LGE_BCM432X_PATCH)
+	    else if (strnicmp(extra, "POWERMODE", strlen("POWERMODE")) == 0)
+			ret = wl_iw_set_btcoex_dhcp(dev, info, (union iwreq_data *)dwrq, extra);
+#else
 		else if (strnicmp(extra, "POWERMODE", 9) == 0)
 			ret = wl_iw_set_powermode(dev, info,
 					(union iwreq_data *)dwrq, extra);
@@ -6710,66 +8138,51 @@ wl_iw_set_priv(
 				dwrq->length = strlen("OK") + 1;
 			}
 		}		
+#if 1	/* Set VOIP */
 		else if (strnicmp(extra, "VOIP-START", 10) == 0) {
 			wl_iw_voip_start(dev);
 		}else if (strnicmp(extra, "VOIP-STOP", 9) == 0) {
 			wl_iw_voip_stop(dev);
-		}
-		/*
-	    else if (strnicmp(extra, "SCAN_UNASSOC_TIME_MS", strlen("SCAN_UNASSOC_TIME_MS")) == 0)
-    	{
-			ret = wl_iw_set_scan_unassoc_time_ms(dev, info, (union iwreq_data *)dwrq, extra);
-		}
-		*/
-		/*
-		else if (strnicmp(extra, "BTCOEXSCAN-START", strlen("BTCOEXSCAN-START")) == 0)
-		{
-			ret = wl_iw_set_scan_unassoc_time_30_ms(dev, info, (union iwreq_data *)dwrq, extra);
-		}
-		
-		else if (strnicmp(extra, "BTCOEXSCAN-STOP", strlen("BTCOEXSCAN-STOP")) == 0)
-		{
-			ret = wl_iw_set_scan_unassoc_time_80_ms(dev, info, (union iwreq_data *)dwrq, extra);
-		}
-		*/
-		else if (strnicmp(extra, "KEEP_ALIVE", strlen("KEEP_ALIVE")) == 0)
-		{
-			ret = wl_keep_alive_set(dev, extra);
-		}
-	else if (strnicmp(extra, "PM2_SLEEP_RET", strlen("PM2_SLEEP_RET")) == 0)
-	{
-	//	WL_ERROR("%s PM2_SLEEP_RET",__FUNCTION__);
-		ret = wl_iw_set_pm2_sleep_ret(dev, info, (union iwreq_data *)dwrq, extra);
-	}
-		
+// 20110210 mingi.sung@lge.com DLNA settings [START]
+	    } else if (strnicmp(extra, "DLNA-START", 10) == 0) {
+		    dnla_dtim_val = wl_dtim_val;
+    		/* Not connected BSS. */	
+    		if(dnla_dtim_val == 0)
+    			dnla_dtim_val = 1;
+    		wl_dtim_val = 1;
+	    }else if (strnicmp(extra, "DLNA-STOP", 9) == 0) {
+    		wl_dtim_val = dnla_dtim_val;
+    		dnla_dtim_val = 0;
+		}
+// 20110210 mingi.sung@lge.com DLNA settings [END]
+#endif	/* Set VOIP */
 #endif /* CONFIG_LGE_BCM432X_PATCH */
 /* LGE_CHANGE_E [yoohoo@lge.com] 2009-05-14, support private command */
+#endif 
 #ifdef SOFTAP
+#ifdef SOFTAP_TLV_CFG
+		else if (strnicmp(extra, SOFTAP_SET_CMD, strlen(SOFTAP_SET_CMD)) == 0) {
+		    wl_iw_softap_cfg_tlv(dev, info, (union iwreq_data *)dwrq, extra);
+	    }
+#endif
 	    else if (strnicmp(extra, "ASCII_CMD", strlen("ASCII_CMD")) == 0) {
+			WL_SOFTAP(("gen purpose 'ASCII CMD' by framework"));
+	        
 		    wl_iw_process_private_ascii_cmd(dev, info, (union iwreq_data *)dwrq, extra);
 	    }
 		else if (strnicmp(extra, "AP_MAC_LIST_SET", strlen("AP_MAC_LIST_SET")) == 0) {
 			WL_SOFTAP(("penguin, set AP_MAC_LIST_SET\n"));
 			set_ap_mac_list(dev, (extra + PROFILE_OFFSET));
 	    }
-#endif /* SOFTAP */
-/* LGE_UPDATE_S 20110708 BRCM patch */
-#ifdef LGE_ROAM_PARAMETER
-        else if( strnicmp( extra, "ROAM_CMD", strlen("ROAM_CMD") ) == 0 )
-            ret = wl_iw_process_private_roam_cmd( dev, info, (union iwreq_data *)dwrq, extra );
-#endif //LGE_ROAM_PARAMETER
-	    else if (strnicmp(extra, "add_vndrie", strlen("add_vndrie")) == 0) {
-			ret = wl_iw_add_vndr_ie(dev, info, (union iwreq_data *)dwrq, extra);
-	    }
+#endif 
 	    else {
+			WL_TRACE(("Unknown PRIVATE command %s\n", extra));
 			snprintf(extra, MAX_WX_STRING, "OK");
 			dwrq->length = strlen("OK") + 1;
-			WL_TRACE(("Unkown PRIVATE command , ignored\n"));
+			WL_ERROR(("Unknown PRIVATE command, ignored\n"));
 		}
-#if defined(BCMDONGLEHOST)
-		DHD_OS_WAKE_UNLOCK(iw->pub);
-		//WAKE_LOCK_DESTROY(iw->pub, WAKE_LOCK_PRIV);
-#endif 
+		WAKE_UNLOCK(iw->pub, WAKE_LOCK_PRIV);
+		WAKE_LOCK_DESTROY(iw->pub, WAKE_LOCK_PRIV);
 	}
 
 	if (extra) {
@@ -6813,18 +8226,15 @@ static const iw_handler wl_iw_handler[] =
 #else
 	(iw_handler) NULL,			
 #endif
-#if defined(WL_IW_USE_ISCAN) || defined(WL_IW_USE_ESCAN)
-	(iw_handler) wl_iw_scan_get_aplist,	
+#if defined(WL_IW_USE_ISCAN)
+	(iw_handler) wl_iw_iscan_get_aplist,	
 #else
 	(iw_handler) wl_iw_get_aplist,		
 #endif 
 #if WIRELESS_EXT > 13
 #if defined(WL_IW_USE_ISCAN)
 	(iw_handler) wl_iw_iscan_set_scan,	
-	(iw_handler) wl_iw_scan_get_scan,	
-#elif defined(WL_IW_USE_ESCAN)
-	(iw_handler) wl_iw_escan_set_scan,	
-	(iw_handler) wl_iw_scan_get_scan,	
+	(iw_handler) wl_iw_iscan_get_scan,	
 #else
 	(iw_handler) wl_iw_set_scan,		
 	(iw_handler) wl_iw_get_scan,		
@@ -6865,7 +8275,7 @@ static const iw_handler wl_iw_handler[] =
 	(iw_handler) wl_iw_set_encodeext,	
 	(iw_handler) wl_iw_get_encodeext,	
 #ifdef BCMWPA2
-	(iw_handler) NULL,			
+	(iw_handler) wl_iw_set_pmksa,			
 #endif
 #endif 
 };
@@ -6907,10 +8317,19 @@ static const iw_handler wl_iw_priv_handler[] = {
 	NULL,
 	(iw_handler)wl_iw_control_wl_on_softap,
 #endif /* defined(CONFIG_LGE_BCM432X_PATCH) && defined(SOFTAP) */
-#endif /* SOFTAP */
+	NULL, 
+	(iw_handler)iwpriv_set_ap_sta_disassoc,
+#endif 
+
+#if defined(CSCAN)
+	
+	NULL,
+	(iw_handler)iwpriv_set_cscan
+#endif	
 };
 
-static const struct iw_priv_args wl_iw_priv_args[] = {
+static const struct iw_priv_args wl_iw_priv_args[] =
+{
 	{
 		WL_IW_SET_ACTIVE_SCAN,
 		0,
@@ -6960,12 +8379,14 @@ static const struct iw_priv_args wl_iw_priv_args[] = {
 		0,
 		"AP_SET_CFG"
 	},
+
 	{
 		WL_AP_STA_LIST,
-		0,                     
 		IW_PRIV_TYPE_CHAR | 0, 
+		IW_PRIV_TYPE_CHAR | 1024,  
 		"AP_GET_STA_LIST"
 	},
+
 	{
 		WL_AP_MAC_FLTR,
 		IW_PRIV_TYPE_CHAR | 256,                      
@@ -7008,10 +8429,27 @@ static const struct iw_priv_args wl_iw_priv_args[] = {
 		0,
 		IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_WX_STRING,
 		"START-SOFTAP"
+
 	},
 #endif	/* defined(CONFIG_LGE_BCM432X_PATCH) && defined(SOFTAP) */
-#endif /* SOFTAP */
-};
+
+	{ 
+		WL_AP_STA_DISASSOC,
+		IW_PRIV_TYPE_CHAR | 256, 
+		IW_PRIV_TYPE_CHAR | 0,   
+		"AP_STA_DISASSOC"
+	},
+#endif 
+
+#if defined(CSCAN)
+	{ 
+		WL_COMBO_SCAN,
+		IW_PRIV_TYPE_CHAR | 1024,  
+		0,
+		"CSCAN"
+	},
+#endif 
+	};
 
 const struct iw_handler_def wl_iw_handler_def =
 {
@@ -7023,17 +8461,14 @@ const struct iw_handler_def wl_iw_handler_def =
 	.private_args = (void *) wl_iw_priv_args,
 
 #if WIRELESS_EXT >= 19
-#if defined(BCMDONGLEHOST)
 	get_wireless_stats: dhd_get_wireless_stats,
-#else
-	get_wireless_stats: wl_get_wireless_stats,
-#endif 
 #endif 
 	};
 #endif 
 
-int
-wl_iw_ioctl(
+
+
+int wl_iw_ioctl(
 	struct net_device *dev,
 	struct ifreq *rq,
 	int cmd
@@ -7045,10 +8480,13 @@ wl_iw_ioctl(
 	char *extra = NULL;
 	int token_size = 1, max_tokens = 0, ret = 0;
 
+	WL_TRACE(("\n%s, cmd:%x alled via dhd->do_ioctl()entry point\n", __FUNCTION__, cmd));
 	if (cmd < SIOCIWFIRST ||
 		IW_IOCTL_IDX(cmd) >= ARRAYSIZE(wl_iw_handler) ||
-		!(handler = wl_iw_handler[IW_IOCTL_IDX(cmd)]))
+		!(handler = wl_iw_handler[IW_IOCTL_IDX(cmd)])) {
+			WL_ERROR(("%s: error in cmd=%x : not supported\n", __FUNCTION__, cmd));
 		return -EOPNOTSUPP;
+	}
 
 	switch (cmd) {
 
@@ -7065,11 +8503,12 @@ wl_iw_ioctl(
 	case SIOCSIWENCODEEXT:
 	case SIOCGIWENCODEEXT:
 #endif
-		max_tokens = IW_ENCODING_TOKEN_MAX;
+		max_tokens = wrq->u.data.length;
 		break;
 
 	case SIOCGIWRANGE:
-		max_tokens = sizeof(struct iw_range);
+		
+		max_tokens = sizeof(struct iw_range) + 500;
 		break;
 
 	case SIOCGIWAPLIST:
@@ -7083,10 +8522,6 @@ wl_iw_ioctl(
 	if (g_iscan)
 		max_tokens = wrq->u.data.length;
 	else
-#elif defined(WL_IW_USE_ESCAN)
-	if (g_escan)
-		max_tokens = wrq->u.data.length;
-	else
 #endif
 		max_tokens = IW_SCAN_MAX_DATA;
 		break;
@@ -7102,15 +8537,21 @@ wl_iw_ioctl(
 		max_tokens = IW_MAX_SPY;
 		break;
 
+#if WIRELESS_EXT > 17
+	case SIOCSIWPMKSA:
+	case SIOCSIWGENIE:
+#endif 
 	case SIOCSIWPRIV:
 		max_tokens = wrq->u.data.length;
 		break;
 	}
 
 	if (max_tokens && wrq->u.data.pointer) {
-		if (wrq->u.data.length > max_tokens)
+		if (wrq->u.data.length > max_tokens) {
+			WL_ERROR(("%s: error in cmd=%x wrq->u.data.length=%d  > max_tokens=%d\n", \
+				__FUNCTION__, cmd, wrq->u.data.length, max_tokens));
 			return -E2BIG;
-
+		}
 		if (!(extra = kmalloc(max_tokens * token_size, GFP_KERNEL)))
 			return -ENOMEM;
 
@@ -7137,7 +8578,6 @@ wl_iw_ioctl(
 	return ret;
 }
 
-#if defined(STA) || defined(BCMDONGLEHOST)
 
 bool
 wl_iw_conn_status_str(uint32 event_type, uint32 status, uint32 reason,
@@ -7178,12 +8618,10 @@ wl_iw_conn_status_str(uint32 event_type, uint32 status, uint32 reason,
 		"Conn", "ReassocTimeout"},
 		{WLC_E_REASSOC,      WLC_E_STATUS_ABORT,     WL_IW_DONT_CARE,
 		"Conn", "ReassocAbort"},
-#if defined(BCMSUP_PSK) || defined(BCMDONGLEHOST)
 		{WLC_E_PSK_SUP,      WLC_SUP_KEYED,          WL_IW_DONT_CARE,
 		"Sup", "ConnSuccess"},
 		{WLC_E_PSK_SUP,      WL_IW_DONT_CARE,        WL_IW_DONT_CARE,
 		"Sup", "WpaHandshakeFail"},
-#endif 
 		{WLC_E_DEAUTH_IND,   WL_IW_DONT_CARE,        WL_IW_DONT_CARE,
 		"Conn", "Deauth"},
 		{WLC_E_DISASSOC_IND, WL_IW_DONT_CARE,        WL_IW_DONT_CARE,
@@ -7225,15 +8663,9 @@ wl_iw_conn_status_str(uint32 event_type, uint32 status, uint32 reason,
 static bool
 wl_iw_check_conn_fail(wl_event_msg_t *e, char* stringBuf, uint buflen)
 {
-#ifdef BCMDONGLEHOST
 	uint32 event = ntoh32(e->event_type);
 	uint32 status =  ntoh32(e->status);
 	uint32 reason =  ntoh32(e->reason);
-#else
-	uint32 event = e->event_type;
-	uint32 status =  e->status;
-	uint32 reason =  e->reason;
-#endif
 
 	if (wl_iw_conn_status_str(event, status, reason, stringBuf, buflen)) {
 		return TRUE;
@@ -7242,72 +8674,11 @@ wl_iw_check_conn_fail(wl_event_msg_t *e, char* stringBuf, uint buflen)
 		return FALSE;
 }
 #endif 
-#endif 
 
 #ifndef IW_CUSTOM_MAX
 #define IW_CUSTOM_MAX 256 
 #endif 
 
-#if defined(WL_IW_USE_ESCAN)
-static void
-wl_iw_escan_update(wl_escan_result_t *escan_result)
-{
-	wl_bss_info_t *bi = escan_result->bss_info;
-	escan_info_t *escan = g_escan;
-	wl_bss_info_t *bss = NULL;
-	wl_scan_results_t *list;
-	int bi_length;
-	int i;
-
-
-	if (dtoh16(escan_result->bss_count) != 1) {
-		WL_TRACE(("Invalid bss_count %d: ignoring\n", escan_result->bss_count));
-		return;
-	}
-	bi_length = dtoh32(bi->length);
-	if (bi_length != dtoh32(escan_result->buflen) - WL_ESCAN_RESULTS_FIXED_SIZE) {
-		WL_TRACE(("Invalid bss_info length %d: ignorning\n", bi_length));
-		return;
-	}
-	list = (wl_scan_results_t *)escan->escan_buf;
-	if (bi_length > ESCAN_BUF_SIZE - list->buflen) {
-		WL_TRACE(("Buffer is too small: ignorning\n"));
-		return;
-	}
-
-#define WLC_BSS_RSSI_ON_CHANNEL 0x0002 
-
-	for (i = 0; i < list->count; i++) {
-		bss = bss ? (wl_bss_info_t *)((uintptr)bss + dtoh32(bss->length)) : list->bss_info;
-
-		if (!bcmp(&bi->BSSID, &bss->BSSID, ETHER_ADDR_LEN) &&
-			CHSPEC_BAND(bi->chanspec) == CHSPEC_BAND(bss->chanspec) &&
-			bi->SSID_len == bss->SSID_len &&
-			!bcmp(bi->SSID, bss->SSID, bi->SSID_len)) {
-			if ((bss->flags & WLC_BSS_RSSI_ON_CHANNEL) ==
-			    (bi->flags & WLC_BSS_RSSI_ON_CHANNEL)) {
-				
-				bss->RSSI = MAX(bss->RSSI, bi->RSSI);
-			} else if ((bss->flags & WLC_BSS_RSSI_ON_CHANNEL) &&
-			           (bi->flags & WLC_BSS_RSSI_ON_CHANNEL) == 0) {
-				
-				bss->RSSI = bi->RSSI;
-				bss->flags |= WLC_BSS_RSSI_ON_CHANNEL;
-			}
-
-			return;
-		}
-	}
-
-	memcpy(&escan->escan_buf[list->buflen], bi, bi_length);
-	list->version = dtoh32(bi->version); 
-	list->buflen += bi_length;
-	list->count++;
-
-	return;
-}
-#endif 
-
 void
 wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data)
 {
@@ -7315,20 +8686,14 @@ wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data)
 	union iwreq_data wrqu;
 	char extra[IW_CUSTOM_MAX + 1];
 	int cmd = 0;
-#ifdef BCMDONGLEHOST
 	uint32 event_type = ntoh32(e->event_type);
 	uint16 flags =  ntoh16(e->flags);
 	uint32 datalen = ntoh32(e->datalen);
 	uint32 status =  ntoh32(e->status);
-#else
-	uint32 event_type = e->event_type;
-	uint16 flags =  e->flags;
-	uint32 datalen = e->datalen;
-	uint32 status =  e->status;
-#endif
 	wl_iw_t *iw;
 	uint32 toto;
-
+	static  uint32 roam_no_success = 0;
+	static bool roam_no_success_send = FALSE;
 	memset(&wrqu, 0, sizeof(wrqu));
 	memset(extra, 0, sizeof(extra));
 	iw = 0;
@@ -7344,7 +8709,14 @@ wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data)
 
 	WL_TRACE(("%s: dev=%s event=%d \n", __FUNCTION__, dev->name, event_type));
 
+	
 	switch (event_type) {
+
+	case WLC_E_RELOAD:
+		 WL_ERROR(("%s: Firmware ERROR %d\n", __FUNCTION__, status));
+		 net_os_send_hang_message(dev);
+		 return;
+
 #if defined(SOFTAP)
 	case WLC_E_PRUNE:
 		if (ap_cfg_running) {
@@ -7373,7 +8745,7 @@ wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data)
 			}
 		}
 		break;
-#endif /* SOFTAP */
+#endif 
 	case WLC_E_TXFAIL:
 		cmd = IWEVTXDROP;
 		memcpy(wrqu.addr.sa_data, &e->addr, ETHER_ADDR_LEN);
@@ -7389,10 +8761,37 @@ wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data)
 			wl_iw_send_priv_event(priv_dev, "STA_JOIN");
 			return;
 		}
-#endif /* SOFTAP */
+#endif 
 		memcpy(wrqu.addr.sa_data, &e->addr, ETHER_ADDR_LEN);
 		wrqu.addr.sa_family = ARPHRD_ETHER;
 		cmd = IWEVREGISTERED;
+#if defined(CONFIG_LGE_BCM432X_PATCH)
+		wl_dtim_set = 1 ;
+#endif
+		break;
+	case WLC_E_ROAM:
+		if (status == WLC_E_STATUS_SUCCESS) {
+			
+			memcpy(wrqu.addr.sa_data, &e->addr.octet, ETHER_ADDR_LEN);
+			wrqu.addr.sa_family = ARPHRD_ETHER;
+			cmd = SIOCGIWAP;
+		}
+		else if (status == WLC_E_STATUS_NO_NETWORKS) {
+			roam_no_success++;
+			if ((roam_no_success == 5) && (roam_no_success_send == FALSE)) {
+				
+				roam_no_success_send = TRUE;
+				bzero(wrqu.addr.sa_data, ETHER_ADDR_LEN);
+				bzero(&extra, ETHER_ADDR_LEN);
+				cmd = SIOCGIWAP;
+				WL_ERROR(("%s  ROAMING did not succeeded , send Link Down\n", \
+					__FUNCTION__));
+			}
+			else {
+				WL_TRACE(("##### ROAMING did not succeeded %d\n", roam_no_success));
+				return;
+			}
+		}
 		break;
 	case WLC_E_DEAUTH_IND:
 	case WLC_E_DISASSOC_IND:
@@ -7402,7 +8801,7 @@ wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data)
 			wl_iw_send_priv_event(priv_dev, "STA_LEAVE");
 			return;
 		}
-#endif /* SOFTAP */
+#endif 
 		cmd = SIOCGIWAP;
 		bzero(wrqu.addr.sa_data, ETHER_ADDR_LEN);
 		wrqu.addr.sa_family = ARPHRD_ETHER;
@@ -7428,15 +8827,13 @@ wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data)
 		}
 #else		
 			g_ss_cache_ctrl.m_link_down = 1;
-#endif /* SOFTAP */
+#endif 
 			WL_TRACE(("Link Down\n"));
 
 			bzero(wrqu.addr.sa_data, ETHER_ADDR_LEN);
 			bzero(&extra, ETHER_ADDR_LEN);
-#if defined(BCMDONGLEHOST)
-			DHD_OS_WAKE_LOCK_TIMEOUT_ENABLE(iw->pub);
-			DHD_OS_WAKE_LOCK_TIMEOUT_WITH_TIME(iw->pub, 20 * HZ);
-#endif
+//			WAKE_LOCK_TIMEOUT(iw->pub, WAKE_LOCK_LINK_DOWN_TMOUT, 20 * HZ);
+			WAKE_LOCK_TIMEOUT(iw->pub, WAKE_LOCK_LINK_DOWN_TMOUT, 10 * HZ);
 		}
 		else {
 			
@@ -7447,17 +8844,20 @@ wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data)
 #ifdef SOFTAP
 
 #ifdef AP_ONLY
-			if (ap_cfg_running)
+			if (ap_cfg_running) {
 #else
-			if (ap_cfg_running && !strncmp(dev->name, "wl0.1", 5))
+			if (ap_cfg_running && !strncmp(dev->name, "wl0.1", 5)) {
 #endif
-			{
+			
 				WL_SOFTAP(("AP UP %d\n", event_type));
 				wl_iw_send_priv_event(priv_dev, "AP_UP");
 			} else {
 				WL_TRACE(("STA_LINK_UP\n"));
+				roam_no_success_send = FALSE;
+				roam_no_success = 0;
 			}
-#endif /* SOFTAP */
+#else
+#endif 
 			WL_TRACE(("Link UP\n"));
 
 		}
@@ -7469,7 +8869,7 @@ wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data)
 			wrqu.data.length = datalen + 1;
 			extra[0] = WLC_E_ACTION_FRAME;
 			memcpy(&extra[1], data, datalen);
-			printf("WLC_E_ACTION_FRAME len %d \n", wrqu.data.length);
+			WL_TRACE(("WLC_E_ACTION_FRAME len %d \n", wrqu.data.length));
 		}
 		break;
 
@@ -7501,17 +8901,17 @@ wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data)
 	}
 #ifdef BCMWPA2
 	case WLC_E_PMKID_CACHE: {
+		if (data)
+		{
 		struct iw_pmkid_cand *iwpmkidcand = (struct iw_pmkid_cand *)&extra;
 		pmkid_cand_list_t *pmkcandlist;
 		pmkid_cand_t	*pmkidcand;
 		int count;
 
-		if (data == NULL)
-			break;
-
 		cmd = IWEVPMKIDCAND;
 		pmkcandlist = data;
 		count = ntoh32_ua((uint8 *)&pmkcandlist->npmkid_cand);
+			ASSERT(count >= 0);
 		wrqu.data.length = sizeof(struct iw_pmkid_cand);
 		pmkidcand = pmkcandlist->pmkid_cand;
 		while (count) {
@@ -7526,21 +8926,25 @@ wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data)
 			pmkidcand++;
 			count--;
 		}
-		break;
+		}
+		return;
 	}
 #endif 
 #endif 
 
 	case WLC_E_SCAN_COMPLETE:
 #if defined(WL_IW_USE_ISCAN)
-		if ((g_iscan) && (g_iscan->sysioc_pid >= 0) &&
+//		if ((g_iscan) && (g_iscan->sysioc_pid >= 0) &&
+		if ((g_iscan) && (g_iscan->tsk_ctl.thr_pid >= 0) &&
 			(g_iscan->iscan_state != ISCAN_STATE_IDLE))
 		{
-			up(&g_iscan->sysioc_sem);
+//			up(&g_iscan->sysioc_sem);
+			up(&g_iscan->tsk_ctl.sema);
 		} else {
 			cmd = SIOCGIWSCAN;
 			wrqu.data.length = strlen(extra);
-			WL_TRACE(("Event WLC_E_SCAN_COMPLETE from specific scan\n"));
+			WL_TRACE_SCAN(("Event WLC_E_SCAN_COMPLETE from specific scan %d\n", \
+				g_iscan->iscan_state));
 		}
 #else
 			cmd = SIOCGIWSCAN;
@@ -7549,85 +8953,35 @@ wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data)
 #endif 
 	break;
 
-#if defined(WL_IW_USE_ESCAN)
-	case WLC_E_ESCAN_RESULT:
-		if (g_escan->escan_state == ESCAN_STATE_IDLE) {
-			
-			break;
-		}
-
-		if (status == WLC_E_STATUS_PARTIAL) {
-			wl_iw_escan_update((wl_escan_result_t *)data); 
-		}
-		else if (status == WLC_E_STATUS_SUCCESS) {
-			g_escan->escan_state = ESCAN_STATE_IDLE; 
-#if defined(CONFIG_LGE_BCM432X_PATCH)
-			cmd = SIOCGIWSCAN;
-			wrqu.data.length = strlen(extra);
-			printk("escan success !!!\n");
-#endif	/* defined(CONFIG_LGE_BCM432X_PATCH) */
-		}
-#ifdef CONFIG_LGE_BCM432X_PATCH
-		else if (status == WLC_E_STATUS_NEWASSOC)
-		{
-			WL_ERROR(("P:WLC_E_STATUS_NEWASSOC!!\n"));
-			if (g_escan->escan_state == ESCAN_STATE_SCANING)
-			{
-				g_escan->escan_state = ESCAN_STATE_IDLE; 
-				cmd = SIOCGIWSCAN;
-				wrqu.data.length = strlen(extra);
-			}
-		}
-#endif
-		else
-			WL_TRACE(("Unknown escan status %d: ignoring\n", status));
-
-		break;
-
-	
-	case WLC_E_SET_SSID: {
-			if ((status == WLC_E_STATUS_NO_NETWORKS) &&
-				(g_escan->escan_state == ESCAN_STATE_SCANING)) {
-				WL_TRACE(("ESCAN was under progress. Resetting ESCAN_STATE\n"));
-				g_escan->escan_state = ESCAN_STATE_IDLE;
-			}
-
-			break;
-		}
-#endif 
 
-#ifdef CONFIG_LGE_BCM432X_PATCH
-	case WLC_E_DISASSOC:
-		if (g_escan->escan_state == ESCAN_STATE_SCANING)
+	case WLC_E_PFN_NET_FOUND:
 		{
-			WL_TRACE(("ESCAN was under progress. Resetting ESCAN_STATE\n"));
-			g_escan->escan_state = ESCAN_STATE_IDLE;			
-			cmd = SIOCGIWSCAN;
+		wlc_ssid_t	* ssid;
+		ssid = (wlc_ssid_t *)data;
+		WL_ERROR(("%s Event WLC_E_PFN_NET_FOUND, send %s up : find %s len=%d\n", \
+			__FUNCTION__, PNO_EVENT_UP, ssid->SSID, ssid->SSID_len));
+			WAKE_LOCK_TIMEOUT(iw->pub, WAKE_LOCK_PNO_FIND_TMOUT, 20 * HZ);
+		cmd = IWEVCUSTOM;
+		memset(&wrqu, 0, sizeof(wrqu));
+		strcpy(extra, PNO_EVENT_UP);
 			wrqu.data.length = strlen(extra);
 		}
 		break;
-#endif 
 
 	default:
 		
 		WL_TRACE(("Unknown Event %d: ignoring\n", event_type));
 		break;
 	}
-#if defined(CONFIG_LGE_BCM432X_PATCH) && !( defined(CONFIG_BRCM_USE_GPIO_RESET) || defined(CONFIG_BRCM_USE_DEEPSLEEP) )
-	if( g_onoff == G_WLAN_SET_OFF)
-		return;
-#endif	/* CONFIG_LGE_BCM432X_PATCH */
 #ifndef SANDGATE2G
-		if (cmd)
-		{
-			if(cmd == SIOCGIWSCAN)
+		if (cmd) {
+			if (cmd == SIOCGIWSCAN)
 				wireless_send_event(dev, cmd, &wrqu, NULL);
 			else
 				wireless_send_event(dev, cmd, &wrqu, extra);
 		}
 #endif
 
-#if defined(STA) || defined(BCMDONGLEHOST)
 #if WIRELESS_EXT > 14
 	
 	memset(extra, 0, sizeof(extra));
@@ -7639,7 +8993,6 @@ wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data)
 #endif
 	}
 #endif 
-#endif 
 
 #endif 
 }
@@ -7656,14 +9009,14 @@ int wl_iw_get_wireless_stats(struct net_device *dev, struct iw_statistics *wstat
 		goto done;
 
 	phy_noise = dtoh32(phy_noise);
-	WL_TRACE(("wl_iw_get_wireless_stats phy noise=%d\n *****", phy_noise));
+	WL_TRACE(("wl_iw_get_wireless_stats phy noise=%d\n", phy_noise));
 
 	bzero(&scb_val, sizeof(scb_val_t));
 	if ((res = dev_wlc_ioctl(dev, WLC_GET_RSSI, &scb_val, sizeof(scb_val_t))))
 		goto done;
 
 	rssi = dtoh32(scb_val.val);
-	WL_TRACE(("wl_iw_get_wireless_stats rssi=%d ****** \n", rssi));
+	WL_TRACE(("wl_iw_get_wireless_stats rssi=%d\n", rssi));
 	if (rssi <= WL_IW_RSSI_NO_SIGNAL)
 		wstats->qual.qual = 0;
 	else if (rssi <= WL_IW_RSSI_VERY_LOW)
@@ -7687,20 +9040,17 @@ int wl_iw_get_wireless_stats(struct net_device *dev, struct iw_statistics *wstat
 #endif 
 
 #if WIRELESS_EXT > 11
-	WL_TRACE(("wl_iw_get_wireless_stats counters=%d\n *****", (int)sizeof(wl_cnt_t)));
+	WL_TRACE(("wl_iw_get_wireless_stats counters=%d\n", (int)sizeof(wl_cnt_t)));
 
 	memset(&cnt, 0, sizeof(wl_cnt_t));
 	res = dev_wlc_bufvar_get(dev, "counters", (char *)&cnt, sizeof(wl_cnt_t));
 	if (res)
 	{
-		WL_ERROR(("wl_iw_get_wireless_stats counters failed error=%d ****** \n", res));
+		WL_ERROR(("wl_iw_get_wireless_stats counters failed error=%d\n", res));
 		goto done;
 	}
 
 	cnt.version = dtoh16(cnt.version);
-	if (cnt.version & WL_MIN_CNT_ENABLED) {
-		cnt.version &= ~WL_MIN_CNT_ENABLED;
-	}
 	if (cnt.version != WL_CNT_T_VERSION) {
 		WL_TRACE(("\tIncorrect version of counters struct: expected %d; got %d\n",
 			WL_CNT_T_VERSION, cnt.version));
@@ -7729,29 +9079,40 @@ int wl_iw_get_wireless_stats(struct net_device *dev, struct iw_statistics *wstat
 done:
 	return res;
 }
-#if defined(COEX_DHCP)
 static void
 wl_iw_bt_flag_set(
 	struct net_device *dev,
 	bool set)
 {
+#if defined(BT_DHCP_USE_FLAGS)
 	char buf_flag7_dhcp_on[8] = { 7, 00, 00, 00, 0x1, 0x0, 0x00, 0x00 };
 	char buf_flag7_default[8]   = { 7, 00, 00, 00, 0x0, 0x00, 0x00, 0x00};
+#endif
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 	rtnl_lock();
 #endif
 
+
+#if defined(BT_DHCP_eSCO_FIX)
+	
+	set_btc_esco_params(dev, set);
+#endif
+
+
+#if defined(BT_DHCP_USE_FLAGS)
+	WL_TRACE_COEX(("WI-FI priority boost via bt flags, set:%d\n", set));
 	if (set == TRUE) {
 		
-		dev_wlc_bufvar_set(dev, "btc_flags",
+		dev_wlc_bufvar_set(dev, "btc_flags", \
 			(char *)&buf_flag7_dhcp_on[0], sizeof(buf_flag7_dhcp_on));
 	}
 	else  {
 		
-		dev_wlc_bufvar_set(dev, "btc_flags",
+		dev_wlc_bufvar_set(dev, "btc_flags", \
 			(char *)&buf_flag7_default[0], sizeof(buf_flag7_default));
 	}
+#endif
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 	rtnl_unlock();
@@ -7765,48 +9126,79 @@ wl_iw_bt_timerfunc(ulong data)
 	bt_local->timer_on = 0;
 	WL_TRACE(("%s\n", __FUNCTION__));
 	
-	up(&bt_local->bt_sem);
+	//up(&bt_local->bt_sem);
+        up(&bt_local->tsk_ctl.sema);
+
 }
 
 static int
 _bt_dhcp_sysioc_thread(void *data)
 {
+	tsk_ctl_t *tsk_ctl =  (tsk_ctl_t *)data;
+
+
 	DAEMONIZE("dhcp_sysioc");
 
-	while (down_interruptible(&g_bt->bt_sem) == 0) {
+//	while (down_interruptible(&g_bt->bt_sem) == 0) {
+	complete(&tsk_ctl->completed);
+
+	while (down_interruptible(&tsk_ctl->sema) == 0) {
+
+		SMP_RD_BARRIER_DEPENDS();
+		if (tsk_ctl->terminated) {
+			break;
+		}
+
 		if (g_bt->timer_on) {
-			del_timer(&g_bt->timer);
+			del_timer_sync(&g_bt->timer);
 			g_bt->timer_on = 0;
 		}
 
 		switch (g_bt->bt_state) {
 			case BT_DHCP_START:
 				
+				WL_TRACE_COEX(("%s bt_dhcp stm: started \n", __FUNCTION__));
 				g_bt->bt_state = BT_DHCP_OPPORTUNITY_WINDOW;
-				mod_timer(&g_bt->timer, jiffies +
-				           BT_DHCP_OPPORTUNITY_WINDOW_TIEM*HZ/1000);
+				mod_timer(&g_bt->timer, jiffies + \
+				           BT_DHCP_OPPORTUNITY_WINDOW_TIME*HZ/1000);
 				g_bt->timer_on = 1;
 				break;
 			case BT_DHCP_OPPORTUNITY_WINDOW:
+				if 	(g_bt->dhcp_done) {
+					WL_TRACE_COEX(("%s DHCP Done before T1 expiration\n", \
+						__FUNCTION__));
+					goto btc_coex_idle;
+				}
+
+				
+				WL_TRACE_COEX(("%s DHCP T1:%d expired\n", \
+						__FUNCTION__, BT_DHCP_OPPORTUNITY_WINDOW_TIME));
 				
-				WL_TRACE(("%s waiting for %d msec expired, force bt flag\n",
-					__FUNCTION__, BT_DHCP_OPPORTUNITY_WINDOW_TIEM));
 				if (g_bt->dev) wl_iw_bt_flag_set(g_bt->dev, TRUE);
+
 				g_bt->bt_state = BT_DHCP_FLAG_FORCE_TIMEOUT;
 				mod_timer(&g_bt->timer, jiffies + BT_DHCP_FLAG_FORCE_TIME*HZ/1000);
 				g_bt->timer_on = 1;
 				break;
+
 			case BT_DHCP_FLAG_FORCE_TIMEOUT:
+				if 	(g_bt->dhcp_done) {
+					WL_TRACE_COEX(("%s DHCP Done before T2 expiration\n", \
+						__FUNCTION__));
+				} else  {
 				
-				WL_TRACE(("%s waiting for %d msec expired remove bt flag\n",
+					WL_TRACE_COEX(("%s DHCP wait interval T2:%d msec expired\n",
 					__FUNCTION__, BT_DHCP_FLAG_FORCE_TIME));
+				}
+
 				
 				if (g_bt->dev)  wl_iw_bt_flag_set(g_bt->dev, FALSE);
+			btc_coex_idle:
 				g_bt->bt_state = BT_DHCP_IDLE;
 				g_bt->timer_on = 0;
 				break;
 			default:
-				WL_ERROR(("%s error g_status=%d !!!\n", __FUNCTION__,
+				WL_ERROR(("%s error g_status=%d !!!\n", __FUNCTION__, \
 				          g_bt->bt_state));
 				if (g_bt->dev) wl_iw_bt_flag_set(g_bt->dev, FALSE);
 				g_bt->bt_state = BT_DHCP_IDLE;
@@ -7816,10 +9208,11 @@ _bt_dhcp_sysioc_thread(void *data)
 	}
 
 	if (g_bt->timer_on) {
-		del_timer(&g_bt->timer);
+		del_timer_sync(&g_bt->timer);
 		g_bt->timer_on = 0;
 	}
-	complete_and_exit(&g_bt->bt_exited, 0);
+//	complete_and_exit(&g_bt->bt_exited, 0);
+	complete_and_exit(&tsk_ctl->completed, 0);
 }
 
 static void
@@ -7831,9 +9224,14 @@ wl_iw_bt_release(void)
 		return;
 	}
 
+#if 0
 	if (bt_local->bt_pid >= 0) {
 		KILL_PROC(bt_local->bt_pid, SIGTERM);
 		wait_for_completion(&bt_local->bt_exited);
+#else
+	if (bt_local->tsk_ctl.thr_pid >= 0) {
+		PROC_STOP(&bt_local->tsk_ctl);
+#endif
 	}
 	kfree(bt_local);
 	g_bt = NULL;
@@ -7849,7 +9247,7 @@ wl_iw_bt_init(struct net_device *dev)
 		return -ENOMEM;
 
 	memset(bt_dhcp, 0, sizeof(bt_info_t));
-	bt_dhcp->bt_pid = -1;
+//	bt_dhcp->bt_pid = -1;
 	g_bt = bt_dhcp;
 	bt_dhcp->dev = dev;
 	bt_dhcp->bt_state = BT_DHCP_IDLE;
@@ -7859,63 +9257,67 @@ wl_iw_bt_init(struct net_device *dev)
 	init_timer(&bt_dhcp->timer);
 	bt_dhcp->timer.data = (ulong)bt_dhcp;
 	bt_dhcp->timer.function = wl_iw_bt_timerfunc;
+	bt_dhcp->ts_dhcp_start = 0;
+	bt_dhcp->ts_dhcp_ok = 0;
 
+#if 0
 	sema_init(&bt_dhcp->bt_sem, 0);
 	init_completion(&bt_dhcp->bt_exited);
 	bt_dhcp->bt_pid = kernel_thread(_bt_dhcp_sysioc_thread, bt_dhcp, 0);
 	if (bt_dhcp->bt_pid < 0) {
+#else
+	PROC_START(_bt_dhcp_sysioc_thread, bt_dhcp, &bt_dhcp->tsk_ctl, 0);
+	if (bt_dhcp->tsk_ctl.thr_pid < 0) {
+#endif
 		WL_ERROR(("Failed in %s\n", __FUNCTION__));
-#ifdef CONFIG_LGE_BCM432X_PATCH // pecan kmalloc fail
-		kfree(bt_dhcp);
-		g_bt = NULL;
-#endif /* CONFIG_LGE_BCM432X_PATCH pecan kmalloc fail */
 		return -ENOMEM;
 	}
 
 	return 0;
 }
 
-#endif 
-
 int wl_iw_attach(struct net_device *dev, void * dhdp)
 {
-#if defined(BCMDONGLEHOST)
+	int params_size;
 	wl_iw_t *iw;
-#endif 
 #if defined(WL_IW_USE_ISCAN)
 	iscan_info_t *iscan = NULL;
-#endif
 
 	if (!dev)
 		return 0;
 
-#ifdef CONFIG_LGE_BCM432X_PATCH // pecan kmalloc fail
-	g_scan = NULL;
-
 	
-	g_scan = (void *)kmalloc(G_SCAN_RESULTS, GFP_KERNEL);
-	if (!g_scan)
-		return -ENOMEM;
+	memset(&g_wl_iw_params, 0, sizeof(wl_iw_extra_params_t));
 
-	memset(g_scan, 0, G_SCAN_RESULTS);
-	g_scan_specified_ssid = 0;
-#endif /* CONFIG_LGE_BCM432X_PATCH pecan kmalloc fail */
 
-#if defined(WL_IW_USE_ISCAN)
+#ifdef CSCAN
+	params_size = (WL_SCAN_PARAMS_FIXED_SIZE + OFFSETOF(wl_iscan_params_t, params)) +
+	    (WL_NUMCHANNELS * sizeof(uint16)) + WL_SCAN_PARAMS_SSID_MAX * sizeof(wlc_ssid_t);
+#else
+	params_size = (WL_SCAN_PARAMS_FIXED_SIZE + OFFSETOF(wl_iscan_params_t, params));
+#endif 
 	iscan = kmalloc(sizeof(iscan_info_t), GFP_KERNEL);
+
 	if (!iscan)
-#ifdef CONFIG_LGE_BCM432X_PATCH // pecan kmalloc fail
-		goto fail;
-#else
 		return -ENOMEM;
-#endif /* CONFIG_LGE_BCM432X_PATCH pecan kmalloc fail */
 	memset(iscan, 0, sizeof(iscan_info_t));
-	iscan->sysioc_pid = -1;
+
+	
+	iscan->iscan_ex_params_p = (wl_iscan_params_t*)kmalloc(params_size, GFP_KERNEL);
+	if (!iscan->iscan_ex_params_p)
+		return -ENOMEM;
+	iscan->iscan_ex_param_size = params_size;
+//	iscan->sysioc_pid = -1;
 	
 	g_iscan = iscan;
 	iscan->dev = dev;
 	iscan->iscan_state = ISCAN_STATE_IDLE;
+
+#if defined(CONFIG_FIRST_SCAN)
+	g_first_broadcast_scan = BROADCAST_SCAN_FIRST_IDLE;
+	g_first_counter_scans = 0;
 	g_iscan->scan_flag = 0;
+#endif 
 
 	
 	iscan->timer_ms    = 3000;
@@ -7923,44 +9325,26 @@ int wl_iw_attach(struct net_device *dev, void * dhdp)
 	iscan->timer.data = (ulong)iscan;
 	iscan->timer.function = wl_iw_timerfunc;
 
+#if 0
 	sema_init(&iscan->sysioc_sem, 0);
 	init_completion(&iscan->sysioc_exited);
 	iscan->sysioc_pid = kernel_thread(_iscan_sysioc_thread, iscan, 0);
-	if (iscan->sysioc_pid < 0) {
-#ifdef CONFIG_LGE_BCM432X_PATCH // pecan kmalloc fail
-		kfree(iscan);
-		g_iscan = NULL;
-		goto fail;
-#else
+	if (iscan->sysioc_pid < 0)
 		return -ENOMEM;
-#endif /* CONFIG_LGE_BCM432X_PATCH pecan kmalloc fail */
-	}
-#elif defined(WL_IW_USE_ESCAN)
-	g_escan = kmalloc(sizeof(escan_info_t), GFP_KERNEL);
-	if (!g_escan)
-#ifdef CONFIG_LGE_BCM432X_PATCH // pecan kmalloc fail
-		goto fail;
 #else
+	PROC_START(_iscan_sysioc_thread, iscan, &iscan->tsk_ctl, 0);
+	if (iscan->tsk_ctl.thr_pid < 0)
 		return -ENOMEM;
-#endif /* CONFIG_LGE_BCM432X_PATCH pecan kmalloc fail */
-	memset(g_escan, 0, sizeof(escan_info_t));
-	g_escan->dev = dev;
-	g_escan->escan_state = ESCAN_STATE_IDLE;
-	g_escan->scan_flag = 0;
-#ifdef CONFIG_LGE_BCM432X_PATCH // escan buf to array
-	g_escan->escan_buf = escan_array;
-#endif /* CONFIG_LGE_BCM432X_PATCH escan buf to array */
+#endif
 #endif 
 
-#if defined(BCMDONGLEHOST)
 	iw = *(wl_iw_t **)netdev_priv(dev);
 	iw->pub = (dhd_pub_t *)dhdp;
-#endif 
+	MUTEX_LOCK_WL_SCAN_SET_INIT();
 #ifdef SOFTAP
 	priv_dev = dev;
 	MUTEX_LOCK_SOFTAP_SET_INIT(iw->pub);
-#endif /* SOFTAP */
-#ifndef CONFIG_LGE_BCM432X_PATCH // pecan kmalloc fail
+#endif 
 	g_scan = NULL;
 
 	
@@ -7970,21 +9354,16 @@ int wl_iw_attach(struct net_device *dev, void * dhdp)
 
 	memset(g_scan, 0, G_SCAN_RESULTS);
 	g_scan_specified_ssid = 0;
-#endif /* CONFIG_LGE_BCM432X_PATCH pecan kmalloc fail */
+
+#if !defined(CSCAN)
 	
 	wl_iw_init_ss_cache_ctrl();
-#ifdef COEX_DHCP
+#endif 
 	
 	wl_iw_bt_init(dev);
-#endif 
+
 
 	return 0;
-#ifdef CONFIG_LGE_BCM432X_PATCH // pecan kmalloc fail
-fail:
-	kfree(g_scan);
-	g_scan = NULL;
-	return -ENOMEM;
-#endif /* CONFIG_LGE_BCM432X_PATCH pecan kmalloc fail */
 }
 
 void wl_iw_detach(void)
@@ -7995,59 +9374,43 @@ void wl_iw_detach(void)
 
 	if (!iscan)
 		return;
+#if 0
 	if (iscan->sysioc_pid >= 0) {
 		KILL_PROC(iscan->sysioc_pid, SIGTERM);
 		wait_for_completion(&iscan->sysioc_exited);
 	}
-
+#else
+	if (iscan->tsk_ctl.thr_pid >= 0) {
+		PROC_STOP(&iscan->tsk_ctl);
+	}	
+#endif
+	MUTEX_LOCK_WL_SCAN_SET();
 	while (iscan->list_hdr) {
 		buf = iscan->list_hdr->next;
 		kfree(iscan->list_hdr);
 		iscan->list_hdr = buf;
 	}
+	MUTEX_UNLOCK_WL_SCAN_SET();
+	kfree(iscan->iscan_ex_params_p);
 	kfree(iscan);
 	g_iscan = NULL;
-#elif defined(WL_IW_USE_ESCAN)
-	if (!g_escan)
-		return;
-	kfree(g_escan);
-	g_escan = NULL;
 #endif 
 
 	if (g_scan)
 		kfree(g_scan);
 
 	g_scan = NULL;
-
+#if !defined(CSCAN)
 	wl_iw_release_ss_cache_ctrl();
-#ifdef COEX_DHCP
-	wl_iw_bt_release();
 #endif 
+	wl_iw_bt_release();
+
 #ifdef SOFTAP
 	if (ap_cfg_running) {
 		WL_TRACE(("\n%s AP is going down\n", __FUNCTION__));
-		wl_iw_send_priv_event(priv_dev, "AP_DOWN");
-	}
-#endif /* SOFTAP */
-}
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-11-19, Support Host Wakeup */
-#if defined(CONFIG_BRCM_LGE_WL_HOSTWAKEUP)
-int del_wl_timers(void)
-{
-#if defined(WL_IW_USE_ISCAN)
-	iscan_info_t *iscan = NULL;
 
-	if(g_iscan)
-		iscan = g_iscan;
-	else
-	{
-		printk("[WiFi] Error g_scan is NULL \n");
-		return -1;
+		wl_iw_send_priv_event(priv_dev, "AP_DOWN");
 	}
+#endif
 
-	del_timer_sync(&iscan->timer);
-#endif	/* defined(WL_IW_USE_ISCAN) */
-	return 0;
 }
-#endif /* CONFIG_BRCM_LGE_WL_HOSTWAKEUP */
-/* LGE_CHANGE_S [yoohoo@lge.com] 2009-11-19, Support Host Wakeup */
diff --git a/drivers/net/wireless/bcm43291/src/wl/sys/wl_iw.h b/drivers/net/wireless/bcm43291/src/wl/sys/wl_iw.h
index 3af1fca..85ac29b 100644
--- a/drivers/net/wireless/bcm43291/src/wl/sys/wl_iw.h
+++ b/drivers/net/wireless/bcm43291/src/wl/sys/wl_iw.h
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: wl_iw.h,v 1.5.34.1.6.7.4.4 2010/04/01 23:18:43 Exp $
+ * $Id: wl_iw.h,v 1.5.34.1.6.36.4.16 2011/01/14 22:25:05 Exp $
  */
 
 
@@ -34,6 +34,41 @@
 #include <proto/ethernet.h>
 #include <wlioctl.h>
 
+#define WL_SCAN_PARAMS_SSID_MAX 	10
+#define GET_SSID			"SSID="
+#define GET_CHANNEL			"CH="
+#define GET_NPROBE 			"NPROBE="
+#define GET_ACTIVE_ASSOC_DWELL  	"ACTIVE="
+#define GET_PASSIVE_ASSOC_DWELL  	"PASSIVE="
+#define GET_HOME_DWELL  		"HOME="
+#define GET_SCAN_TYPE			"TYPE="
+
+#define BAND_GET_CMD				"BANDGET"
+#define BAND_SET_CMD				"BANDSET"
+#define DTIM_SKIP_GET_CMD			"DTIMSKIPGET"
+#define DTIM_SKIP_SET_CMD			"DTIMSKIPSET"
+#define SETSUSPEND_CMD				"SETSUSPENDOPT"
+#define PNOSSIDCLR_SET_CMD			"PNOSSIDCLR"
+#define PNOSETUP_SET_CMD			"PNOSETUP " 
+#define PNOENABLE_SET_CMD			"PNOFORCE"
+#define PNODEBUG_SET_CMD			"PNODEBUG"
+
+#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+
+
+typedef struct wl_iw_extra_params {
+	int 	target_channel; 
+} wl_iw_extra_params_t;
+
+struct cntry_locales_custom {
+	char iso_abbrev[WLC_CNTRY_BUF_SZ];	
+	char custom_locale[WLC_CNTRY_BUF_SZ];	
+	int32 custom_locale_rev;		
+};
+
+#define SOFTAP 1
+
 
 #define	WL_IW_RSSI_MINVAL		-200	
 #define	WL_IW_RSSI_NO_SIGNAL	-91	
@@ -44,7 +79,8 @@
 #define	WL_IW_RSSI_EXCELLENT	-57	
 #define	WL_IW_RSSI_INVALID	 0	
 #define MAX_WX_STRING 80
-#define isprint(c) bcm_isprint(c)
+#define isprintf(c) bcm_isprint(c)
+
 #define WL_IW_SET_ACTIVE_SCAN	(SIOCIWFIRSTPRIV+1)
 #define WL_IW_GET_RSSI			(SIOCIWFIRSTPRIV+3)
 #define WL_IW_SET_PASSIVE_SCAN	(SIOCIWFIRSTPRIV+5)
@@ -60,18 +96,18 @@
 #define WL_AP_BSS_START         (SIOCIWFIRSTPRIV+21)
 #define AP_LPB_CMD              (SIOCIWFIRSTPRIV+23)
 #define WL_AP_STOP              (SIOCIWFIRSTPRIV+25)
-#if defined(CONFIG_LGE_BCM432X_PATCH)
 #define WL_FW_RELOAD            (SIOCIWFIRSTPRIV+27)
+#if defined(CONFIG_LGE_BCM432X_PATCH) && defined(SOFTAP)
 #define WL_IW_SET_STOP_SOFTAP	(SIOCIWFIRSTPRIV+29)
 #define WL_IW_SET_START_SOFTAP	(SIOCIWFIRSTPRIV+31)
-#define WL_AP_SPARE1            (SIOCIWFIRSTPRIV+33)
-#define WL_AP_SPARE2            (SIOCIWFIRSTPRIV+35)
-#define WL_AP_SPARE3            (SIOCIWFIRSTPRIV+37)
+#define WL_AP_STA_DISASSOC            (SIOCIWFIRSTPRIV+33)
+#define WL_COMBO_SCAN            (SIOCIWFIRSTPRIV+35)
 #else
-#define WL_AP_SPARE1            (SIOCIWFIRSTPRIV+27)
-#define WL_AP_SPARE2            (SIOCIWFIRSTPRIV+29)
-#define WL_AP_SPARE3            (SIOCIWFIRSTPRIV+31)
-#endif /* CONFIG_LGE_BCM432X_PATCH */
+#define WL_AP_STA_DISASSOC		(SIOCIWFIRSTPRIV+29)
+#define WL_COMBO_SCAN           (SIOCIWFIRSTPRIV+31)
+#endif	/* defined(CONFIG_LGE_BCM432X_PATCH) && defined(SOFTAP) */
+
+
 #define 		G_SCAN_RESULTS 8*1024
 #define 		WE_ADD_EVENT_FIX	0x80
 #define          G_WLAN_SET_ON	0
@@ -91,38 +127,27 @@ typedef struct wl_iw {
 	int spy_num;
 	uint32 pwsec;			
 	uint32 gwsec;			
-	// louislee : added for WPS
-	bool privacy_invoked;       /* IW_AUTH_PRIVACY_INVOKED setting */
+	bool privacy_invoked; 		
 
 	struct ether_addr spy_addr[IW_MAX_SPY];
 	struct iw_quality spy_qual[IW_MAX_SPY];
 	void  *wlinfo;
-#if defined(BCMDONGLEHOST)
 	dhd_pub_t * pub;
-#endif 
 } wl_iw_t;
 
-struct wl_ctrl {
-	struct timer_list *timer;
-	struct net_device *dev;
-	long sysioc_pid;
-	struct semaphore timer_sem;
-	struct completion sysioc_exited;
-};
-
-#define WLC_IW_SS_CACHE_MAXLEN				512
+int	 wl_control_wl_start(struct net_device *dev);
+#define WLC_IW_SS_CACHE_MAXLEN				2048
 #define WLC_IW_SS_CACHE_CTRL_FIELD_MAXLEN	32
 #define WLC_IW_BSS_INFO_MAXLEN 				\
 	(WLC_IW_SS_CACHE_MAXLEN - WLC_IW_SS_CACHE_CTRL_FIELD_MAXLEN)
 
 typedef struct wl_iw_ss_cache {
+	struct wl_iw_ss_cache *next;
+	int dirty;
 	uint32 buflen;
 	uint32 version;
 	uint32 count;
 	wl_bss_info_t bss_info[1];
-	char dummy[WLC_IW_BSS_INFO_MAXLEN - sizeof(wl_bss_info_t)];
-	int dirty;
-	struct wl_iw_ss_cache *next;
 } wl_iw_ss_cache_t;
 
 typedef struct wl_iw_ss_cache_ctrl {
@@ -153,9 +178,13 @@ struct ap_profile {
 	uint32	channel; 
 	uint32	preamble;
 	uint32	max_scb;	
+	uint32  closednet;  
+	char country_code[WLC_CNTRY_BUF_SZ];
 };
+
+
 #define MACLIST_MODE_DISABLED	0
-#define MACLIST_MODE_ENABLED	1
+#define MACLIST_MODE_DENY		1
 #define MACLIST_MODE_ALLOW		2
 struct mflist {
 	uint count;
@@ -163,10 +192,9 @@ struct mflist {
 };
 struct mac_list_set {
 	uint32	mode;
-	struct mflist white_list;
-	struct mflist black_list;
+	struct mflist mac_list;
 };
-#endif /* SOFTAP */
+#endif   
 
 #if WIRELESS_EXT > 12
 #include <net/iw_handler.h>
@@ -178,6 +206,11 @@ extern void wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void* data);
 extern int wl_iw_get_wireless_stats(struct net_device *dev, struct iw_statistics *wstats);
 int wl_iw_attach(struct net_device *dev, void * dhdp);
 void wl_iw_detach(void);
+extern int net_os_set_suspend_disable(struct net_device *dev, int val);
+extern int net_os_set_suspend(struct net_device *dev, int val);
+extern int net_os_set_dtim_skip(struct net_device *dev, int val);
+extern int net_os_set_packet_filter(struct net_device *dev, int val);
+extern void get_customized_country_code(char *country_iso_code, wl_country_t *cspec);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
 #define IWE_STREAM_ADD_EVENT(info, stream, ends, iwe, extra) \
@@ -195,4 +228,82 @@ void wl_iw_detach(void);
 	iwe_stream_add_point(stream, ends, iwe, extra)
 #endif
 
+extern int dhd_pno_enable(dhd_pub_t *dhd, int pfn_enabled);
+extern int dhd_pno_clean(dhd_pub_t *dhd);
+extern int dhd_pno_set(dhd_pub_t *dhd, wlc_ssid_t* ssids_local, int nssid, ushort  scan_fr);
+extern int dhd_pno_get_status(dhd_pub_t *dhd);
+extern int dhd_dev_pno_reset(struct net_device *dev);
+extern int dhd_dev_pno_set(struct net_device *dev, wlc_ssid_t* ssids_local, \
+				 int nssid, ushort  scan_fr);
+extern int dhd_dev_pno_enable(struct net_device *dev,  int pfn_enabled);
+extern int dhd_dev_get_pno_status(struct net_device *dev);
+void	dhd_bus_country_set(struct net_device *dev, wl_country_t *cspec);
+extern int dhd_get_dtim_skip(dhd_pub_t *dhd);
+
+#define PNO_TLV_PREFIX			'S'
+#define PNO_TLV_VERSION			'1'
+#define PNO_TLV_SUBVERSION 		'2'
+#define PNO_TLV_RESERVED		'0'
+#define PNO_TLV_TYPE_SSID_IE		'S'
+#define PNO_TLV_TYPE_TIME		'T'
+#define  PNO_EVENT_UP			"PNO_EVENT"
+#define PNO_SCAN_MAX_FW		508	
+
+typedef struct cmd_tlv {
+	char prefix;
+	char version;
+	char subver;
+	char reserved;
+} cmd_tlv_t;
+
+
+
+
+typedef struct cscan_tlv {
+	char prefix;
+	char version;
+	char subver;
+	char reserved;
+} cscan_tlv_t;
+
+#define CSCAN_COMMAND				"CSCAN "
+#define CSCAN_TLV_PREFIX 			'S'
+#define CSCAN_TLV_VERSION			1
+#define CSCAN_TLV_SUBVERSION			0
+#define CSCAN_TLV_TYPE_SSID_IE          'S'
+#define CSCAN_TLV_TYPE_CHANNEL_IE   'C'
+#define CSCAN_TLV_TYPE_NPROBE_IE     'N'
+#define CSCAN_TLV_TYPE_ACTIVE_IE      'A'
+#define CSCAN_TLV_TYPE_PASSIVE_IE    'P'
+#define CSCAN_TLV_TYPE_HOME_IE         'H'
+#define CSCAN_TLV_TYPE_STYPE_IE        'T'
+
+#ifdef SOFTAP_TLV_CFG
+
+#define SOFTAP_SET_CMD				"SOFTAPSET "
+#define SOFTAP_TLV_PREFIX			'A'
+#define SOFTAP_TLV_VERSION			'1'
+#define SOFTAP_TLV_SUBVERSION		'0'
+#define SOFTAP_TLV_RESERVED		'0'
+
+#define TLV_TYPE_SSID				'S'
+#define TLV_TYPE_SECUR				'E'
+#define TLV_TYPE_KEY				'K'
+#define TLV_TYPE_CHANNEL			'C'
+#endif 
+
+extern int wl_iw_parse_channel_list_tlv(char** list_str, uint16* channel_list, \
+					int channel_num, int *bytes_left);
+
+extern int wl_iw_parse_data_tlv(char** list_str, void  *dst, int dst_size, \
+					const char token, int input_size, int *bytes_left);
+
+extern int wl_iw_parse_ssid_list_tlv(char** list_str, wlc_ssid_t* ssid, \
+					int max, int *bytes_left);
+
+extern int wl_iw_parse_ssid_list(char** list_str, wlc_ssid_t* ssid, int idx, int max);
+
+extern int wl_iw_parse_channel_list(char** list_str, uint16* channel_list, int channel_num);
+
+
 #endif 
